{
  "summary": {
    "total_servers": 353,
    "analyzed_servers": 353,
    "failed_servers": 0
  },
  "results": {
    "AO Generative AI CP3 Smithery Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the AO Generative AI CP3 Smithery Server are read-only operations that retrieve data from external sources (e.g., weather, sea conditions, earthquakes, fire risk, UV index). None of the functions have parameters or descriptions indicating they modify system state, create sessions, store data, or alter configurations. Each function operates independently, with no indication of shared mutable state, persistent context, or inter-function dependencies. Inputs are self-contained (e.g., city name, day, area), and outputs are derived solely from external APIs without reliance on prior function calls. There is no evidence of side effects or state persistence across invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1099,
        "completion_tokens": 156,
        "total_tokens": 1255
      },
      "function_count": 6,
      "functions": [
        "ao-generative-ai-cp3-smithery-server-get_earthquakes",
        "ao-generative-ai-cp3-smithery-server-weather_warnings",
        "ao-generative-ai-cp3-smithery-server-uv_forecast",
        "ao-generative-ai-cp3-smithery-server-get_sea_forecast",
        "ao-generative-ai-cp3-smithery-server-get_forecast",
        "ao-generative-ai-cp3-smithery-server-get_fire_risk_forecast"
      ]
    },
    "Q-Anon Posts/Drops Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "After analyzing all available tools in the Q-Anon Posts/Drops Server, there is no evidence of any function that modifies persistent state (e.g., create, update, or delete operations). All provided functions are read-only queries that retrieve data based on input parameters such as post ID, date ranges, author IDs, or search terms. None of the functions have side effects that alter server state, set configurations, establish sessions, or store data that would influence subsequent calls. Each function operates independently and does not rely on prior interactions. For example, calling `search_posts` does not affect the behavior of `get_post_by_id`, nor does using `analyze_post` depend on a previously established context from another call. Since all operations are stateless retrievals or analyses based solely on explicit input arguments, the server exhibits no stateful behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1832,
        "completion_tokens": 193,
        "total_tokens": 2025
      },
      "function_count": 8,
      "functions": [
        "q-anon-posts/drops-server-get_posts_by_author_id",
        "q-anon-posts/drops-server-get_post_by_id_tool",
        "q-anon-posts/drops-server-search_posts",
        "q-anon-posts/drops-server-word_cloud_by_date_range",
        "q-anon-posts/drops-server-get_timeline_summary",
        "q-anon-posts/drops-server-get_posts_by_date",
        "q-anon-posts/drops-server-analyze_post",
        "q-anon-posts/drops-server-word_cloud_by_post_ids"
      ]
    },
    "Pokémcp": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Pokémcp server are read-only operations that retrieve Pokémon data from external sources (e.g., PokeAPI) based on either randomness or natural language queries. None of the functions perform create, update, or delete operations that would modify persistent state. Each function call is independent and does not rely on or alter any shared context, session, configuration, or stored data. The outputs depend solely on input parameters and external API responses, with no indication of internal state being maintained across calls. There is no evidence that calling one function affects the behavior or outcome of another.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 876,
        "completion_tokens": 143,
        "total_tokens": 1019
      },
      "function_count": 4,
      "functions": [
        "pokémcp-random-pokemon-by-type",
        "pokémcp-random-pokemon-from-region",
        "pokémcp-pokemon-query",
        "pokémcp-random-pokemon"
      ]
    },
    "Solana Client": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Solana Client MCP server includes functions that modify persistent state on the blockchain or within the node's context, and other functions that depend on this modified state. Specifically, `request_airdrop` modifies the account balance by increasing the lamport balance of a given address. Subsequent calls to `get_balance` for the same address will reflect this change, indicating that `get_balance` depends on the state altered by `request_airdrop`. This represents a clear state dependency where one function (airdrop) mutates system state and another (balance query) observes it.\n\nAdditionally, `send_transaction` modifies the blockchain state (e.g., token balances, account data), and functions like `get_transaction`, `get_account_info`, or `get_token_account_balance` can later read the resulting state. These are fundamental read-after-write dependencies inherent in stateful systems. While the blockchain itself is externally persistent, the MCP server acts as an interface to it, and its ability to both mutate and observe shared state across function calls qualifies it as stateful in the context of MCP semantics.",
      "state_dependencies": [
        {
          "function_a": "request_airdrop",
          "function_b": "get_balance",
          "state_description": "Account balance state modified by airdrop is read by get_balance"
        },
        {
          "function_a": "send_transaction",
          "function_b": "get_transaction",
          "state_description": "Transaction confirmation state created by send_transaction is retrieved by get_transaction"
        },
        {
          "function_a": "send_transaction",
          "function_b": "get_account_info",
          "state_description": "Account data or balance changes made via transaction are observable through get_account_info"
        },
        {
          "function_a": "send_transaction",
          "function_b": "get_token_account_balance",
          "state_description": "Token account balance updated by transaction is read by get_token_account_balance"
        }
      ],
      "token_usage": {
        "prompt_tokens": 5357,
        "completion_tokens": 414,
        "total_tokens": 5771
      },
      "function_count": 44,
      "functions": [
        "solana-client-get_epoch_schedule",
        "solana-client-get_multiple_accounts",
        "solana-client-get_supply",
        "solana-client-get_recent_performance_samples",
        "solana-client-get_inflation_governor",
        "solana-client-get_transaction_count",
        "solana-client-get_token_accounts_by_owner",
        "solana-client-get_token_accounts_by_delegate",
        "solana-client-get_blocks",
        "solana-client-get_block_height",
        "solana-client-get_transaction",
        "solana-client-get_first_available_block",
        "solana-client-confirm_transaction",
        "solana-client-get_block_time",
        "solana-client-send_transaction",
        "solana-client-get_token_supply",
        "solana-client-get_slot",
        "solana-client-get_leader_schedule",
        "solana-client-get_latest_blockhash",
        "solana-client-get_signatures_for_address",
        "solana-client-get_epoch_info",
        "solana-client-get_identity",
        "solana-client-get_minimum_balance_for_rent_exemption",
        "solana-client-get_program_accounts",
        "solana-client-get_cluster_nodes",
        "solana-client-get_fee_for_message",
        "solana-client-get_inflation_reward",
        "solana-client-get_genesis_hash",
        "solana-client-is_connected",
        "solana-client-get_token_largest_accounts",
        "solana-client-get_account_info",
        "solana-client-get_signature_statuses",
        "solana-client-get_block",
        "solana-client-validator_exit",
        "solana-client-get_version",
        "solana-client-get_minimum_ledger_slot",
        "solana-client-get_vote_accounts",
        "solana-client-get_balance",
        "solana-client-get_largest_accounts",
        "solana-client-get_block_commitment",
        "solana-client-get_token_account_balance",
        "solana-client-request_airdrop",
        "solana-client-get_inflation_rate",
        "solana-client-get_slot_leader"
      ]
    },
    "LinkedIn Digital Intelligence Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The LinkedIn Digital Intelligence Server exhibits clear stateful behavior based on the function definitions and their interdependencies. Specifically, several tools are designed to create or modify persistent state (e.g., reports), while others depend on that state being present to function correctly.  \n\nKey evidence includes:\n- **create-linkedin-report** creates a new report with a specific audience and baseline definition. This operation modifies server-side state by persisting a new report object that can be referenced later via an ID.\n- **get-linkedin-report**, **get-linkedin-insights**, **get-linkedin-categories**, and potentially other read operations require a `reportId` parameter, indicating they retrieve data about a previously created report.\n- The existence of **get-linkedin-reports** suggests enumeration of user-specific reports, further implying that reports are stored and maintained across sessions.\n\nThis establishes a direct dependency: a report must first be created (via `create-linkedin-report`) before it can be retrieved or analyzed using other tools. Without prior creation, calls to fetch insights or categories for a non-existent report would fail or return empty results.\n\nAdditionally, while not directly tied to report state, authentication-related functions like **initiate-linkedin-device-auth** and **get-linkedin-account** suggest session or token-based authentication flows, which may also introduce session state. However, the strongest and most explicit statefulness comes from the report lifecycle.",
      "state_dependencies": [
        {
          "function_a": "create-linkedin-report",
          "function_b": "get-linkedin-report",
          "state_description": "The report ID generated by create-linkedin-report is required for get-linkedin-report to retrieve the specific report."
        },
        {
          "function_a": "create-linkedin-report",
          "function_b": "get-linkedin-insights",
          "state_description": "The report ID from create-linkedin-report must exist for get-linkedin-insights to fetch insights associated with that report."
        },
        {
          "function_a": "create-linkedin-report",
          "function_b": "get-linkedin-categories",
          "state_description": "The report ID created by create-linkedin-report is required for get-linkedin-categories to return category data for that report."
        }
      ],
      "token_usage": {
        "prompt_tokens": 3625,
        "completion_tokens": 473,
        "total_tokens": 4098
      },
      "function_count": 12,
      "functions": [
        "linkedin-digital-intelligence-server-list-linkedin-facet-values",
        "linkedin-digital-intelligence-server-initiate-linkedin-device-auth",
        "linkedin-digital-intelligence-server-get-linkedin-typeahead",
        "linkedin-digital-intelligence-server-create-linkedin-report",
        "linkedin-digital-intelligence-server-list-linkedin-typeahead-facets",
        "linkedin-digital-intelligence-server-get-linkedin-categories",
        "linkedin-digital-intelligence-server-get-linkedin-report",
        "linkedin-digital-intelligence-server-get-linkedin-account",
        "linkedin-digital-intelligence-server-estimate-linkedin-audience",
        "linkedin-digital-intelligence-server-get-linkedin-insights",
        "linkedin-digital-intelligence-server-get-linkedin-reports",
        "linkedin-digital-intelligence-server-get-linkedin-audience-definition-examples"
      ]
    },
    "Laravel MCP Companion": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior due to the presence of functions that modify persistent documentation state (e.g., updating or syncing documentation from external sources), which subsequently affects the results of read and search operations. Specifically, `update_laravel_docs` and `update_external_laravel_docs` fetch and synchronize the latest documentation from GitHub, thereby altering the internal state of the stored docs. This updated state directly impacts subsequent calls to functions like `read_laravel_doc_content`, `search_laravel_docs`, `list_laravel_docs`, and others that retrieve or search documentation content. Without a prior update, these functions may return stale or outdated information. Similarly, `laravel_docs_info` reflects metadata about the current state of documentation, including last update times—information that changes as a result of update operations. This dependency of retrieval/search functions on prior update actions confirms stateful behavior.",
      "state_dependencies": [
        {
          "function_a": "update_laravel_docs",
          "function_b": "read_laravel_doc_content",
          "state_description": "Updated documentation files from the specified Laravel version are made available for reading; without an update, content may be stale."
        },
        {
          "function_a": "update_laravel_docs",
          "function_b": "search_laravel_docs",
          "state_description": "Search results depend on the current set of documentation files, which can be refreshed by updating from the official repository."
        },
        {
          "function_a": "update_laravel_docs",
          "function_b": "list_laravel_docs",
          "state_description": "The list of available documentation files may change after an update, especially for new Laravel versions."
        },
        {
          "function_a": "update_laravel_docs",
          "function_b": "laravel_docs_info",
          "state_description": "Metadata such as last update time and commit information is modified when documentation is synced."
        },
        {
          "function_a": "update_external_laravel_docs",
          "function_b": "search_external_laravel_docs",
          "state_description": "External documentation content must be up-to-date for accurate search results across Laravel services."
        },
        {
          "function_a": "update_external_laravel_docs",
          "function_b": "get_laravel_service_info",
          "state_description": "Service information details depend on the currently cached or updated external documentation."
        }
      ],
      "token_usage": {
        "prompt_tokens": 2568,
        "completion_tokens": 507,
        "total_tokens": 3075
      },
      "function_count": 16,
      "functions": [
        "laravel-mcp-companion-update_laravel_docs",
        "laravel-mcp-companion-read_laravel_doc_content",
        "laravel-mcp-companion-search_laravel_docs",
        "laravel-mcp-companion-get_laravel_package_info",
        "laravel-mcp-companion-get_laravel_package_categories",
        "laravel-mcp-companion-list_laravel_docs",
        "laravel-mcp-companion-search_laravel_docs_with_context",
        "laravel-mcp-companion-get_doc_structure",
        "laravel-mcp-companion-get_laravel_package_recommendations",
        "laravel-mcp-companion-search_external_laravel_docs",
        "laravel-mcp-companion-get_laravel_service_info",
        "laravel-mcp-companion-list_laravel_services",
        "laravel-mcp-companion-update_external_laravel_docs",
        "laravel-mcp-companion-browse_docs_by_category",
        "laravel-mcp-companion-laravel_docs_info",
        "laravel-mcp-companion-get_features_for_laravel_package"
      ]
    },
    "Currency Converter MCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "currency-converter-mcp-convert_currency"
      ]
    },
    "Weather360 Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "weather360-server-get_live_weather"
      ]
    },
    "Formula 1 Schedule": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the \"Formula 1 Schedule\" MCP server are read-only operations that retrieve data based on a specified year. Each function—`fetch_f1_calendar`, `fetch_f1_team_standings`, `fetch_f1_driver_standings`, and `fetch_f1_race_results`—accepts a `year` parameter and returns data for that year without indicating any side effects such as creating, modifying, or deleting persistent state. There is no evidence of shared mutable state, session creation, configuration changes, or dependencies between function calls. The server appears to provide idempotent access to historical or scheduled F1 data, likely sourced from an external API or database, with caching mentioned only for performance (not implying user-visible state). Since no function modifies state that would affect the behavior of another, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1019,
        "completion_tokens": 194,
        "total_tokens": 1213
      },
      "function_count": 4,
      "functions": [
        "formula-1-schedule-fetch_f1_driver_standings",
        "formula-1-schedule-fetch_f1_race_results",
        "formula-1-schedule-fetch_f1_team_standings",
        "formula-1-schedule-fetch_f1_calendar"
      ]
    },
    "Memory Palace": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The MCP server is clearly stateful, as multiple functions are designed to create persistent data structures (palaces, rooms, memory items, journeys) that must exist before other functions can operate on them. Several tool interactions depend on prior state modifications. For example, creating a room requires a palace ID from a previously created palace; adding a memory item requires a room ID from an existing room; taking a journey requires a journey ID from a pre-created journey. These dependencies indicate that the system maintains shared, persistent state across function calls. Additionally, functions like `get_palace_layout`, `take_journey`, and `search_memories` retrieve or act upon data that must have been previously written using `create_palace`, `create_room`, or `add_memory_item`. This write-then-read pattern across interdependent resources confirms stateful behavior. There is no indication that this is purely functional or stateless—each entity builds upon prior side effects.",
      "state_dependencies": [
        {
          "function_a": "create_palace",
          "function_b": "create_room",
          "state_description": "The palaceId returned by create_palace must be used in create_room to associate the room with a valid palace."
        },
        {
          "function_a": "create_palace",
          "function_b": "create_journey",
          "state_description": "The palaceId from create_palace is required to create a journey within that palace."
        },
        {
          "function_a": "create_palace",
          "function_b": "get_palace_layout",
          "state_description": "get_palace_layout requires a palaceId from a previously created palace to return its structure."
        },
        {
          "function_a": "create_room",
          "function_b": "add_memory_item",
          "state_description": "The roomId returned by create_room must be provided to add_memory_item so the item can be placed in the correct room."
        },
        {
          "function_a": "create_journey",
          "function_b": "take_journey",
          "state_description": "The journeyId generated by create_journey is required input for take_journey to review the memory path."
        },
        {
          "function_a": "add_memory_item",
          "function_b": "search_memories",
          "state_description": "Memory items added via add_memory_item become part of the searchable index used by search_memories."
        }
      ],
      "token_usage": {
        "prompt_tokens": 2011,
        "completion_tokens": 516,
        "total_tokens": 2527
      },
      "function_count": 9,
      "functions": [
        "memory-palace-search_memories",
        "memory-palace-get_palace_layout",
        "memory-palace-get_statistics",
        "memory-palace-take_journey",
        "memory-palace-list_palaces",
        "memory-palace-create_room",
        "memory-palace-add_memory_item",
        "memory-palace-create_palace",
        "memory-palace-create_journey"
      ]
    },
    "ConferenceSearcher": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "conferencesearcher-get_events"
      ]
    },
    "BrasilAPI MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the BrasilAPI MCP Server are read-only data retrieval functions. None of the functions perform create, update, or delete operations that would modify persistent state on the server. Each function operates independently and does not rely on prior function calls to succeed. For example, while get_bank_by_code requires a bank code, this code is publicly obtainable via get_all_banks and does not represent a dynamically created or session-specific state. The dependency between get_all_banks and get_bank_by_code is informational (schema/data reference), not stateful—no mutable context, session, or configuration is established or modified across calls. There is no indication of shared sessions, authentication tokens, cached data, or configurations that persist and affect behavior across function invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1070,
        "completion_tokens": 178,
        "total_tokens": 1248
      },
      "function_count": 6,
      "functions": [
        "brasilapi-mcp-server-get_cnpj",
        "brasilapi-mcp-server-get_isbn",
        "brasilapi-mcp-server-get_postal_code_v2",
        "brasilapi-mcp-server-get_bank_by_code",
        "brasilapi-mcp-server-get_all_banks",
        "brasilapi-mcp-server-get_postal_code_v1"
      ]
    },
    "Elevator Pitch": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The two available tools, `analyze_idea_tool` and `generate_pitch_tool`, appear to be stateless in nature. The `analyze_idea_tool` extracts structured information (sector, target audience, problem, solution) from a given startup idea but does not indicate any persistent storage or modification of system-wide state. The `generate_pitch_tool` generates an elevator pitch based on explicit input parameters (sector, target_audience, problem, solution, tone), all of which must be provided directly in the function call. There is no indication that calling `analyze_idea_tool` automatically sets up context or state that is later read by `generate_pitch_tool`. Each tool operates independently, relying solely on the inputs provided during invocation, with no shared session, configuration, or stored data implied by the tool definitions. Therefore, there is no evidence of cross-function state dependency.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 754,
        "completion_tokens": 201,
        "total_tokens": 955
      },
      "function_count": 2,
      "functions": [
        "elevator-pitch-analyze_idea_tool",
        "elevator-pitch-generate_pitch_tool"
      ]
    },
    "DefiLlama API Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The DefiLlama API Server, as exposed through this MCP interface, consists exclusively of read-only functions that retrieve financial and blockchain data (e.g., TVL, prices, fees, volumes). None of the available tools perform create, update, or delete operations. All functions are idempotent and do not modify any server-side state such as configurations, sessions, or stored data. Each function operates independently, relying solely on external data sources rather than internal mutable state. There is no indication of shared context, session tokens, configuration flags, or cached values set by one function and used by another. The parameters for each tool are self-contained (e.g., protocol slugs, chain names), and outputs depend only on current API data, not prior interactions. Therefore, no stateful dependencies exist between function calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2281,
        "completion_tokens": 190,
        "total_tokens": 2471
      },
      "function_count": 16,
      "functions": [
        "defillama-api-server-get_summary_fees__by_protocol",
        "defillama-api-server-get_summary_dexs__by_protocol",
        "defillama-api-server-get_overview_dexs",
        "defillama-api-server-get_protocol__by_protocol",
        "defillama-api-server-get_pools",
        "defillama-api-server-get_v2_historicalChainTvl__by_chain",
        "defillama-api-server-get_v2_historicalChainTvl",
        "defillama-api-server-get_overview_dexs__by_chain",
        "defillama-api-server-get_chart__by_pool",
        "defillama-api-server-get_overview_fees__by_chain",
        "defillama-api-server-get_v2_chains",
        "defillama-api-server-get_overview_fees",
        "defillama-api-server-get_protocols",
        "defillama-api-server-get_stablecoincharts_all",
        "defillama-api-server-get_tvl__by_protocol",
        "defillama-api-server-get_prices_current__by_coins"
      ]
    },
    "PapersWithCode Client": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The PapersWithCode Client provides only read/query operations against a research database via the PapersWithCode API. All available tools are designed to retrieve data—such as papers, authors, conferences, methods, and datasets—based on identifiers or search criteria. None of the functions perform create, update, or delete operations that would modify persistent state on the server. Furthermore, all function calls are self-contained and do not rely on prior interactions (e.g., no session setup, authentication token generation, or configuration setting is required). Each function takes explicit parameters (like IDs or names) to locate resources, and there is no evidence of shared mutable context, sessions, or configurations that persist across requests. Therefore, the behavior of any function call does not depend on previous function calls, indicating a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 3963,
        "completion_tokens": 186,
        "total_tokens": 4149
      },
      "function_count": 20,
      "functions": [
        "paperswithcode-client-list_research_area_tasks",
        "paperswithcode-client-search_authors",
        "paperswithcode-client-list_paper_datasets",
        "paperswithcode-client-list_paper_results",
        "paperswithcode-client-get_conference_proceeding",
        "paperswithcode-client-get_conference",
        "paperswithcode-client-search_papers",
        "paperswithcode-client-get_research_area",
        "paperswithcode-client-list_conference_proceedings",
        "paperswithcode-client-list_conference_papers",
        "paperswithcode-client-read_paper_from_url",
        "paperswithcode-client-list_paper_methods",
        "paperswithcode-client-list_papers_by_author_name",
        "paperswithcode-client-list_paper_tasks",
        "paperswithcode-client-get_paper",
        "paperswithcode-client-list_paper_repositories",
        "paperswithcode-client-list_conferences",
        "paperswithcode-client-list_papers_by_author_id",
        "paperswithcode-client-search_research_areas",
        "paperswithcode-client-get_paper_author"
      ]
    },
    "ChEMBL Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all 46 available tools in the ChEMBL Server MCP, there is no evidence of state-modifying operations (e.g., create, update, delete) or any mechanism for storing, modifying, or retrieving persistent state across function calls. All functions are read-only or transformational in nature:\n\n- The majority of tools retrieve data based on identifiers (e.g., `example_assay`, `example_molecule`, `example_document`) or perform deterministic chemical computations (e.g., `example_canonicalizeSmiles`, `example_smiles2inchiKey`, `example_standardize`).\n- Functions such as `example_chembl_id_lookup`, `example_description_utils`, and `example_official_utils` retrieve metadata about ChEMBL entities but do not alter server state.\n- Chemical computation tools (e.g., descriptor generation, structural alerts, SVG rendering) operate purely on input SMILES or InChI strings and return derived outputs without side effects.\n- There are no session management functions, configuration setters, authentication flows, or caching mechanisms that would introduce shared context between calls.\n- No function returns a value (such as a token, session ID, or reference handle) that is required as input to another function.\n\nWhile it's theoretically possible that some internal state (like rate-limiting or logging) exists outside the scope of these tools, from an API contract perspective, none of the exposed functions exhibit interdependencies where one call affects the behavior or output of another.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 5515,
        "completion_tokens": 324,
        "total_tokens": 5839
      },
      "function_count": 46,
      "functions": [
        "chembl-server-example_is3D",
        "chembl-server-example_target_component",
        "chembl-server-example_molecule_form",
        "chembl-server-example_mechanism",
        "chembl-server-example_inchi2inchiKey",
        "chembl-server-example_compound_record",
        "chembl-server-example_inchi2svg",
        "chembl-server-example_activity",
        "chembl-server-example_compound_structural_alert",
        "chembl-server-example_biotherapeutic",
        "chembl-server-example_highlightSmilesFragmentSvg",
        "chembl-server-example_drug_warning",
        "chembl-server-example_status",
        "chembl-server-example_getParent",
        "chembl-server-example_assay",
        "chembl-server-example_smiles2inchi",
        "chembl-server-example_drug",
        "chembl-server-example_removeHs",
        "chembl-server-example_description_utils",
        "chembl-server-example_protein_classification",
        "chembl-server-example_chembl_release",
        "chembl-server-example_assay_class",
        "chembl-server-example_source",
        "chembl-server-example_go_slim",
        "chembl-server-example_cell_line",
        "chembl-server-example_document",
        "chembl-server-example_organism",
        "chembl-server-example_molecule",
        "chembl-server-example_official_utils",
        "chembl-server-example_xref_source",
        "chembl-server-example_activity_supplementary_data_by_activity",
        "chembl-server-example_descriptors",
        "chembl-server-example_tissue",
        "chembl-server-example_smiles2inchiKey",
        "chembl-server-example_target_relation",
        "chembl-server-example_smiles2svg",
        "chembl-server-example_canonicalizeSmiles",
        "chembl-server-example_structuralAlerts",
        "chembl-server-example_standardize",
        "chembl-server-example_drug_indication",
        "chembl-server-example_chembl_id_lookup",
        "chembl-server-example_binding_site",
        "chembl-server-example_description",
        "chembl-server-example_chemblDescriptors",
        "chembl-server-example_target",
        "chembl-server-example_atc_class"
      ]
    },
    "Status Observer": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "status-observer-status"
      ]
    },
    "BoardGameGeek API Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The BoardGameGeek API Server provides read-only access to data from BoardGameGeek through its tools. All available functions are retrieval or search operations that do not create, modify, or delete any persistent state on the server side. There are no indications of functions that perform write operations (e.g., updating a user's collection, modifying ratings, creating sessions, or storing configurations). Each function operates independently, with inputs fully specified in the request parameters and outputs determined solely by those inputs and the external BGG API’s current state—not by any internal mutable state maintained across calls. Furthermore, there is no shared session context, authentication token lifecycle, or configuration setting mechanism evident in the tool definitions. While some tools reference the special value 'SELF' for user identification, this is resolved client-side or via authenticated context passed per-request rather than relying on prior function invocations to establish state. Therefore, no function modifies state that affects the behavior of another.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2219,
        "completion_tokens": 216,
        "total_tokens": 2435
      },
      "function_count": 8,
      "functions": [
        "boardgamegeek-api-server-bgg-search",
        "boardgamegeek-api-server-bgg-trade-finder",
        "boardgamegeek-api-server-bgg-details",
        "boardgamegeek-api-server-bgg-collection",
        "boardgamegeek-api-server-bgg-recommender",
        "boardgamegeek-api-server-bgg-hot",
        "boardgamegeek-api-server-bgg-price",
        "boardgamegeek-api-server-bgg-user"
      ]
    },
    "Bright Data": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exposes a suite of browser automation tools (e.g., `scraping_browser_navigate`, `scraping_browser_click`, `scraping_browser_type`, etc.) that operate within a shared browsing session context. These tools are designed to interact with a persistent headless browser instance where each action depends on the previous state of the page. For example, calling `scraping_browser_navigate` changes the current URL of the session, and subsequent calls to `scraping_browser_get_text` or `scraping_browser_click` will return results based on that navigated page. Actions like clicking links, typing into forms, scrolling, or waiting for elements all modify or depend on the evolving DOM state of this shared session. Furthermore, navigation controls such as `scraping_browser_go_back` and `scraping_browser_go_forward` explicitly rely on browser history maintained across function calls, which is a clear indicator of statefulness. Additionally, tools like `session_stats` suggest awareness of cumulative usage during a session, reinforcing the presence of persistent internal state.",
      "state_dependencies": [
        {
          "function_a": "scraping_browser_navigate",
          "function_b": "scraping_browser_get_text",
          "state_description": "The current page content after navigation determines the text returned by get_text"
        },
        {
          "function_a": "scraping_browser_navigate",
          "function_b": "scraping_browser_click",
          "state_description": "The loaded page from navigate determines which elements are available to click"
        },
        {
          "function_a": "scraping_browser_click",
          "function_b": "scraping_browser_get_html",
          "state_description": "A click may trigger dynamic content loading, affecting the HTML retrieved subsequently"
        },
        {
          "function_a": "scraping_browser_navigate",
          "function_b": "scraping_browser_screenshot",
          "state_description": "The screenshot captures the visual state of the currently navigated page"
        },
        {
          "function_a": "scraping_browser_navigate",
          "function_b": "scraping_browser_links",
          "state_description": "The list of links returned depends on the content of the currently loaded page"
        },
        {
          "function_a": "scraping_browser_type",
          "function_b": "scraping_browser_click",
          "state_description": "Text input into a form field may be required before submitting via a button click"
        },
        {
          "function_a": "scraping_browser_click",
          "function_b": "scraping_browser_go_back",
          "state_description": "The browser's back navigation depends on having previously visited pages in the session"
        },
        {
          "function_a": "scraping_browser_navigate",
          "function_b": "scraping_browser_wait_for",
          "state_description": "Waiting for an element requires that the element exists in the context of the current or dynamically loaded page"
        }
      ],
      "token_usage": {
        "prompt_tokens": 7698,
        "completion_tokens": 646,
        "total_tokens": 8344
      },
      "function_count": 60,
      "functions": [
        "bright-data-web_data_linkedin_job_listings",
        "bright-data-web_data_github_repository_file",
        "bright-data-web_data_facebook_posts",
        "bright-data-web_data_facebook_events",
        "bright-data-scraping_browser_click",
        "bright-data-web_data_amazon_product_search",
        "bright-data-web_data_reddit_posts",
        "bright-data-web_data_linkedin_posts",
        "bright-data-scrape_as_markdown",
        "bright-data-web_data_tiktok_comments",
        "bright-data-web_data_facebook_company_reviews",
        "bright-data-web_data_youtube_comments",
        "bright-data-scraping_browser_go_back",
        "bright-data-web_data_zara_products",
        "bright-data-web_data_bestbuy_products",
        "bright-data-web_data_apple_app_store",
        "bright-data-scraping_browser_screenshot",
        "bright-data-web_data_x_posts",
        "bright-data-web_data_instagram_posts",
        "bright-data-web_data_youtube_profiles",
        "bright-data-web_data_booking_hotel_listings",
        "bright-data-scraping_browser_get_text",
        "bright-data-scraping_browser_scroll_to",
        "bright-data-web_data_ebay_product",
        "bright-data-scraping_browser_links",
        "bright-data-extract",
        "bright-data-web_data_walmart_product",
        "bright-data-web_data_instagram_reels",
        "bright-data-web_data_zillow_properties_listing",
        "bright-data-web_data_amazon_product",
        "bright-data-web_data_instagram_comments",
        "bright-data-web_data_facebook_marketplace_listings",
        "bright-data-scraping_browser_scroll",
        "bright-data-web_data_linkedin_person_profile",
        "bright-data-web_data_tiktok_shop",
        "bright-data-web_data_homedepot_products",
        "bright-data-web_data_zoominfo_company_profile",
        "bright-data-web_data_crunchbase_company",
        "bright-data-scrape_as_html",
        "bright-data-web_data_instagram_profiles",
        "bright-data-web_data_tiktok_posts",
        "bright-data-web_data_tiktok_profiles",
        "bright-data-web_data_linkedin_people_search",
        "bright-data-web_data_reuter_news",
        "bright-data-session_stats",
        "bright-data-scraping_browser_go_forward",
        "bright-data-search_engine",
        "bright-data-scraping_browser_navigate",
        "bright-data-web_data_google_shopping",
        "bright-data-scraping_browser_wait_for",
        "bright-data-web_data_google_maps_reviews",
        "bright-data-web_data_linkedin_company_profile",
        "bright-data-web_data_amazon_product_reviews",
        "bright-data-web_data_google_play_store",
        "bright-data-scraping_browser_get_html",
        "bright-data-web_data_walmart_seller",
        "bright-data-web_data_etsy_products",
        "bright-data-web_data_youtube_videos",
        "bright-data-web_data_yahoo_finance_business",
        "bright-data-scraping_browser_type"
      ]
    },
    "Mutation Testing Manager": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Mutation Testing Manager MCP server exhibits clear stateful behavior. Multiple tools interact with a shared, persistent mutation testing state that is created and modified across function calls. Specifically, the `run_mutmut` tool initiates a mutation testing session, which generates and stores results (including killed, survived, and timed-out mutations) in a local cache or result store (e.g., `.mutmut-cache`). Subsequent tools such as `show_results`, `show_survivors`, `rerun_mutmut_on_survivor`, `show_mutant`, and `prioritize_survivors` all depend on this generated state to retrieve and process information about mutations. Without a prior call to `run_mutmut`, these functions would have no data to operate on and would likely return empty or error responses. Additionally, `rerun_mutmut_on_survivor` can re-execute tests on surviving mutations, potentially altering the outcome state based on updated test suites, further indicating mutable and persistent state. The presence of `clean_mutmut_cache` also confirms that there is a persistent cache that can be explicitly reset, reinforcing the existence of shared state across invocations.",
      "state_dependencies": [
        {
          "function_a": "run_mutmut",
          "function_b": "show_results",
          "state_description": "The mutation testing summary and results generated by run_mutmut are required for show_results to display the overall status."
        },
        {
          "function_a": "run_mutmut",
          "function_b": "show_survivors",
          "state_description": "Surviving mutations identified during the run_mutmut execution are listed by show_survivors; without a prior run, no survivors exist to report."
        },
        {
          "function_a": "run_mutmut",
          "function_b": "prioritize_survivors",
          "state_description": "Prioritization of survivors depends on the list of surviving mutations produced by a previous run_mutmut call."
        },
        {
          "function_a": "run_mutmut",
          "function_b": "rerun_mutmut_on_survivor",
          "state_description": "Rerunning on survivors requires an existing set of survivor mutations from a prior mutation run to target specific mutants."
        },
        {
          "function_a": "run_mutmut",
          "function_b": "show_mutant",
          "state_description": "Details for a specific mutant (diff, location) are only available after run_mutmut has discovered and recorded that mutant."
        },
        {
          "function_a": "clean_mutmut_cache",
          "function_b": "run_mutmut",
          "state_description": "Cleaning the cache resets the mutation state, affecting subsequent runs by forcing a full re-evaluation instead of resuming or incremental runs."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1765,
        "completion_tokens": 590,
        "total_tokens": 2355
      },
      "function_count": 7,
      "functions": [
        "mutation-testing-manager-clean_mutmut_cache",
        "mutation-testing-manager-show_results",
        "mutation-testing-manager-show_mutant",
        "mutation-testing-manager-rerun_mutmut_on_survivor",
        "mutation-testing-manager-run_mutmut",
        "mutation-testing-manager-prioritize_survivors",
        "mutation-testing-manager-show_survivors"
      ]
    },
    "Advanced Calculator Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Advanced Calculator Server provides purely functional mathematical operations. Each tool takes explicit numerical inputs and returns a deterministic output based solely on those inputs, with no indication of internal state modification or persistence. None of the functions perform create, update, or delete operations that affect shared state; all are idempotent and side-effect-free. There is no evidence of session management, configuration settings, cached values, or inter-function dependencies where one function relies on the side effects of another. For example, calling `add` does not influence the result of `sin`, nor does any function depend on prior computations unless explicitly passed as input. All parameters are self-contained, and default values (e.g., in the `log` function) are constant and do not change over time or across calls. Therefore, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2067,
        "completion_tokens": 188,
        "total_tokens": 2255
      },
      "function_count": 17,
      "functions": [
        "advanced-calculator-server-div",
        "advanced-calculator-server-factorial",
        "advanced-calculator-server-is_prime",
        "advanced-calculator-server-lcm",
        "advanced-calculator-server-mul",
        "advanced-calculator-server-add",
        "advanced-calculator-server-square_root",
        "advanced-calculator-server-quadratic_roots",
        "advanced-calculator-server-degrees_to_radians",
        "advanced-calculator-server-tan",
        "advanced-calculator-server-cos",
        "advanced-calculator-server-sin",
        "advanced-calculator-server-power",
        "advanced-calculator-server-sub",
        "advanced-calculator-server-gcd",
        "advanced-calculator-server-radians_to_degrees",
        "advanced-calculator-server-log"
      ]
    },
    "Shotclock": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server for \"Shotclock\" interacts with a Figma design environment, and multiple tools clearly modify persistent state within the document or node tree that subsequent functions depend on. For example, creation tools (e.g., `create_rectangle`, `create_frame`, `create_text`) alter the document structure by adding new nodes with unique IDs. These newly created nodes can then be referenced by other functions such as `get_node_info`, `set_fill_color`, `move_node`, `delete_node`, etc. This creates a clear dependency where the behavior and success of read/modify/delete operations depend on prior create operations.\n\nAdditionally, several tools like `set_text_content`, `set_fill_color`, and `resize_node` mutate existing node properties. Subsequent calls to `get_node_info`, `read_my_design`, or `get_selection` will reflect these changes, indicating shared mutable state across function calls. Tools like `clone_node` also rely on the existence of a source node, which must have been created or selected earlier.\n\nMoreover, annotation-related tools (`set_annotation`, `set_multiple_annotations`) modify metadata attached to nodes, and retrieval via `get_annotations` depends on this previously set data. Similarly, layout modification tools (`set_layout_mode`, `set_padding`, `set_axis_align`, etc.) change frame behaviors in ways that affect how children are rendered and manipulated—state that persists and influences future interactions.\n\nThe presence of multi-node operations (e.g., `get_nodes_info`, `delete_multiple_nodes`, `set_multiple_text_contents`) further implies an expectation of shared context and consistency in node state across calls.\n\nThese interdependencies confirm that the server maintains and operates on a shared, evolving document state—hallmarks of a stateful system.",
      "state_dependencies": [
        {
          "function_a": "create_rectangle",
          "function_b": "get_node_info",
          "state_description": "Creating a rectangle adds a new node; get_node_info retrieves its properties"
        },
        {
          "function_a": "create_frame",
          "function_b": "set_layout_mode",
          "state_description": "A frame must exist before its layout mode can be set"
        },
        {
          "function_a": "create_text",
          "function_b": "set_text_content",
          "state_description": "Text content can only be updated after a text node is created"
        },
        {
          "function_a": "create_rectangle",
          "function_b": "set_fill_color",
          "state_description": "Fill color can only be applied to an existing node"
        },
        {
          "function_a": "create_frame",
          "function_b": "set_padding",
          "state_description": "Padding can only be set on an existing frame"
        },
        {
          "function_a": "set_text_content",
          "function_b": "get_node_info",
          "state_description": "Updated text content is reflected when retrieving node info"
        },
        {
          "function_a": "set_annotation",
          "function_b": "get_annotations",
          "state_description": "Annotations created by set_annotation appear in results from get_annotations"
        },
        {
          "function_a": "create_component_instance",
          "function_b": "get_instance_overrides",
          "state_description": "Instance overrides can only be retrieved after an instance is created"
        },
        {
          "function_a": "clone_node",
          "function_b": "move_node",
          "state_description": "A cloned node must exist before it can be moved"
        },
        {
          "function_a": "create_frame",
          "function_b": "scan_nodes_by_types",
          "state_description": "Newly created frames become discoverable when scanning for node types"
        }
      ],
      "token_usage": {
        "prompt_tokens": 8179,
        "completion_tokens": 785,
        "total_tokens": 8964
      },
      "function_count": 38,
      "functions": [
        "shotclock-delete_multiple_nodes",
        "shotclock-set_item_spacing",
        "shotclock-create_connections",
        "shotclock-scan_text_nodes",
        "shotclock-create_frame",
        "shotclock-set_default_connector",
        "shotclock-get_document_info",
        "shotclock-read_my_design",
        "shotclock-get_selection",
        "shotclock-create_component_instance",
        "shotclock-get_node_info",
        "shotclock-set_corner_radius",
        "shotclock-set_multiple_annotations",
        "shotclock-set_text_content",
        "shotclock-join_channel",
        "shotclock-create_text",
        "shotclock-set_layout_sizing",
        "shotclock-delete_node",
        "shotclock-get_instance_overrides",
        "shotclock-scan_nodes_by_types",
        "shotclock-set_layout_mode",
        "shotclock-set_instance_overrides",
        "shotclock-set_stroke_color",
        "shotclock-get_reactions",
        "shotclock-get_local_components",
        "shotclock-create_rectangle",
        "shotclock-clone_node",
        "shotclock-get_styles",
        "shotclock-export_node_as_image",
        "shotclock-set_fill_color",
        "shotclock-set_padding",
        "shotclock-set_annotation",
        "shotclock-set_multiple_text_contents",
        "shotclock-get_annotations",
        "shotclock-resize_node",
        "shotclock-get_nodes_info",
        "shotclock-set_axis_align",
        "shotclock-move_node"
      ]
    },
    "LeetCode": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available tools in the LeetCode MCP server, there is no evidence of stateful behavior. All provided functions are read-only operations that retrieve data from the LeetCode platform without modifying any persistent state on the server. None of the tools perform create, update, or delete actions (e.g., submitting code, creating solutions, updating user profiles, or modifying contest rankings). Furthermore, each function operates independently and does not rely on prior function calls to succeed—each includes all necessary parameters (such as `username`, `titleSlug`, or `questionSlug`) to execute in isolation. There are no shared sessions, configurations, or authentication setup steps exposed in the tool definitions that would persist across calls. While the server likely uses authentication internally (as noted in the overview), no tool explicitly manages or sets authentication state (like `login` or `set_auth_token`), and all user-specific queries require explicit identifiers (e.g., `username`) rather than relying on an established session context. Therefore, the absence of both state-modifying operations and inter-function state dependencies strongly indicates a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2771,
        "completion_tokens": 247,
        "total_tokens": 3018
      },
      "function_count": 9,
      "functions": [
        "leetcode-get_problem",
        "leetcode-list_problem_solutions",
        "leetcode-get_recent_ac_submissions",
        "leetcode-get_user_profile",
        "leetcode-search_problems",
        "leetcode-get_daily_challenge",
        "leetcode-get_problem_solution",
        "leetcode-get_user_contest_ranking",
        "leetcode-get_recent_submissions"
      ]
    },
    "Repomix": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Repomix MCP server exhibits stateful behavior because the `pack_codebase` and `pack_remote_repository` functions generate output files that are later accessed using the `read_repomix_output` function. These packaging functions modify persistent state by creating a packaged representation of a codebase (either local or remote), which is stored internally and assigned an `outputId`. The `read_repomix_output` function depends on this generated state, as it requires a valid `outputId`—produced only by prior execution of one of the pack functions—to retrieve the contents. Without a prior call to `pack_codebase` or `pack_remote_repository`, `read_repomix_output` cannot return meaningful data, indicating a clear dependency on previously established state. Additionally, while `file_system_read_file` and `file_system_read_directory` allow direct file access, `read_repomix_output` is explicitly designed for environments where direct access is not possible, implying that the server maintains internal state (the packed output) that persists across function calls.",
      "state_dependencies": [
        {
          "function_a": "pack_codebase",
          "function_b": "read_repomix_output",
          "state_description": "The outputId and associated packaged codebase file generated by pack_codebase must exist for read_repomix_output to successfully retrieve the content."
        },
        {
          "function_a": "pack_remote_repository",
          "function_b": "read_repomix_output",
          "state_description": "The outputId and associated packaged remote repository file generated by pack_remote_repository must exist for read_repomix_output to successfully retrieve the content."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1534,
        "completion_tokens": 357,
        "total_tokens": 1891
      },
      "function_count": 5,
      "functions": [
        "repomix-pack_remote_repository",
        "repomix-file_system_read_file",
        "repomix-file_system_read_directory",
        "repomix-pack_codebase",
        "repomix-read_repomix_output"
      ]
    },
    "Super Shell": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Super Shell MCP server maintains a persistent command whitelist and security configuration that can be modified and subsequently influence the behavior of other functions. Multiple tools explicitly modify shared state (e.g., `add_to_whitelist`, `update_security_level`, `remove_from_whitelist`), while others depend on this state (e.g., `get_whitelist`, `execute_command`, `get_pending_commands`). For example, adding a command to the whitelist alters what commands are allowed or require approval, which directly affects whether `execute_command` can run without manual approval. Similarly, `execute_command` may place a request in pending status based on the current security level of the command, which is determined by prior calls to `add_to_whitelist` or `update_security_level`. This creates clear interdependencies where earlier function calls affect the outcomes of later ones. Additionally, `approve_command` and `deny_command` operate on state created by attempted executions, indicating session-like context persistence.",
      "state_dependencies": [
        {
          "function_a": "add_to_whitelist",
          "function_b": "get_whitelist",
          "state_description": "The list of whitelisted commands returned by get_whitelist includes entries added via add_to_whitelist"
        },
        {
          "function_a": "add_to_whitelist",
          "function_b": "execute_command",
          "state_description": "Whether a command is whitelisted with 'safe' or 'requires_approval' determines if execute_command runs immediately or creates a pending request"
        },
        {
          "function_a": "update_security_level",
          "function_b": "execute_command",
          "state_description": "Changing a command's security level affects whether its execution requires approval"
        },
        {
          "function_a": "execute_command",
          "function_b": "get_pending_commands",
          "state_description": "Executing a command with 'requires_approval' security level adds it to the pending commands list"
        },
        {
          "function_a": "execute_command",
          "function_b": "approve_command",
          "state_description": "A command execution generates a pending command ID that must be used to approve it"
        },
        {
          "function_a": "execute_command",
          "function_b": "deny_command",
          "state_description": "A command execution generates a pending command ID that must be used to deny it"
        },
        {
          "function_a": "remove_from_whitelist",
          "function_b": "get_whitelist",
          "state_description": "Removing a command updates the whitelist, which will no longer include the removed command"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1213,
        "completion_tokens": 553,
        "total_tokens": 1766
      },
      "function_count": 9,
      "functions": [
        "super-shell-add_to_whitelist",
        "super-shell-deny_command",
        "super-shell-execute_command",
        "super-shell-get_whitelist",
        "super-shell-approve_command",
        "super-shell-get_pending_commands",
        "super-shell-get_platform_info",
        "super-shell-update_security_level",
        "super-shell-remove_from_whitelist"
      ]
    },
    "Magic UI Component Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available tools in the Magic UI Component Server are read-only functions that retrieve implementation details or lists of UI components. None of the functions perform create, update, delete, or configuration-setting operations. Each function returns information about a specific category of UI elements (e.g., buttons, motion effects, backgrounds), and there is no indication that calling one function alters any server-side state that would affect the behavior or output of another function. The parameters for all tools are empty objects with `additionalProperties: false`, meaning no input can be provided to modify behavior or set context. There is no evidence of shared sessions, configurations, or persistent state modifications across function calls. Therefore, the server exhibits purely stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1356,
        "completion_tokens": 167,
        "total_tokens": 1523
      },
      "function_count": 11,
      "functions": [
        "magic-ui-component-server-getUIComponents",
        "magic-ui-component-server-getTextReveal",
        "magic-ui-component-server-getWidgets",
        "magic-ui-component-server-getMotion",
        "magic-ui-component-server-getEffects",
        "magic-ui-component-server-getButtons",
        "magic-ui-component-server-getLayout",
        "magic-ui-component-server-getMedia",
        "magic-ui-component-server-getBackgrounds",
        "magic-ui-component-server-getTextEffects",
        "magic-ui-component-server-getDevices"
      ]
    },
    "LottieFiles Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The LottieFiles Server provides three read-only functions: `search_animations`, `get_animation_details`, and `get_popular_animations`. All of these functions are purely retrieval-based and do not involve creating, modifying, or deleting any data on the server. There are no indications of state-modifying operations such as uploading animations, updating metadata, or managing user sessions. Each function operates independently and does not rely on prior function calls to succeed. For example, calling `search_animations` does not set up context or configuration that affects the behavior of `get_animation_details` or `get_popular_animations`. Similarly, none of the parameters suggest shared session tokens, configurations, or cached states across requests. Therefore, there is no evidence of persistent state being modified or depended upon across function calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 852,
        "completion_tokens": 186,
        "total_tokens": 1038
      },
      "function_count": 3,
      "functions": [
        "lottiefiles-server-get_popular_animations",
        "lottiefiles-server-get_animation_details",
        "lottiefiles-server-search_animations"
      ]
    },
    "Minecraft Bot Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Minecraft Bot Server maintains and manipulates persistent state through the bot's position, inventory, equipped items, and block world state. Multiple tool functions both modify and depend on this shared state. For example, moving the bot with `move-to-position` or `fly-to` changes its current location, which affects subsequent calls to `get-position` or movement-based actions relative to the current position. Similarly, inventory-related tools like `find-item`, `equip-item`, and `list-inventory` operate on a shared inventory state—equipping an item presumes it exists in the inventory, and finding an item depends on the current contents. Block manipulation tools such as `place-block`, `dig-block`, and `get-block-info` interact with the persistent world state; placing or digging a block alters the environment that future block queries will reflect. These interdependencies confirm that the server is stateful.",
      "state_dependencies": [
        {
          "function_a": "move-to-position",
          "function_b": "get-position",
          "state_description": "The bot's current position is updated by move-to-position and can be retrieved by get-position"
        },
        {
          "function_a": "fly-to",
          "function_b": "get-position",
          "state_description": "The bot's current position is updated by fly-to and can be retrieved by get-position"
        },
        {
          "function_a": "move-to-position",
          "function_b": "look-at",
          "state_description": "After moving, look-at may be used relative to the new position to orient toward targets"
        },
        {
          "function_a": "equip-item",
          "function_b": "find-item",
          "state_description": "Equipping an item implies it exists in the inventory, which is queried by find-item"
        },
        {
          "function_a": "place-block",
          "function_b": "get-block-info",
          "state_description": "Placing a block modifies the world state, which can later be inspected using get-block-info"
        },
        {
          "function_a": "dig-block",
          "function_b": "get-block-info",
          "state_description": "Digging a block changes the world state, affecting the result of subsequent block queries"
        },
        {
          "function_a": "place-block",
          "function_b": "find-block",
          "state_description": "Placing a block of a certain type can influence the results of finding the nearest block of that type"
        },
        {
          "function_a": "dig-block",
          "function_b": "find-block",
          "state_description": "Removing a block affects the proximity and availability of blocks found by find-block"
        },
        {
          "function_a": "equip-item",
          "function_b": "place-block",
          "state_description": "Equipping a tool (e.g., pickaxe) may affect the ability or efficiency to place or dig blocks, depending on game logic"
        }
      ],
      "token_usage": {
        "prompt_tokens": 2374,
        "completion_tokens": 635,
        "total_tokens": 3009
      },
      "function_count": 15,
      "functions": [
        "minecraft-bot-server-list-inventory",
        "minecraft-bot-server-find-entity",
        "minecraft-bot-server-dig-block",
        "minecraft-bot-server-fly-to",
        "minecraft-bot-server-place-block",
        "minecraft-bot-server-move-to-position",
        "minecraft-bot-server-move-in-direction",
        "minecraft-bot-server-equip-item",
        "minecraft-bot-server-find-item",
        "minecraft-bot-server-jump",
        "minecraft-bot-server-send-chat",
        "minecraft-bot-server-find-block",
        "minecraft-bot-server-get-position",
        "minecraft-bot-server-look-at",
        "minecraft-bot-server-get-block-info"
      ]
    },
    "Region Weather": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "region-weather-get_weather"
      ]
    },
    "Lyrical MCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Lyrical MCP server provides four tools: `ping`, `health_check`, `count_syllables`, and `find_rhymes`. All of these functions are stateless in nature. There is no indication that any function modifies persistent state (e.g., no creation, update, or deletion of resources), and none of the functions depend on prior calls to function properly. Each function operates solely on the input provided during the call:\n\n- `ping` and `health_check` are diagnostic tools that return server status without altering or relying on any internal state.\n- `count_syllables` takes an input string and returns syllable counts per line using a prebuilt linguistic resource (NLTK's CMU Pronouncing Dictionary). It does not store or modify any data between calls.\n- `find_rhymes` takes an input word and returns rhyming words based on pronunciation data from the same static dictionary. It only analyzes the last word of the input and does not retain or depend on session-specific or previously computed data.\n\nThere are no shared contexts, sessions, configurations, or stored data across function invocations. All operations are idempotent and self-contained. Therefore, there is no stateful behavior present.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 989,
        "completion_tokens": 271,
        "total_tokens": 1260
      },
      "function_count": 4,
      "functions": [
        "lyrical-mcp-count_syllables",
        "lyrical-mcp-health_check",
        "lyrical-mcp-ping",
        "lyrical-mcp-find_rhymes"
      ]
    },
    "Flow RPC Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Flow RPC Server provides read-only and stateless JSON-RPC methods for interacting with the Flow EVM network. All available tools are queries that retrieve blockchain data (e.g., balance, code, logs, chain ID) or broadcast already-signed transactions without maintaining any internal mutable state across calls. None of the functions listed have parameters or documented behaviors indicating they create, modify, or store server-side state such as sessions, configurations, or cached data. For example:\n- `flow_getBalance`, `flow_getCode`, `flow_gasPrice`, `flow_chainId`, `flow_blockNumber`, and `flow_getNetworkInfo` are pure read operations based on on-chain data.\n- `flow_call` simulates a contract call without committing changes.\n- `flow_getLogs` retrieves event logs based on filter criteria, which depends solely on blockchain state, not server state.\n- `flow_sendRawTransaction` submits a signed transaction to the network but does not create or rely on any persistent session or context on the server side.\n\nThere is no evidence of function pairs where one sets up state consumed by another within the server. All interactions depend only on the immutable or consensus-driven state of the blockchain itself, not on transient server-managed state. Therefore, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2181,
        "completion_tokens": 282,
        "total_tokens": 2463
      },
      "function_count": 10,
      "functions": [
        "flow-rpc-server-flow_getLogs",
        "flow-rpc-server-flow_getCode",
        "flow-rpc-server-flow_getBalance",
        "flow-rpc-server-flow_getNetworkInfo",
        "flow-rpc-server-flow_sendRawTransaction",
        "flow-rpc-server-flow_chainId",
        "flow-rpc-server-flow_gasPrice",
        "flow-rpc-server-flow_call",
        "flow-rpc-server-flow_blockNumber",
        "flow-rpc-server-flow_checkCOA"
      ]
    },
    "MongoDB MCP Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The MongoDB MCP Server is clearly stateful because multiple functions modify persistent state on the database (e.g., inserting, updating, or deleting data), and subsequent operations depend on that modified state. The server maintains shared context across function calls in the form of an active connection, database schema, collection existence, document contents, and indexes—all of which persist between tool invocations. Crucially, several functions require prior execution of others to succeed or produce meaningful results. For example, most data operations (like `find`, `insert-many`, `create-index`) require a connection established via `connect`. Furthermore, operations like `list-collections` will return different results after `create-collection` or `drop-collection` are called. Similarly, `count` and `find` return results that reflect prior `insert-many` or `delete-many` actions. This interdependence confirms statefulness.",
      "state_dependencies": [
        {
          "function_a": "connect",
          "function_b": "list-databases",
          "state_description": "An active MongoDB connection established by 'connect' is required for 'list-databases' to retrieve the list of databases."
        },
        {
          "function_a": "connect",
          "function_b": "list-collections",
          "state_description": "A successful connection via 'connect' is necessary before 'list-collections' can query collections in a specific database."
        },
        {
          "function_a": "create-collection",
          "function_b": "list-collections",
          "state_description": "'create-collection' modifies the database by adding a new collection, which affects the output of subsequent 'list-collections' calls."
        },
        {
          "function_a": "insert-many",
          "function_b": "find",
          "state_description": "Documents inserted via 'insert-many' become available for retrieval by 'find' queries using matching filters."
        },
        {
          "function_a": "insert-many",
          "function_b": "count",
          "state_description": "The number of documents returned by 'count' increases after 'insert-many' adds new documents to the collection."
        },
        {
          "function_a": "delete-many",
          "function_b": "count",
          "state_description": "After 'delete-many' removes documents matching a filter, 'count' will reflect the reduced number of documents."
        },
        {
          "function_a": "create-index",
          "function_b": "collection-indexes",
          "state_description": "Indexes created with 'create-index' appear in the output of 'collection-indexes', which lists all indexes on a collection."
        },
        {
          "function_a": "rename-collection",
          "function_b": "list-collections",
          "state_description": "Renaming a collection with 'rename-collection' changes the list of collection names returned by 'list-collections'."
        },
        {
          "function_a": "drop-collection",
          "function_b": "list-collections",
          "state_description": "Dropping a collection via 'drop-collection' removes it from the results of future 'list-collections' calls."
        },
        {
          "function_a": "drop-database",
          "function_b": "list-databases",
          "state_description": "Removing a database with 'drop-database' causes it to no longer appear in the output of 'list-databases'."
        },
        {
          "function_a": "update-many",
          "function_b": "find",
          "state_description": "Changes made by 'update-many' to document fields are reflected in subsequent 'find' queries that retrieve those documents."
        },
        {
          "function_a": "create-collection",
          "function_b": "insert-many",
          "state_description": "A collection must first be created (or exist) before 'insert-many' can add documents to it."
        }
      ],
      "token_usage": {
        "prompt_tokens": 4124,
        "completion_tokens": 815,
        "total_tokens": 4939
      },
      "function_count": 20,
      "functions": [
        "mongodb-mcp-server-collection-indexes",
        "mongodb-mcp-server-find",
        "mongodb-mcp-server-update-many",
        "mongodb-mcp-server-create-collection",
        "mongodb-mcp-server-drop-collection",
        "mongodb-mcp-server-collection-storage-size",
        "mongodb-mcp-server-list-databases",
        "mongodb-mcp-server-create-index",
        "mongodb-mcp-server-insert-many",
        "mongodb-mcp-server-connect",
        "mongodb-mcp-server-aggregate",
        "mongodb-mcp-server-list-collections",
        "mongodb-mcp-server-explain",
        "mongodb-mcp-server-collection-schema",
        "mongodb-mcp-server-drop-database",
        "mongodb-mcp-server-count",
        "mongodb-mcp-server-rename-collection",
        "mongodb-mcp-server-delete-many",
        "mongodb-mcp-server-mongodb-logs",
        "mongodb-mcp-server-db-stats"
      ]
    },
    "End to End Testing Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server is stateful because multiple functions interact with and depend on the browser's navigation and page state, which persists across function calls. For example, `browser_navigate` changes the current page URL, and subsequent actions like `browser_click`, `browser_type`, or `browser_snapshot` operate on the currently loaded page. These functions depend on the navigated state to correctly identify elements via `ref` (element references from snapshots), which are only valid in the context of the current page. Additionally, functions such as `browser_go_back` and `browser_go_forward` explicitly rely on the browser’s session history stack—modifying or depending on prior navigation actions. The requirement noted in `browser_batch` that `browser_navigate` must be called first to obtain correct ARIA references confirms that element interaction depends on prior state setup. This shared, persistent context (page content, navigation history, element references) clearly indicates stateful behavior.",
      "state_dependencies": [
        {
          "function_a": "browser_navigate",
          "function_b": "browser_click",
          "state_description": "Navigating to a URL sets the current page context; clicking an element requires the target element to exist on this page and uses a reference from its snapshot."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_type",
          "state_description": "The page context set by navigation determines where text input occurs; typing requires a valid element reference from the current page snapshot."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_hover",
          "state_description": "Hovering depends on the existence of the target element on the currently loaded page, established by prior navigation."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_select_option",
          "state_description": "Dropdown selection requires the form element to be present on the current page, which is set by navigating to a specific URL."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_snapshot",
          "state_description": "The accessibility snapshot reflects the DOM of the currently navigated page, so it depends directly on the last navigation action."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_go_back",
          "state_description": "The go-back operation relies on the browser's history stack, which is populated by prior navigation actions."
        },
        {
          "function_a": "browser_go_back",
          "function_b": "browser_snapshot",
          "state_description": "After going back, the page reverts to a previous state, and the snapshot reflects that earlier page content."
        },
        {
          "function_a": "browser_click",
          "function_b": "browser_snapshot",
          "state_description": "A click may trigger dynamic content changes (e.g., opening a modal), which will be reflected in a subsequent snapshot."
        }
      ],
      "token_usage": {
        "prompt_tokens": 4280,
        "completion_tokens": 638,
        "total_tokens": 4918
      },
      "function_count": 16,
      "functions": [
        "end-to-end-testing-server-browser_select_option",
        "end-to-end-testing-server-browser_wait",
        "end-to-end-testing-server-browser_type",
        "end-to-end-testing-server-browser_click",
        "end-to-end-testing-server-browser_go_back",
        "end-to-end-testing-server-browser_close",
        "end-to-end-testing-server-browser_go_forward",
        "end-to-end-testing-server-browser_hover",
        "end-to-end-testing-server-browser_take_screenshot",
        "end-to-end-testing-server-browser_save_as_pdf",
        "end-to-end-testing-server-browser_batch",
        "end-to-end-testing-server-browser_navigate",
        "end-to-end-testing-server-browser_choose_file",
        "end-to-end-testing-server-browser_press_key",
        "end-to-end-testing-server-browser_drag",
        "end-to-end-testing-server-browser_snapshot"
      ]
    },
    "Model Context Protocol Servers": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "After analyzing all available tools in the MCP server, there is no evidence of functions that modify persistent state or depend on prior function calls. Each tool appears to operate independently and idempotently:\n\n- `echo`: Simply returns the input message without modifying any system state.\n- `add`: Performs a pure mathematical operation with no side effects.\n- `printEnv`: Reads environment variables but does not alter them; environment variables are assumed to be static configuration set outside the function call lifecycle.\n- `longRunningOperation`: Simulates a long-running task with progress updates, but there's no indication it stores state that affects other functions.\n- `sampleLLM`: Samples from an LLM based on a prompt; while LLMs can have context internally, this function treats each call as independent and does not expose mechanisms for carrying forward conversation history or session state within the MCP layer.\n- `getTinyImage`: Returns a constant image value (MCP_TINY_IMAGE), implying a static asset.\n- `annotatedMessage`: Generates a message with metadata annotations; behavior is fully determined by input parameters and does not rely on or modify external state.\n\nNone of the functions create, update, or delete data that would influence subsequent calls. There are no apparent shared contexts, sessions, or mutable configurations exposed through the API that persist across requests. While some operations (like `longRunningOperation`) might involve internal transient state (e.g., for tracking progress), such state does not appear to be accessible or impactful to other functions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1216,
        "completion_tokens": 329,
        "total_tokens": 1545
      },
      "function_count": 8,
      "functions": [
        "model-context-protocol-servers-getTinyImage",
        "model-context-protocol-servers-printEnv",
        "model-context-protocol-servers-annotatedMessage",
        "model-context-protocol-servers-getResourceReference",
        "model-context-protocol-servers-longRunningOperation",
        "model-context-protocol-servers-add",
        "model-context-protocol-servers-echo",
        "model-context-protocol-servers-sampleLLM"
      ]
    },
    "Starknet MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Starknet MCP Server includes several functions that modify persistent blockchain state through write operations (e.g., token transfers, contract executions), and other functions that read or depend on the outcomes of those modifications. Specifically, tools like `transfer_starknet_eth`, `transfer_starknet_strk`, `transfer_starknet_token`, and `execute_starknet_contract` all require a private key to sign and submit transactions that alter the state of the blockchain (e.g., updating balances, modifying contract storage). Subsequent calls to balance-checking or data-fetching functions (such as `get_starknet_eth_balance`, `get_starknet_token_balance`, `get_starknet_strk_balance`, `get_starknet_transaction_receipt`, etc.) will reflect different results depending on whether such state-modifying functions have been previously invoked.\n\nMoreover, while the server itself may not store internal session state, it interacts with a stateful system — the Starknet blockchain — where each transaction permanently affects global state. In the context of MCP analysis, if function A triggers a state change on the underlying system and function B's output is affected by that change, this constitutes stateful behavior from the perspective of the protocol, even if the server is acting as a middleware.\n\nAdditionally, transaction-dependent functions like `get_starknet_transaction`, `get_starknet_transaction_receipt`, and `check_starknet_transaction_status` explicitly rely on prior invocations of transaction-initiating functions (like `transfer_starknet_eth`) to return meaningful data. Without a previous call that submits a transaction, these functions would fail or return null for non-existent hashes.\n\nThus, there are clear interdependencies between write (state-modifying) and read (state-dependent) functions, confirming stateful behavior.",
      "state_dependencies": [
        {
          "function_a": "transfer_starknet_eth",
          "function_b": "get_starknet_eth_balance",
          "state_description": "Transferring ETH changes the balance of sender and recipient addresses; subsequent balance queries reflect this updated state."
        },
        {
          "function_a": "transfer_starknet_strk",
          "function_b": "get_starknet_strk_balance",
          "state_description": "Transferring STRK tokens modifies account balances; later balance checks will return updated values based on this transfer."
        },
        {
          "function_a": "transfer_starknet_token",
          "function_b": "get_starknet_token_balance",
          "state_description": "ERC20 token transfers update token balances; future queries to token balance depend on the success and confirmation of the prior transfer."
        },
        {
          "function_a": "execute_starknet_contract",
          "function_b": "call_starknet_contract",
          "state_description": "Executing a contract function can alter contract storage; subsequent read calls to the same contract may return different results due to this mutation."
        },
        {
          "function_a": "transfer_starknet_eth",
          "function_b": "get_starknet_transaction_receipt",
          "state_description": "The transaction receipt can only be retrieved after a transaction has been submitted via a transfer function."
        },
        {
          "function_a": "execute_starknet_contract",
          "function_b": "get_starknet_transaction",
          "state_description": "Details of a contract execution transaction are available only after the execution function is called and the transaction is broadcast."
        },
        {
          "function_a": "transfer_starknet_token",
          "function_b": "check_starknet_transaction_status",
          "state_description": "Checking transaction status depends on a transaction hash generated by a prior token transfer operation."
        }
      ],
      "token_usage": {
        "prompt_tokens": 4926,
        "completion_tokens": 776,
        "total_tokens": 5702
      },
      "function_count": 25,
      "functions": [
        "starknet-mcp-server-get_starknet_profile",
        "starknet-mcp-server-get_starknet_token_balance",
        "starknet-mcp-server-resolve_starknet_address",
        "starknet-mcp-server-resolve_starknet_name",
        "starknet-mcp-server-get_supported_starknet_networks",
        "starknet-mcp-server-transfer_starknet_eth",
        "starknet-mcp-server-call_starknet_contract",
        "starknet-mcp-server-get_starknet_token_info",
        "starknet-mcp-server-get_starknet_block_transactions",
        "starknet-mcp-server-get_starknet_chain_info",
        "starknet-mcp-server-validate_starknet_domain",
        "starknet-mcp-server-get_starknet_strk_balance",
        "starknet-mcp-server-execute_starknet_contract",
        "starknet-mcp-server-get_starknet_transaction",
        "starknet-mcp-server-get_starknet_nft_balance",
        "starknet-mcp-server-get_starknet_token_supply",
        "starknet-mcp-server-transfer_starknet_strk",
        "starknet-mcp-server-get_starknet_native_balances",
        "starknet-mcp-server-get_starknet_block",
        "starknet-mcp-server-get_starknet_contract_class",
        "starknet-mcp-server-check_starknet_nft_ownership",
        "starknet-mcp-server-get_starknet_eth_balance",
        "starknet-mcp-server-check_starknet_transaction_status",
        "starknet-mcp-server-transfer_starknet_token",
        "starknet-mcp-server-get_starknet_transaction_receipt"
      ]
    },
    "Firestore Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Firestore MCP server is inherently stateful because it provides persistent data storage operations (CRUD) where the outcome of read/query operations depends on prior write operations (create, update, delete). Multiple function pairs demonstrate clear state dependencies: creating or updating a document modifies the underlying database state, and subsequent retrieval or query functions will return different results based on those modifications. For example, calling `firestore-create-document` changes the set of available documents, which directly affects the output of `firestore-get-document`, `firestore-query-collection`, and other read operations. Similarly, atomic operations like `firestore-increment-field` or `firestore-array-union` alter document fields whose values are then returned by future reads. The existence of transactional and batched operations (`firestore-transaction`, `firestore-batch-write`) further confirms that consistency across stateful interactions is a core design requirement. There is no indication that this server operates in a purely stateless fashion; instead, its entire purpose is to manage shared, persistent state in a distributed environment.",
      "state_dependencies": [
        {
          "function_a": "firestore-create-document",
          "function_b": "firestore-get-document",
          "state_description": "Creating a document in a collection makes it retrievable by ID using get-document"
        },
        {
          "function_a": "firestore-create-document-by-path",
          "function_b": "firestore-get-document-by-path",
          "state_description": "Creating a document at a specific path allows it to be retrieved later using its full path"
        },
        {
          "function_a": "firestore-update-document",
          "function_b": "firestore-get-document",
          "state_description": "Updating a document changes its data, which is then reflected in subsequent get requests"
        },
        {
          "function_a": "firestore-delete-document",
          "function_b": "firestore-get-document",
          "state_description": "Deleting a document causes subsequent get requests for that document to return not found"
        },
        {
          "function_a": "firestore-create-document",
          "function_b": "firestore-query-collection",
          "state_description": "Creating a document may cause it to appear in the results of a query on its collection"
        },
        {
          "function_a": "firestore-update-document-by-path",
          "function_b": "firestore-query-collection-by-path",
          "state_description": "Updating a document can affect whether it matches filter conditions in future queries"
        },
        {
          "function_a": "firestore-increment-field",
          "function_b": "firestore-get-document-by-path",
          "state_description": "Incrementing a numeric field changes its value, which is then visible when the document is read"
        },
        {
          "function_a": "firestore-array-union",
          "function_b": "firestore-get-document-by-path",
          "state_description": "Adding elements to an array field via array-union modifies the document state, affecting future reads"
        },
        {
          "function_a": "firestore-delete-field",
          "function_b": "firestore-get-document-by-path",
          "state_description": "Removing a field from a document alters its structure and content as seen in subsequent reads"
        },
        {
          "function_a": "firestore-batch-write",
          "function_b": "firestore-batch-read",
          "state_description": "A batch write operation modifies multiple documents, which can then be read back using batch-read"
        },
        {
          "function_a": "firestore-transaction",
          "function_b": "firestore-get-document",
          "state_description": "A transaction may commit writes that alter document state, affecting future individual document reads"
        }
      ],
      "token_usage": {
        "prompt_tokens": 5395,
        "completion_tokens": 793,
        "total_tokens": 6188
      },
      "function_count": 23,
      "functions": [
        "firestore-server-firestore-delete-document-by-path",
        "firestore-server-firestore-field-value-batch",
        "firestore-server-firestore-batch-write",
        "firestore-server-firestore-get-document",
        "firestore-server-firestore-query-collection",
        "firestore-server-firestore-server-timestamp",
        "firestore-server-firestore-update-document-by-path",
        "firestore-server-firestore-increment-field",
        "firestore-server-firestore-delete-document",
        "firestore-server-firestore-create-document-by-path",
        "firestore-server-firestore-get-collection",
        "firestore-server-firestore-transaction",
        "firestore-server-firestore-list-subcollections",
        "firestore-server-firestore-array-remove",
        "firestore-server-firestore-delete-field",
        "firestore-server-firestore-get-document-by-path",
        "firestore-server-firestore-list-collections",
        "firestore-server-firestore-update-document",
        "firestore-server-firestore-array-union",
        "firestore-server-firestore-batch-read",
        "firestore-server-firestore-query-collection-by-path",
        "firestore-server-firestore-create-document",
        "firestore-server-firestore-get-collection-by-path"
      ]
    },
    "KMB Bus": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the KMB Bus MCP server are read-only operations that retrieve information from a public transit database. None of the functions perform create, update, delete, or configuration-setting actions that would modify persistent state. Each function operates independently based on input parameters (e.g., route number, stop name, destination) and does not rely on prior function calls to set up context such as sessions, configurations, or cached data. There is no indication of shared mutable state, session tokens, or contextual dependencies between function calls. The system appears designed for stateless querying of static and real-time transit data.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1077,
        "completion_tokens": 147,
        "total_tokens": 1224
      },
      "function_count": 5,
      "functions": [
        "kmb-bus-get_all_routes_at_stop",
        "kmb-bus-get_next_bus",
        "kmb-bus-get_route_stops_info",
        "kmb-bus-find_stop_by_name",
        "kmb-bus-find_buses_to_destination"
      ]
    },
    "United States Weather": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available tools in the \"United States Weather\" MCP server are purely read-only and do not perform any create, update, delete, or configuration operations. Each function takes location (and optionally time or filter parameters) as input and returns weather-related data based on real-time or forecasted external sources. There is no indication that calling one function alters internal server state, sets preferences, establishes sessions, or configures context that would affect subsequent calls. All functions operate independently using only the provided input parameters and external weather data sources. No pair of functions exhibits a producer-consumer relationship where one sets up state for another. The system appears designed for idempotent, stateless queries typical of public weather data APIs.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1980,
        "completion_tokens": 167,
        "total_tokens": 2147
      },
      "function_count": 6,
      "functions": [
        "united-states-weather-get_current_weather",
        "united-states-weather-get_hourly_forecast",
        "united-states-weather-get_weather_forecast",
        "united-states-weather-get_weather_alerts",
        "united-states-weather-get_local_time",
        "united-states-weather-find_weather_stations"
      ]
    },
    "OpenAI Agent Library": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the OpenAI Agent Library MCP server are read-only operations that retrieve information from documentation, GitHub repositories, or API references. None of the functions perform create, update, delete, or any other state-modifying actions. Each function call is independent and does not rely on prior interactions or alter any shared context, session, or configuration. For example, calling `search_docs` does not affect the outcome of a subsequent `get_doc` call, nor does `get_github_file` depend on a previous `search_files` result beyond what could be inferred from external data. There is no indication of persistent state being modified or relied upon across function calls. The absence of any write-capable or side-effect-inducing operations strongly suggests a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1364,
        "completion_tokens": 180,
        "total_tokens": 1544
      },
      "function_count": 11,
      "functions": [
        "openai-agent-library-get_section",
        "openai-agent-library-search_files",
        "openai-agent-library-get_doc",
        "openai-agent-library-get_github_file",
        "openai-agent-library-get_code_examples",
        "openai-agent-library-list_github_structure",
        "openai-agent-library-get_api_docs",
        "openai-agent-library-run_diagnostics",
        "openai-agent-library-get_doc_index",
        "openai-agent-library-search_github",
        "openai-agent-library-search_docs"
      ]
    },
    "MyTime": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The MCP server \"MyTime\" provides two functions: `get_current_time` and `add_num`. Neither function modifies any persistent state. The `get_current_time` function retrieves the current time, which is a stateless operation dependent only on the system clock at call time, not on any user-modifiable or stored context. The `add_num` function performs a pure computation—adding a list of numbers—and does not store, modify, or depend on any external or internal state across calls. There are no indications of shared context, sessions, configurations, or side effects that persist between function invocations. Furthermore, there is no overlap in data or control flow between the two functions, and no function depends on the outcome or side effects of another. Therefore, the server exhibits purely stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 604,
        "completion_tokens": 186,
        "total_tokens": 790
      },
      "function_count": 2,
      "functions": [
        "mytime-get_current_time",
        "mytime-add_num"
      ]
    },
    "Event Horizon Evolutionary Solution Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Event Horizon Evolutionary Solution Server maintains persistent internal state across function calls, as evidenced by the interdependencies between its tools. The `start_evolution` function initializes the evolutionary framework, including the problem context, consistency checks, population size, and generation limits—establishing a shared configuration that subsequent functions depend on. After initialization, `add_solution` allows contributions to the current generation’s population, directly modifying the evolving state of solutions. These solutions are later referenced by ID in `score_solution`, which evaluates them against previously defined consistency checks (introduced in `start_evolution`). The `evolve_generation` function then uses aggregated scoring data from prior `score_solution` calls to generate crossover recommendations and advance the evolutionary process—this cannot function correctly without complete scoring of the current generation. Additionally, `get_evolution_status` retrieves the cumulative state of the evolution process, including generation count, best solutions, and history, all of which are built incrementally through prior function invocations. Multiple clear dependencies exist where one function sets state (e.g., creates solutions or scores) and others require that state to operate meaningfully.",
      "state_dependencies": [
        {
          "function_a": "start_evolution",
          "function_b": "add_solution",
          "state_description": "The problem statement and consistency checks defined in start_evolution establish the context required for valid solution content in add_solution"
        },
        {
          "function_a": "start_evolution",
          "function_b": "score_solution",
          "state_description": "Consistency checks registered during start_evolution are required to provide valid checkId values in score_solution"
        },
        {
          "function_a": "add_solution",
          "function_b": "score_solution",
          "state_description": "Solution IDs returned by add_solution must be used as input in score_solution to evaluate those specific solutions"
        },
        {
          "function_a": "score_solution",
          "function_b": "evolve_generation",
          "state_description": "The evolve_generation function requires all solutions in the current generation to have been scored via score_solution before it can proceed with crossover analysis"
        },
        {
          "function_a": "start_evolution",
          "function_b": "get_evolution_status",
          "state_description": "The evolution status reflects the configuration and progress initialized by start_evolution and updated over time"
        },
        {
          "function_a": "add_solution",
          "function_b": "get_evolution_status",
          "state_description": "Added solutions contribute to the population statistics and best solution tracking reported by get_evolution_status"
        },
        {
          "function_a": "score_solution",
          "function_b": "get_evolution_status",
          "state_description": "Scoring results influence the best solution and performance metrics visible in the evolution status"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1515,
        "completion_tokens": 597,
        "total_tokens": 2112
      },
      "function_count": 5,
      "functions": [
        "event-horizon-evolutionary-solution-server-add_solution",
        "event-horizon-evolutionary-solution-server-score_solution",
        "event-horizon-evolutionary-solution-server-get_evolution_status",
        "event-horizon-evolutionary-solution-server-start_evolution",
        "event-horizon-evolutionary-solution-server-evolve_generation"
      ]
    },
    "RedNote Content Access Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The presence of a `login` function that takes no parameters strongly suggests it is used to establish an authenticated session or context, likely storing authentication state (e.g., session tokens, user credentials, or cookies) on the server side. This state would then be implicitly used by subsequent calls to other functions such as `search_notes`, `get_note_content`, and `get_note_comments`. These read operations may return different results or have different access permissions based on whether a user is logged in (e.g., accessing private content, personalized search results, or rate-limited behavior). Since the `login` function modifies internal server-side state that affects the behavior of other functions without being explicitly passed as input, this constitutes stateful behavior. Furthermore, the lack of required parameters in `login` implies it relies on external context (such as pre-configured credentials) and sets internal state upon invocation.",
      "state_dependencies": [
        {
          "function_a": "login",
          "function_b": "search_notes",
          "state_description": "Authentication session established by login affects search results (e.g., personalization or access control) in search_notes"
        },
        {
          "function_a": "login",
          "function_b": "get_note_content",
          "state_description": "Authentication session established by login may grant access to restricted note content in get_note_content"
        },
        {
          "function_a": "login",
          "function_b": "get_note_comments",
          "state_description": "Authentication session established by login may affect comment visibility or retrieval in get_note_comments"
        }
      ],
      "token_usage": {
        "prompt_tokens": 845,
        "completion_tokens": 342,
        "total_tokens": 1187
      },
      "function_count": 4,
      "functions": [
        "rednote-content-access-server-login",
        "rednote-content-access-server-get_note_content",
        "rednote-content-access-server-get_note_comments",
        "rednote-content-access-server-search_notes"
      ]
    },
    "OpenProject Integration Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The OpenProject Integration Server provides a full CRUD (Create, Read, Update, Delete) interface for projects and tasks, which inherently implies stateful behavior. Multiple functions modify persistent state (e.g., `openproject-create-project`, `openproject-create-task`, `openproject-update-project`), and other functions depend on that state to return meaningful results (e.g., `openproject-get-project`, `openproject-list-tasks`). For example, calling `openproject-create-project` creates a project that can later be retrieved with `openproject-get-project` or `openproject-list-projects`. Similarly, creating a task with `openproject-create-task` affects the output of `openproject-list-tasks` and enables retrieval via `openproject-get-task`. The update and delete operations further confirm that the server maintains persistent state across function calls, as they require existing entities to operate. There is clear inter-function dependency based on shared persistent data in the OpenProject instance.",
      "state_dependencies": [
        {
          "function_a": "openproject-create-project",
          "function_b": "openproject-get-project",
          "state_description": "The created project entity, including its ID, becomes accessible via get-project after creation"
        },
        {
          "function_a": "openproject-create-project",
          "function_b": "openproject-list-projects",
          "state_description": "The newly created project appears in the list of projects returned by list-projects"
        },
        {
          "function_a": "openproject-create-project",
          "function_b": "openproject-create-task",
          "state_description": "A project must exist to associate a new task with it via projectId"
        },
        {
          "function_a": "openproject-create-task",
          "function_b": "openproject-get-task",
          "state_description": "The created task entity, including its ID, becomes retrievable via get-task"
        },
        {
          "function_a": "openproject-create-task",
          "function_b": "openproject-list-tasks",
          "state_description": "The newly created task appears in the list of tasks, especially when filtered by projectId"
        },
        {
          "function_a": "openproject-update-project",
          "function_b": "openproject-get-project",
          "state_description": "Changes made to a project's name or description are reflected in subsequent get-project calls"
        },
        {
          "function_a": "openproject-update-task",
          "function_b": "openproject-get-task",
          "state_description": "Updates to a task's subject or description are visible in later get-task responses"
        },
        {
          "function_a": "openproject-delete-project",
          "function_b": "openproject-get-project",
          "state_description": "After deletion, the project is no longer retrievable and will result in an error or not found response"
        },
        {
          "function_a": "openproject-delete-task",
          "function_b": "openproject-get-task",
          "state_description": "After deletion, the task is no longer retrievable"
        },
        {
          "function_a": "openproject-list-projects",
          "function_b": "openproject-create-task",
          "state_description": "The list of available projects may inform which projectId values are valid when creating a task"
        }
      ],
      "token_usage": {
        "prompt_tokens": 2072,
        "completion_tokens": 705,
        "total_tokens": 2777
      },
      "function_count": 11,
      "functions": [
        "openproject-integration-server-openproject-list-projects",
        "openproject-integration-server-openproject-update-task",
        "openproject-integration-server-openproject-get-task",
        "openproject-integration-server-openproject-delete-task",
        "openproject-integration-server-start-notification-stream",
        "openproject-integration-server-openproject-list-tasks",
        "openproject-integration-server-openproject-update-project",
        "openproject-integration-server-openproject-delete-project",
        "openproject-integration-server-openproject-get-project",
        "openproject-integration-server-openproject-create-task",
        "openproject-integration-server-openproject-create-project"
      ]
    },
    "Trends Hub": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the \"Trends Hub\" MCP server are read-only data retrieval functions that fetch trending content from external platforms (e.g., Weibo, Douyin, BBC, Zhihu). None of the tools perform create, update, delete, or configuration-setting operations. Each function operates independently, with no indication of shared mutable state, persistent sessions, user context, or configurations modified across calls. Parameters for each tool are self-contained and do not reference outputs or internal states from other functions. The server appears to be a passive aggregator of public real-time data, where each call is stateless and idempotent. There is no evidence of inter-function dependency based on system state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 4444,
        "completion_tokens": 166,
        "total_tokens": 4610
      },
      "function_count": 21,
      "functions": [
        "trends-hub-get-bbc-news",
        "trends-hub-get-weread-rank",
        "trends-hub-get-weibo-trending",
        "trends-hub-get-douyin-trending",
        "trends-hub-get-douban-rank",
        "trends-hub-get-sspai-rank",
        "trends-hub-get-juejin-article-rank",
        "trends-hub-get-theverge-news",
        "trends-hub-get-9to5mac-news",
        "trends-hub-get-infoq-news",
        "trends-hub-get-zhihu-trending",
        "trends-hub-get-nytimes-news",
        "trends-hub-get-bilibili-rank",
        "trends-hub-get-toutiao-trending",
        "trends-hub-get-netease-news-trending",
        "trends-hub-get-thepaper-trending",
        "trends-hub-get-36kr-trending",
        "trends-hub-get-ifanr-news",
        "trends-hub-get-smzdm-rank",
        "trends-hub-get-gcores-new",
        "trends-hub-get-tencent-news-trending"
      ]
    },
    "Package Registry Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Package Registry Server provides read-only access to package metadata, version history, and search functionality across multiple registries (Cargo, Go, NPM, NuGet, PyPI). All available tools are idempotent retrieval operations—such as getting package details, searching packages, or listing versions—and none of them imply mutation of server-side state. There are no functions that create, update, or delete data; no session management; no configuration setters; and no indication of shared context or persistent client-specific state between calls. Each function operates independently based on its input parameters and backend registry data, with no dependency on prior function invocations. Therefore, the server exhibits purely stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2106,
        "completion_tokens": 162,
        "total_tokens": 2268
      },
      "function_count": 13,
      "functions": [
        "package-registry-server-search-nuget-packages",
        "package-registry-server-get-nuget-package-details",
        "package-registry-server-get-golang-package-details",
        "package-registry-server-get-cargo-package-details",
        "package-registry-server-get-pypi-package-details",
        "package-registry-server-search-cargo-packages",
        "package-registry-server-list-npm-package-versions",
        "package-registry-server-list-nuget-package-versions",
        "package-registry-server-get-npm-package-details",
        "package-registry-server-search-npm-packages",
        "package-registry-server-list-cargo-package-versions",
        "package-registry-server-list-pypi-package-versions",
        "package-registry-server-list-golang-package-versions"
      ]
    },
    "Biomart MCP": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available functions in the Biomart MCP server, there is no evidence of stateful behavior. All functions are read-only operations that query metadata or data from Biomart databases without creating, modifying, or deleting any persistent state on the server. Each function call is self-contained and requires all necessary parameters (such as `mart`, `dataset`, `attributes`, etc.) to be explicitly provided. There are no session-establishing functions, configuration setters, or operations that alter server-side state. Even though some functions like `get_translation` mention caching for performance, this is an implementation detail internal to the function and does not create observable state dependencies between different function calls. Furthermore, no function depends on prior invocations to succeed — for example, calling `list_datasets` does not require a previous call to `list_marts`, although logically one might use the output of `list_marts` to inform a `list_datasets` call. This dependency is logical and client-side, not server-state-based.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 3129,
        "completion_tokens": 227,
        "total_tokens": 3356
      },
      "function_count": 8,
      "functions": [
        "biomart-mcp-list_datasets",
        "biomart-mcp-batch_translate",
        "biomart-mcp-list_common_attributes",
        "biomart-mcp-get_translation",
        "biomart-mcp-get_data",
        "biomart-mcp-list_marts",
        "biomart-mcp-list_all_attributes",
        "biomart-mcp-list_filters"
      ]
    },
    "box3-statistics-mcp": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available tools in the box3-statistics-mcp server, no functions are observed to perform state-modifying operations such as creating, updating, or deleting data. All provided tools are read-only in nature—designed to retrieve user profiles, map information, comments, statistics, and behavioral data. None of the functions have parameters or descriptions indicating side effects (e.g., no \"create\", \"update\", \"delete\", or \"set\" semantics).  \n\nWhile several tools (e.g., getMapStatList, getMapPlayerStatList, getCommentList) require authentication tokens and user agent headers, these are standard for secure API access and do not imply shared mutable state across function calls. The presence of authentication does not equate to statefulness unless the authentication establishes a session that influences subsequent behavior—but there is no evidence of session creation or context mutation here.  \n\nFurthermore, no function output appears to be a prerequisite for another function’s correct operation. For example, retrieving a user profile does not need prior invocation of a login or setup call, and all required parameters (like mapId, token, startTime, etc.) are explicitly passed in each request. There are no implicit dependencies where one function relies on internal state set by another.  \n\nTherefore, the server behaves as a stateless service where each request contains all necessary context and no inter-call dependency exists.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2390,
        "completion_tokens": 302,
        "total_tokens": 2692
      },
      "function_count": 10,
      "functions": [
        "box3-statistics-mcp-getMapCommentList",
        "box3-statistics-mcp-getMapStatList",
        "box3-statistics-mcp-getMapReleaseInfo",
        "box3-statistics-mcp-getMapPlayerStatList",
        "box3-statistics-mcp-getMapInfo",
        "box3-statistics-mcp-getMapPlayerBehavior",
        "box3-statistics-mcp-getMapPlayerRetention",
        "box3-statistics-mcp-getUserProfile",
        "box3-statistics-mcp-getMapList",
        "box3-statistics-mcp-getCommentList"
      ]
    },
    "Git Test Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available tools in the \"Git Test Server\" MCP server, there is no evidence of stateful behavior. All provided functions are read-only API clients that retrieve data from external systems (e.g., legal case databases, airport congestion APIs, sexual offender registries) without creating, modifying, or storing any persistent internal state on the server itself.  \n\nNone of the functions perform create, update, or delete operations. Each function call is self-contained and depends only on its input parameters and the availability of external services. There are no indications of shared sessions, configurations, authentication tokens, or context caches established by one function and required by another. Even though some functions share common parameters like `service_key` or `OC` (email ID), these are static credentials or identifiers passed explicitly with each request and do not represent mutable server-side state.\n\nAdditionally, while `search_law_cases` returns a list of legal cases and `get_law_case_body` retrieves the body of a specific case using an `ID`, this represents a typical client-driven workflow rather than statefulness — the second function does not depend on the first having been called, as long as the caller provides a valid `ID`. No session or context is established or maintained between calls.\n\nTherefore, the server behaves statelessly: identical requests will produce identical responses regardless of previous interactions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 3424,
        "completion_tokens": 296,
        "total_tokens": 3720
      },
      "function_count": 5,
      "functions": [
        "git-test-server-get_sexual_abuse_notice_house_jibun",
        "git-test-server-get_law_case_body",
        "git-test-server-search_law_cases",
        "git-test-server-get_sexual_code",
        "git-test-server-get_airport_congestion"
      ]
    },
    "Rabi MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the Rabi MCP Server are computational simulations or calculations that take explicit input parameters and return results based solely on those inputs. None of the functions perform operations that suggest modification of persistent state (e.g., no \"set_\", \"update_\", or \"initialize_\" type functions with side effects). Each function appears to be stateless, deterministic, and self-contained—meaning their outputs depend only on the provided arguments and not on any external or shared context established by prior function calls. There is no indication of session management, configuration storage, or data persistence across calls. Furthermore, there are no read/write pairs (e.g., save_data and retrieve_data) or dependencies where one function relies on internal state created by another. The naming, descriptions, and parameters all align with pure scientific computation models common in quantum physics, which typically do not maintain internal state between invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1200,
        "completion_tokens": 202,
        "total_tokens": 1402
      },
      "function_count": 5,
      "functions": [
        "rabi-mcp-server-simulate_two_level_atom",
        "rabi-mcp-server-absorption_spectrum",
        "rabi-mcp-server-rabi_oscillations",
        "rabi-mcp-server-cavity_qed",
        "rabi-mcp-server-bec_simulation"
      ]
    },
    "Office Word Document Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Office Word Document Server is clearly stateful because multiple functions modify persistent document state (e.g., creating, editing, or protecting documents), and subsequent operations depend on that modified state. For example, adding content to a document using `add_paragraph` or `add_heading` changes the document’s structure, which affects later calls to `get_document_text`, `get_document_outline`, or `delete_paragraph`. These read and modification operations are inherently dependent on the evolving state of the file system and document contents. Furthermore, document protection via `protect_document` introduces access control state that impacts whether other operations can succeed unless `unprotect_document` is called with the correct password. All write operations (e.g., adding tables, pictures, formatting) mutate shared document resources, and all read/query operations rely on the current state of those same documents. This interdependence across function calls confirms strong statefulness.",
      "state_dependencies": [
        {
          "function_a": "create_document",
          "function_b": "add_paragraph",
          "state_description": "A document must be created before paragraphs can be added to it; the existence of the file is required state."
        },
        {
          "function_a": "create_document",
          "function_b": "get_document_info",
          "state_description": "The document must exist in the file system for metadata to be retrieved by get_document_info."
        },
        {
          "function_a": "add_paragraph",
          "function_b": "get_document_text",
          "state_description": "Text returned by get_document_text includes content added by add_paragraph; thus, the output depends on prior modifications."
        },
        {
          "function_a": "add_heading",
          "function_b": "get_document_outline",
          "state_description": "The document outline reflects headings added via add_heading; without them, the structure would be different or empty."
        },
        {
          "function_a": "add_table",
          "function_b": "format_table",
          "state_description": "format_table requires a table at a given index to exist, which is created by add_table."
        },
        {
          "function_a": "create_custom_style",
          "function_b": "add_paragraph",
          "state_description": "The add_paragraph function can use a custom style name that was previously defined using create_custom_style."
        },
        {
          "function_a": "protect_document",
          "function_b": "unprotect_document",
          "state_description": "The unprotect_document function can only remove protection if protect_document was previously called to set a password."
        },
        {
          "function_a": "add_paragraph",
          "function_b": "format_text",
          "state_description": "format_text targets specific text within a paragraph, which must first be created using add_paragraph."
        },
        {
          "function_a": "add_footnote_to_document",
          "function_b": "convert_footnotes_to_endnotes_in_document",
          "state_description": "The conversion function only has effect if footnotes were previously added using add_footnote_to_document."
        },
        {
          "function_a": "search_and_replace",
          "function_b": "get_document_text",
          "state_description": "The text retrieved after search_and_replace reflects the replacements made, showing dependency on prior mutation."
        },
        {
          "function_a": "copy_document",
          "function_b": "get_document_info",
          "state_description": "get_document_info can be used on the copied document, whose existence depends on copy_document having been called."
        },
        {
          "function_a": "customize_footnote_style",
          "function_b": "add_footnote_to_document",
          "state_description": "Footnote appearance during addition may be influenced by prior customization of numbering format and styling."
        }
      ],
      "token_usage": {
        "prompt_tokens": 5548,
        "completion_tokens": 796,
        "total_tokens": 6344
      },
      "function_count": 25,
      "functions": [
        "office-word-document-server-unprotect_document",
        "office-word-document-server-add_table",
        "office-word-document-server-delete_paragraph",
        "office-word-document-server-search_and_replace",
        "office-word-document-server-add_heading",
        "office-word-document-server-add_footnote_to_document",
        "office-word-document-server-add_picture",
        "office-word-document-server-find_text_in_document",
        "office-word-document-server-add_endnote_to_document",
        "office-word-document-server-get_document_info",
        "office-word-document-server-get_document_text",
        "office-word-document-server-protect_document",
        "office-word-document-server-get_document_outline",
        "office-word-document-server-add_paragraph",
        "office-word-document-server-format_table",
        "office-word-document-server-add_page_break",
        "office-word-document-server-copy_document",
        "office-word-document-server-list_available_documents",
        "office-word-document-server-convert_footnotes_to_endnotes_in_document",
        "office-word-document-server-customize_footnote_style",
        "office-word-document-server-create_custom_style",
        "office-word-document-server-create_document",
        "office-word-document-server-format_text",
        "office-word-document-server-convert_to_pdf",
        "office-word-document-server-get_paragraph_text_from_document"
      ]
    },
    "After Effects MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The After Effects MCP Server maintains persistent state across function calls, as evidenced by the presence of functions that create or modify project elements (compositions, layers, keyframes, effects) which are later referenced by other functions using indices (e.g., `compIndex`, `layerIndex`). These indices imply a shared context tied to the current state of the After Effects project. For example, creating a composition with `create-composition` establishes a new composition that can be targeted by subsequent operations such as `setLayerKeyframe`, `apply-effect`, or `setLayerExpression`. Without the prior creation of a composition and likely addition of layers (implied though not directly exposed), these later functions would have no valid target and would fail. Furthermore, multiple tools (`setLayerKeyframe`, `apply-effect`, etc.) require knowledge of the structure and order of compositions and layers, indicating reliance on accumulated state. The use of 1-based indices for compositions and layers strongly suggests mutation of a global document model that persists across requests.",
      "state_dependencies": [
        {
          "function_a": "create-composition",
          "function_b": "setLayerKeyframe",
          "state_description": "Creating a composition with create-composition establishes a composition at a specific index, which is then referenced via compIndex in setLayerKeyframe to animate a layer property."
        },
        {
          "function_a": "create-composition",
          "function_b": "setLayerExpression",
          "state_description": "The composition created by create-composition is referenced by compIndex in setLayerExpression to apply an expression to a layer property."
        },
        {
          "function_a": "create-composition",
          "function_b": "apply-effect",
          "state_description": "The existence and index of a composition created by create-composition are required inputs (via compIndex) for applying an effect to a layer using apply-effect."
        },
        {
          "function_a": "create-composition",
          "function_b": "apply-effect-template",
          "state_description": "The created composition's index is used in apply-effect-template to target a specific layer within that composition for template application."
        },
        {
          "function_a": "create-composition",
          "function_b": "test-animation",
          "state_description": "The test-animation function requires a valid composition index (likely from a previously created composition) to perform animation tests on a specified layer."
        }
      ],
      "token_usage": {
        "prompt_tokens": 3289,
        "completion_tokens": 518,
        "total_tokens": 3807
      },
      "function_count": 13,
      "functions": [
        "after-effects-mcp-server-create-composition",
        "after-effects-mcp-server-get-results",
        "after-effects-mcp-server-mcp_aftereffects_applyEffectTemplate",
        "after-effects-mcp-server-setLayerKeyframe",
        "after-effects-mcp-server-test-animation",
        "after-effects-mcp-server-get-help",
        "after-effects-mcp-server-mcp_aftereffects_get_effects_help",
        "after-effects-mcp-server-apply-effect",
        "after-effects-mcp-server-setLayerExpression",
        "after-effects-mcp-server-run-script",
        "after-effects-mcp-server-apply-effect-template",
        "after-effects-mcp-server-mcp_aftereffects_applyEffect",
        "after-effects-mcp-server-run-bridge-test"
      ]
    },
    "Wallhaven Wallpaper Search Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "After analyzing all available tools in the Wallhaven Wallpaper Search Server, there is no evidence of functions that modify persistent state (e.g., create, update, or delete operations). All exposed functions are read-only: they retrieve data based on input parameters or authentication context but do not alter server-side state. For example:\n\n- `search_wallpapers`, `get_wallpaper`, and `get_tag_info` are purely query-based and depend only on their input arguments.\n- `get_user_settings`, `get_collections`, and `get_collection_wallpapers` retrieve user-specific data, but this data reflects pre-existing state tied to authentication (e.g., API key), not transient or mutable context set by prior function calls.\n\nWhile some functions require authentication (e.g., accessing user collections or settings), this represents static access control rather than stateful interaction. There are no functions that, for instance, add wallpapers to a collection, create a session, or set preferences that affect subsequent calls. Therefore, calling one function does not influence the behavior or output of another beyond what is defined by fixed user permissions and input parameters.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1686,
        "completion_tokens": 246,
        "total_tokens": 1932
      },
      "function_count": 6,
      "functions": [
        "wallhaven-wallpaper-search-server-get_tag_info",
        "wallhaven-wallpaper-search-server-search_wallpapers",
        "wallhaven-wallpaper-search-server-get_collection_wallpapers",
        "wallhaven-wallpaper-search-server-get_user_settings",
        "wallhaven-wallpaper-search-server-get_collections",
        "wallhaven-wallpaper-search-server-get_wallpaper"
      ]
    },
    "ennkaheksa": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The provided MCP server \"ennkaheksa\" exposes tools that interact with n8n nodes, but all available tools are read-only or metadata-oriented in nature. They retrieve documentation, list node types, search for properties, validate configurations, or return pre-defined templates — none of them perform operations that modify persistent state within the MCP server itself.  \n\nFor example:\n- `list_nodes`, `search_nodes`, and `get_node_info` retrieve static metadata about n8n nodes.\n- `get_node_documentation`, `get_node_essentials`, and `search_node_properties` return documentation or schema fragments.\n- Validation tools like `validate_node_operation` and `validate_workflow` analyze inputs without altering any internal state.\n- Template-related tools (`list_node_templates`, `get_template`) fetch predefined workflows from an external source.\n\nThere is no evidence of functions that create, update, or delete data on the server (e.g., saving sessions, storing credentials, modifying node configurations). Furthermore, there are no function pairs where one call sets a configuration or context that another call depends on. All function calls appear to be idempotent and independent.\n\nEven though some tools (like validation) may use temporary in-memory processing, there is no indication of shared, persistent context across calls. Therefore, the MCP server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 4716,
        "completion_tokens": 292,
        "total_tokens": 5008
      },
      "function_count": 22,
      "functions": [
        "ennkaheksa-get_node_info",
        "ennkaheksa-tools_documentation",
        "ennkaheksa-get_node_documentation",
        "ennkaheksa-search_node_properties",
        "ennkaheksa-search_templates",
        "ennkaheksa-get_node_for_task",
        "ennkaheksa-list_tasks",
        "ennkaheksa-validate_workflow",
        "ennkaheksa-search_nodes",
        "ennkaheksa-get_node_as_tool_info",
        "ennkaheksa-list_node_templates",
        "ennkaheksa-get_templates_for_task",
        "ennkaheksa-get_database_statistics",
        "ennkaheksa-get_template",
        "ennkaheksa-get_property_dependencies",
        "ennkaheksa-validate_node_operation",
        "ennkaheksa-list_ai_tools",
        "ennkaheksa-get_node_essentials",
        "ennkaheksa-validate_workflow_expressions",
        "ennkaheksa-validate_workflow_connections",
        "ennkaheksa-validate_node_minimal",
        "ennkaheksa-list_nodes"
      ]
    },
    "First MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "first-mcp-server-example_tool"
      ]
    },
    "Wikipedia Integration Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Wikipedia Integration Server are read-only operations that retrieve data from Wikipedia based on explicit input parameters (e.g., article title, query string). None of the functions perform create, update, delete, or any other state-modifying operations on the server itself or on Wikipedia. Each function call is independent and does not rely on side effects or persistent state changes from prior calls. For example, calling `search_wikipedia` does not alter the behavior of subsequent calls to `get_summary` or any other tool—the latter only depend on their own required inputs (like `title`), which must be provided explicitly each time. There is no indication of shared context, session state, configuration flags, or cached data that persists across requests and influences outcomes. Therefore, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1532,
        "completion_tokens": 186,
        "total_tokens": 1718
      },
      "function_count": 9,
      "functions": [
        "wikipedia-integration-server-get_summary",
        "wikipedia-integration-server-get_sections",
        "wikipedia-integration-server-summarize_article_for_query",
        "wikipedia-integration-server-get_related_topics",
        "wikipedia-integration-server-get_links",
        "wikipedia-integration-server-get_article",
        "wikipedia-integration-server-summarize_article_section",
        "wikipedia-integration-server-search_wikipedia",
        "wikipedia-integration-server-extract_key_facts"
      ]
    },
    "LGTM": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "lgtm-get_lgtm"
      ]
    },
    "Google News and Trends": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the \"Google News and Trends\" MCP server are read-only retrieval operations that fetch news articles or trending terms based on input parameters. None of the tools perform create, update, delete, or configuration-setting actions that would modify persistent state. Each function operates independently, accepting all necessary parameters explicitly (e.g., keyword, location, topic, geo) and returning results without relying on or altering shared context, sessions, or configurations. There is no indication that calling one function affects the behavior or output of another. For example, calling `get_news_by_keyword` does not influence the results of `get_top_news` or `get_trending_terms`, as they query different data sources with self-contained inputs. Additionally, optional parameters like `summarize` or `full_data` control processing locally within each call and do not persist across requests.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2017,
        "completion_tokens": 198,
        "total_tokens": 2215
      },
      "function_count": 5,
      "functions": [
        "google-news-and-trends-get_trending_terms",
        "google-news-and-trends-get_top_news",
        "google-news-and-trends-get_news_by_keyword",
        "google-news-and-trends-get_news_by_topic",
        "google-news-and-trends-get_news_by_location"
      ]
    },
    "Blockscout MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After thorough analysis of all available tools in the Blockscout MCP Server, there is no evidence of state-modifying operations (e.g., create, update, delete) or persistent state dependencies between function calls. All functions are read-only and retrieve blockchain data based solely on input parameters such as chain ID, address, transaction hash, or timestamps. The only exception is the required initial call to `__get_instructions__`, which appears to be a setup or handshake mechanism rather than a state-modifying operation. This tool likely initializes the session context for the AI agent but does not alter server-side state that affects subsequent function behavior beyond enabling proper functionality—consistent with initialization guards in stateless APIs. There are no indications that calling one function changes the output or behavior of another function in a persistent way. Pagination is supported via cursors in several tools (e.g., `get_tokens_by_address`, `nft_tokens_by_address`), but cursor-based pagination uses ephemeral, request-scoped tokens returned in responses and does not imply server-side mutable state. These cursors are typically time-limited and opaque handles managed by the backend without implying long-term statefulness from the client's perspective. No other functions depend on side effects from prior calls; each can be invoked independently given the correct inputs. Therefore, the system behaves as a stateless API with a mandatory initialization step.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 4626,
        "completion_tokens": 299,
        "total_tokens": 4925
      },
      "function_count": 16,
      "functions": [
        "blockscout-mcp-server-__get_instructions__",
        "blockscout-mcp-server-get_latest_block",
        "blockscout-mcp-server-get_transactions_by_address",
        "blockscout-mcp-server-nft_tokens_by_address",
        "blockscout-mcp-server-get_chains_list",
        "blockscout-mcp-server-lookup_token_by_symbol",
        "blockscout-mcp-server-get_block_info",
        "blockscout-mcp-server-get_address_logs",
        "blockscout-mcp-server-get_token_transfers_by_address",
        "blockscout-mcp-server-get_transaction_logs",
        "blockscout-mcp-server-get_address_info",
        "blockscout-mcp-server-transaction_summary",
        "blockscout-mcp-server-get_transaction_info",
        "blockscout-mcp-server-get_tokens_by_address",
        "blockscout-mcp-server-get_address_by_ens_name",
        "blockscout-mcp-server-get_contract_abi"
      ]
    },
    "OpenDota API Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The OpenDota API Server provides a set of read-only functions that retrieve data based on input parameters such as `account_id`, `match_id`, `hero_id`, or `team_id`. All available tools are designed to fetch existing data from external sources (e.g., player profiles, match histories, hero statistics) without modifying any persistent state. There are no evident operations for creating, updating, or deleting data (e.g., no functions like `update_player_profile`, `create_match`, or `set_preference`). Each function call is self-contained and does not rely on prior interactions or stored context such as sessions, authentication tokens, or configuration settings. For example, calling `get_player_recent_matches` does not require or depend on a previous call to `get_player_by_id`; both functions independently query backend systems using the provided `account_id`. Similarly, `search_player` returns results purely based on the search query, with no indication of session-based filtering or personalization. No pair of functions exhibits a producer-consumer relationship where one establishes state consumed by another. Therefore, there is no evidence of shared mutable state, session persistence, or cross-function dependency on prior side effects.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2430,
        "completion_tokens": 262,
        "total_tokens": 2692
      },
      "function_count": 17,
      "functions": [
        "opendota-api-server-get_player_win_loss",
        "opendota-api-server-get_player_totals",
        "opendota-api-server-get_team_info",
        "opendota-api-server-get_player_rankings",
        "opendota-api-server-get_player_wordcloud",
        "opendota-api-server-get_player_recent_matches",
        "opendota-api-server-get_public_matches",
        "opendota-api-server-get_match_data",
        "opendota-api-server-get_heroes",
        "opendota-api-server-get_match_heroes",
        "opendota-api-server-get_player_by_id",
        "opendota-api-server-get_pro_players",
        "opendota-api-server-search_player",
        "opendota-api-server-get_player_peers",
        "opendota-api-server-get_pro_matches",
        "opendota-api-server-get_player_heroes",
        "opendota-api-server-get_hero_stats"
      ]
    },
    "Dictionary Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 2,
      "functions": [
        "dictionary-server-get_definitions",
        "dictionary-server-get_definitions"
      ]
    },
    "Kuran-ı Kerim Quran API Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Kuran-ı Kerim Quran API Server are read-only operations that retrieve static religious content (Quranic text, metadata, editions, fonts, etc.) based on explicit input parameters. None of the functions perform create, update, delete, or configuration-setting operations that would modify persistent server state. Each function call is self-contained and requires all necessary context (e.g., edition_name, chapter_no, script_type) to be passed directly as arguments. There is no indication of shared mutable state, session tokens, cached contexts, or configurations established by one function and used by another. The API appears designed for stateless, idempotent access to immutable Quranic data.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2467,
        "completion_tokens": 166,
        "total_tokens": 2633
      },
      "function_count": 12,
      "functions": [
        "kuran-ı-kerim-quran-api-server-get_quran_page",
        "kuran-ı-kerim-quran-api-server-get_quran_manzil",
        "kuran-ı-kerim-quran-api-server-get_quran_verse",
        "kuran-ı-kerim-quran-api-server-get_quran_ruku",
        "kuran-ı-kerim-quran-api-server-get_quran_editions",
        "kuran-ı-kerim-quran-api-server-get_quran_juz",
        "kuran-ı-kerim-quran-api-server-get_quran_fonts",
        "kuran-ı-kerim-quran-api-server-get_quran_chapter",
        "kuran-ı-kerim-quran-api-server-get_quran_full",
        "kuran-ı-kerim-quran-api-server-get_quran_editions_min",
        "kuran-ı-kerim-quran-api-server-get_quran_maqra",
        "kuran-ı-kerim-quran-api-server-get_quran_info"
      ]
    },
    "Old School RuneScape Wiki and Data Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "After thorough analysis of all 19 available tools in the \"Old School RuneScape Wiki and Data Server\" MCP server, no functions are present that modify persistent state (e.g., create, update, or delete operations). All provided functions are read-only queries against static data sources such as wiki pages or game data files (e.g., `varptypes.txt`, `objtypes.txt`). None of the tools introduce side effects, store session-specific data, set configurations, or alter server state in any way.\n\nEach function operates independently and does not rely on prior function calls. For example:\n- `osrs_wiki_search` returns search results based solely on input parameters.\n- `osrs_wiki_get_page_info` retrieves page metadata using titles passed directly as arguments.\n- The various `search_*` tools (e.g., `search_objtypes`, `search_npctypes`) query predefined data files without altering internal or shared state.\n- Even `get_file_details` and `list_data_files`, which provide metadata about available files, do not establish or depend on mutable context.\n\nThere is no evidence of shared sessions, cached contexts, or configuration states that persist across requests. All outputs are fully determined by explicit input parameters with no hidden dependencies.\n\nTherefore, this MCP server is purely stateless: every function call is self-contained, idempotent, and independent of previous interactions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 3607,
        "completion_tokens": 304,
        "total_tokens": 3911
      },
      "function_count": 19,
      "functions": [
        "old-school-runescape-wiki-and-data-server-search_loctypes",
        "old-school-runescape-wiki-and-data-server-search_spritetypes",
        "old-school-runescape-wiki-and-data-server-search_tabletypes",
        "old-school-runescape-wiki-and-data-server-osrs_wiki_get_page_info",
        "old-school-runescape-wiki-and-data-server-search_varptypes",
        "old-school-runescape-wiki-and-data-server-osrs_wiki_parse_page",
        "old-school-runescape-wiki-and-data-server-search_spottypes",
        "old-school-runescape-wiki-and-data-server-osrs_wiki_search",
        "old-school-runescape-wiki-and-data-server-search_objtypes",
        "old-school-runescape-wiki-and-data-server-search_varbittypes",
        "old-school-runescape-wiki-and-data-server-search_invtypes",
        "old-school-runescape-wiki-and-data-server-get_file_details",
        "old-school-runescape-wiki-and-data-server-search_soundtypes",
        "old-school-runescape-wiki-and-data-server-list_data_files",
        "old-school-runescape-wiki-and-data-server-search_data_file",
        "old-school-runescape-wiki-and-data-server-search_seqtypes",
        "old-school-runescape-wiki-and-data-server-search_iftypes",
        "old-school-runescape-wiki-and-data-server-search_rowtypes",
        "old-school-runescape-wiki-and-data-server-search_npctypes"
      ]
    },
    "MCPollinations Multimodal Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The MCPollinations Multimodal Server provides functions for generating images, audio, and text from prompts, as well as listing available models and voices. All of the provided tools are stateless in nature: each function call operates independently, taking explicit input parameters (such as `prompt`, `model`, `seed`, etc.) and producing output without modifying any shared or persistent server-side state. There is no indication that any function creates, updates, or deletes persistent data that would affect the behavior of subsequent calls to other functions. For example:\n- `generateImageUrl` and `generateImage` both generate media from a prompt but do not store or alter global configuration.\n- `listImageModels`, `listAudioVoices`, and `listTextModels` are pure read operations with no dependencies on prior writes.\n- `respondAudio` and `respondText` generate responses based solely on input parameters and do not rely on session context or prior interactions.\n\nNo function requires or references artifacts (e.g., session IDs, configuration flags, stored data) created by another function. The optional `outputPath` and `fileName` in `generateImage` relate only to local file system output and do not imply server-side state persistence. Additionally, the absence of authentication and emphasis on \"simple setup\" further supports a stateless, REST-like API design typical of such generative services.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1667,
        "completion_tokens": 300,
        "total_tokens": 1967
      },
      "function_count": 14,
      "functions": [
        "mcpollinations-respondAudio",
        "mcpollinations-multimodal-server-respondAudio",
        "mcpollinations-multimodal-server-generateImageUrl",
        "mcpollinations-listTextModels",
        "mcpollinations-listAudioVoices",
        "mcpollinations-multimodal-server-listAudioVoices",
        "mcpollinations-multimodal-server-listImageModels",
        "mcpollinations-multimodal-server-respondText",
        "mcpollinations-listImageModels",
        "mcpollinations-generateImage",
        "mcpollinations-respondText",
        "mcpollinations-generateImageUrl",
        "mcpollinations-multimodal-server-listTextModels",
        "mcpollinations-multimodal-server-generateImage"
      ]
    },
    "PyMCP": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available functions in the PyMCP server, there is no evidence of stateful behavior. Each function operates independently and does not modify or depend on any shared persistent state:\n\n1. **greet**: This function returns a greeting message based solely on the input parameter `name`. It does not store or modify any system state.\n2. **generate_password**: Generates a random password based on input parameters (`length`, `use_special_chars`) and internal logic. The generation process is self-contained and does not affect or rely on external state.\n3. **permutations**: Computes a mathematical value (P(n,k)) from inputs `n` and `k`. It is a pure function with no side effects or state dependencies.\n4. **pirate_summary**: Takes a text input and returns a transformed output using LLM sampling. While it may use an external model, it does not retain or depend on session-specific context across calls.\n5. **vonmises_random**: Generates a random number from the von Mises distribution given `mu`. Although it may involve elicitation for `kappa`, this appears to be part of the parameter acquisition during the call and does not imply persistent state storage.\n\nNone of the functions perform create/update/delete operations that persist beyond the scope of a single invocation. There are no indications of shared sessions, configurations, or contexts that carry over between function calls. All outputs depend strictly on their inputs and internal logic, with no observable inter-function state coupling.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1235,
        "completion_tokens": 324,
        "total_tokens": 1559
      },
      "function_count": 5,
      "functions": [
        "pymcp-greet",
        "pymcp-pirate_summary",
        "pymcp-generate_password",
        "pymcp-permutations",
        "pymcp-vonmises_random"
      ]
    },
    "NPM Sentinel MCP": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the NPM Sentinel MCP server are read-only functions that retrieve information about NPM packages. None of the functions perform create, update, or delete operations that would modify persistent state on the server. Each function takes a list of package names (and optionally other parameters) as input and returns data derived from external sources such as the NPM registry, GitHub repositories, or vulnerability databases. There is no evidence of shared context, sessions, configurations, or internal state being created or modified by one function that affects the behavior or output of another. For example, calling `npmVersions` does not alter the result of subsequent calls to `npmLatest` or any other tool. All functions appear to be idempotent and state-independent, relying solely on external package metadata rather than internal server state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2827,
        "completion_tokens": 187,
        "total_tokens": 3014
      },
      "function_count": 19,
      "functions": [
        "npm-sentinel-mcp-npmCompare",
        "npm-sentinel-mcp-npmPackageReadme",
        "npm-sentinel-mcp-npmMaintenance",
        "npm-sentinel-mcp-npmLicenseCompatibility",
        "npm-sentinel-mcp-npmSize",
        "npm-sentinel-mcp-npmAlternatives",
        "npm-sentinel-mcp-npmChangelogAnalysis",
        "npm-sentinel-mcp-npmQuality",
        "npm-sentinel-mcp-npmDeps",
        "npm-sentinel-mcp-npmSearch",
        "npm-sentinel-mcp-npmRepoStats",
        "npm-sentinel-mcp-npmLatest",
        "npm-sentinel-mcp-npmDeprecated",
        "npm-sentinel-mcp-npmScore",
        "npm-sentinel-mcp-npmVulnerabilities",
        "npm-sentinel-mcp-npmMaintainers",
        "npm-sentinel-mcp-npmTypes",
        "npm-sentinel-mcp-npmTrends",
        "npm-sentinel-mcp-npmVersions"
      ]
    },
    "n8n Workflow Builder": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "n8n-workflow-builder-create_workflow"
      ]
    },
    "Azure Integration Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Azure Integration Server exhibits clear stateful behavior due to the presence of functions that modify persistent context (such as tenant and subscription selection) which directly influence the behavior of subsequent function calls. Specifically, the `select-tenant` tool modifies the server-side execution context by setting the active Azure tenant and subscription. All other tools—such as `list-resource-groups`, `get-user-permissions`, `run-azure-code`, and others—implicitly depend on this selected context to operate within the correct scope. Without an explicit call to `select-tenant`, these functions may default to a subscription or tenant, but their results can change based on prior use of `select-tenant`. This establishes a dependency where one function (`select-tenant`) sets runtime state that affects the outcome of multiple other functions.\n\nAdditionally, operations like `create-resource-group` modify the cloud environment state, and subsequent calls to `list-resource-groups` or `get-resource-details` would reflect those changes, further reinforcing stateful interactions. However, the most consistent and pervasive state dependency is the context established by `select-tenant`.",
      "state_dependencies": [
        {
          "function_a": "select-tenant",
          "function_b": "list-resource-groups",
          "state_description": "The selected tenant and subscription from select-tenant determines which resource groups are listed"
        },
        {
          "function_a": "select-tenant",
          "function_b": "get-user-permissions",
          "state_description": "The selected scope from select-tenant affects the user permissions retrieved"
        },
        {
          "function_a": "select-tenant",
          "function_b": "run-azure-code",
          "state_description": "The selected tenant and subscription are used as context for executing Azure SDK code unless overridden in parameters"
        },
        {
          "function_a": "create-resource-group",
          "function_b": "list-resource-groups",
          "state_description": "Creating a new resource group modifies the environment, affecting the list returned by subsequent calls"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1381,
        "completion_tokens": 432,
        "total_tokens": 1813
      },
      "function_count": 6,
      "functions": [
        "azure-mcp-run-azure-code",
        "azure-mcp-select-tenant",
        "azure-mcp-create-resource-group",
        "azure-mcp-list-tenants",
        "azure-mcp-list-resource-groups",
        "azure-mcp-get-resource-details"
      ]
    },
    "Virtual Traveling Bot": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Virtual Traveling Bot MCP server exhibits clear stateful behavior based on the available tools. Multiple functions modify persistent state (e.g., `set_traveler_info`), while others depend on that state being set (e.g., `get_traveler_info`). Additionally, journey control functions (`start_traveler_journey`, `stop_traveler_journey`) imply a shared runtime state that persists across calls—starting and stopping a journey only makes sense if there is an ongoing, mutable journey state. Furthermore, `get_setting` likely reflects configuration or context that may be influenced by prior setup actions (such as setting API tokens in practice mode vs. real mode), indicating internal state persistence. The presence of settings that affect traveler behavior (name, language, personality) confirms that state set by one function influences the output or operation of others.",
      "state_dependencies": [
        {
          "function_a": "set_traveler_info",
          "function_b": "get_traveler_info",
          "state_description": "Traveler settings such as name, language, personality are set by set_traveler_info and later retrieved by get_traveler_info"
        },
        {
          "function_a": "set_traveler_info",
          "function_b": "get_traveler_view_info",
          "state_description": "The traveler's language and personality settings influence the narrative style or content returned in location views"
        },
        {
          "function_a": "start_traveler_journey",
          "function_b": "stop_traveler_journey",
          "state_description": "The journey state must be 'active' for stop_traveler_journey to have effect; start initiates this shared state"
        },
        {
          "function_a": "start_traveler_journey",
          "function_b": "get_traveler_location",
          "state_description": "The traveler's location may change over time during an active journey initiated by start_traveler_journey"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1030,
        "completion_tokens": 414,
        "total_tokens": 1444
      },
      "function_count": 8,
      "functions": [
        "virtual-traveling-bot-get_traveler_info",
        "virtual-traveling-bot-get_traveler_location",
        "virtual-traveling-bot-get_setting",
        "virtual-traveling-bot-set_traveler_info",
        "virtual-traveling-bot-get_traveler_view_info",
        "virtual-traveling-bot-stop_traveler_journey",
        "virtual-traveling-bot-start_traveler_journey",
        "virtual-traveling-bot-tips"
      ]
    },
    "CCXT Cryptocurrency Exchange Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The CCXT Cryptocurrency Exchange Server provides a set of tools that are primarily stateless API wrappers around cryptocurrency exchange operations. Each function call is self-contained and includes all necessary parameters (such as `exchange_id`, authentication credentials, and market context via `params`) to perform its operation independently. There is no explicit function that creates or modifies persistent client-side state (e.g., no `create_session`, `set_context`, or `initialize_client` tool). While some functions require configuration like `{'options': {'defaultType': 'future'}}` in the `params` field to correctly interact with non-spot markets, this configuration is passed explicitly in each relevant function call rather than being set once and reused across subsequent calls. Authentication keys are optional inputs per call and not stored or implied from prior interactions. All operations—whether reading data (`fetch_*`) or performing actions (`create_*`, `withdraw_*`, `cancel_*`)—do not rely on side effects from previous calls. Even if an order is created, canceling it does not depend on internal server state but only on externally provided identifiers. Thus, there is no shared mutable state between function invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 16130,
        "completion_tokens": 259,
        "total_tokens": 16389
      },
      "function_count": 19,
      "functions": [
        "ccxt-cryptocurrency-exchange-server-fetch_order_history",
        "ccxt-cryptocurrency-exchange-server-cancel_order",
        "ccxt-cryptocurrency-exchange-server-fetch_long_short_ratio",
        "ccxt-cryptocurrency-exchange-server-fetch_public_market_trades",
        "ccxt-cryptocurrency-exchange-server-fetch_account_balance",
        "ccxt-cryptocurrency-exchange-server-calculate_technical_indicator",
        "ccxt-cryptocurrency-exchange-server-create_futures_limit_order",
        "ccxt-cryptocurrency-exchange-server-create_spot_limit_order",
        "ccxt-cryptocurrency-exchange-server-withdraw_cryptocurrency",
        "ccxt-cryptocurrency-exchange-server-fetch_funding_rate",
        "ccxt-cryptocurrency-exchange-server-fetch_deposit_address",
        "ccxt-cryptocurrency-exchange-server-fetch_my_trade_history",
        "ccxt-cryptocurrency-exchange-server-fetch_open_positions",
        "ccxt-cryptocurrency-exchange-server-create_futures_market_order",
        "ccxt-cryptocurrency-exchange-server-fetch_ohlcv",
        "ccxt-cryptocurrency-exchange-server-set_trading_leverage",
        "ccxt-cryptocurrency-exchange-server-fetch_option_contract_data",
        "ccxt-cryptocurrency-exchange-server-create_spot_market_order",
        "ccxt-cryptocurrency-exchange-server-fetch_market_ticker"
      ]
    },
    "AI Lab MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The two available functions, `get_members` and `get_member_phone`, are both read-only operations that do not modify any system state. There is no indication that calling one function alters configurations, creates sessions, stores data, or otherwise affects the environment in a way that influences subsequent calls. The `get_member_phone` function depends solely on the input parameter `name` to retrieve a phone number, and `get_members` returns a list without requiring any prior setup. No shared context, session, or configuration is indicated as being created or modified by these functions. Since there are no write operations or observable side effects, and no evidence of inter-function state reliance, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 634,
        "completion_tokens": 165,
        "total_tokens": 799
      },
      "function_count": 2,
      "functions": [
        "ai-lab-mcp-server-get_member_phone",
        "ai-lab-mcp-server-get_members"
      ]
    },
    "Unity MCP Integration": {
      "is_stateful": true,
      "confidence": 0.98,
      "reasoning": "The MCP server exposes several functions that modify persistent state within the Unity project (e.g., file system and scene state), and other functions that retrieve or depend on that modified state. For example, writing to a file using `write_file` changes the content of a file in the Unity project, and subsequent calls to `read_file`, `get_current_scene_info`, or `execute_editor_command` may return different results depending on that written content. Similarly, executing C# code via `execute_editor_command` can alter the internal state of the Unity Editor (e.g., modifying GameObjects, changing variables, creating assets), which will affect future queries such as `get_logs`, `get_current_scene_info`, or `get_game_objects_info`. These cross-call dependencies demonstrate clear statefulness.\n\nAdditionally, tools like `edit_file`, `write_file`, and `execute_editor_command` actively mutate the environment, while tools like `read_file`, `get_logs`, and scene inspection tools observe the current state—making the output of the latter dependent on prior use of the former. This tight coupling through shared mutable state confirms the server is stateful.",
      "state_dependencies": [
        {
          "function_a": "write_file",
          "function_b": "read_file",
          "state_description": "The content of a file written by write_file is directly readable by read_file; thus, read_file's output depends on prior writes."
        },
        {
          "function_a": "write_file",
          "function_b": "read_multiple_files",
          "state_description": "Files written with write_file can be included in bulk reads via read_multiple_files, making its output dependent on previous writes."
        },
        {
          "function_a": "write_file",
          "function_b": "get_file_info",
          "state_description": "Writing a file updates its metadata (e.g., size, modification time), which affects the result of get_file_info."
        },
        {
          "function_a": "edit_file",
          "function_b": "read_file",
          "state_description": "Editing a file modifies its content, which will be reflected when reading it later with read_file."
        },
        {
          "function_a": "execute_editor_command",
          "function_b": "get_current_scene_info",
          "state_description": "Executing C# code can instantiate, modify, or destroy GameObjects in the scene, altering what is returned by get_current_scene_info."
        },
        {
          "function_a": "execute_editor_command",
          "function_b": "get_game_objects_info",
          "state_description": "Code execution can change component values, hierarchy, or GameObject properties, affecting detailed queries from get_game_objects_info."
        },
        {
          "function_a": "execute_editor_command",
          "function_b": "get_logs",
          "state_description": "Executed C# code may generate log entries (e.g., Debug.Log), which are then retrievable via get_logs."
        },
        {
          "function_a": "execute_editor_command",
          "function_b": "get_editor_state",
          "state_description": "Code execution can change the editor mode, selection, or project settings, potentially affecting the reported editor state."
        },
        {
          "function_a": "execute_editor_command",
          "function_b": "find_assets_by_type",
          "state_description": "Code execution might create new assets (e.g., ScriptableObjects), increasing the count of assets found by type."
        },
        {
          "function_a": "write_file",
          "function_b": "search_files",
          "state_description": "Creating or modifying files can cause them to appear in search results when searching by pattern."
        }
      ],
      "token_usage": {
        "prompt_tokens": 3100,
        "completion_tokens": 777,
        "total_tokens": 3877
      },
      "function_count": 15,
      "functions": [
        "unity-mcp-integration-get_logs",
        "unity-mcp-integration-write_file",
        "unity-mcp-integration-get_file_info",
        "unity-mcp-integration-search_files",
        "unity-mcp-integration-edit_file",
        "unity-mcp-integration-execute_editor_command",
        "unity-mcp-integration-directory_tree",
        "unity-mcp-integration-read_file",
        "unity-mcp-integration-get_game_objects_info",
        "unity-mcp-integration-list_directory",
        "unity-mcp-integration-get_current_scene_info",
        "unity-mcp-integration-verify_connection",
        "unity-mcp-integration-get_editor_state",
        "unity-mcp-integration-read_multiple_files",
        "unity-mcp-integration-find_assets_by_type"
      ]
    },
    "Playwright Automation Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Playwright Automation Server maintains state across multiple function calls, particularly through the concept of a *code generation session*. The `start_codegen_session` tool creates a new session with specific configuration (e.g., output path, test name prefix), which persists until explicitly ended or cleared. Subsequent tools like `end_codegen_session`, `get_codegen_session`, and `clear_codegen_session` all require a `sessionId` parameter to operate on this existing session state. This indicates that the server must maintain internal state associated with each session.\n\nAdditionally, browser context is preserved across navigation and interaction tools. For example, calling `playwright_navigate` loads a page in a browser context, and subsequent calls to `playwright_click`, `playwright_fill`, or `playwright_screenshot` act on that same page state. Actions are sequential and depend on prior page state — for instance, clicking an element only works if it exists after a prior navigation. Similarly, `playwright_go_back` and `playwright_go_forward` rely on browser history being maintained across calls.\n\nOther stateful behaviors include:\n- `playwright_expect_response` sets up an expectation for a future HTTP response identified by `id`, which is later retrieved and validated by `playwright_assert_response`. This establishes a clear producer-consumer relationship across calls.\n- `playwright_custom_user_agent` modifies the browser's user agent setting, which affects subsequent requests made by the browser.\n- Tools like `playwright_console_logs` support clearing logs after retrieval, implying logs are accumulated over time and persist between calls.\n\nAll these behaviors confirm that the server maintains shared, mutable state across function invocations.",
      "state_dependencies": [
        {
          "function_a": "start_codegen_session",
          "function_b": "end_codegen_session",
          "state_description": "Session ID and code generation context created by start_codegen_session must be referenced by end_codegen_session to finalize and save the test."
        },
        {
          "function_a": "start_codegen_session",
          "function_b": "get_codegen_session",
          "state_description": "Session metadata and recorded actions from start_codegen_session are retrieved via get_codegen_session using the sessionId."
        },
        {
          "function_a": "start_codegen_session",
          "function_b": "clear_codegen_session",
          "state_description": "The session state initialized by start_codegen_session is removed when clear_codegen_session is called with its sessionId."
        },
        {
          "function_a": "playwright_expect_response",
          "function_b": "playwright_assert_response",
          "state_description": "An expected HTTP response identified by 'id' is registered with playwright_expect_response and later awaited and validated by playwright_assert_response."
        },
        {
          "function_a": "playwright_navigate",
          "function_b": "playwright_click",
          "state_description": "The page context loaded by playwright_navigate determines the DOM elements available for interaction via playwright_click."
        },
        {
          "function_a": "playwright_navigate",
          "function_b": "playwright_screenshot",
          "state_description": "The current page state established by playwright_navigate is what gets captured when playwright_screenshot is called."
        },
        {
          "function_a": "playwright_custom_user_agent",
          "function_b": "playwright_navigate",
          "state_description": "The custom user agent set by playwright_custom_user_agent affects the headers sent during subsequent navigations via playwright_navigate."
        },
        {
          "function_a": "playwright_navigate",
          "function_b": "playwright_go_back",
          "state_description": "Navigating to a page with playwright_navigate adds an entry to browser history, enabling playwright_go_back to return to the previous page."
        }
      ],
      "token_usage": {
        "prompt_tokens": 3849,
        "completion_tokens": 785,
        "total_tokens": 4634
      },
      "function_count": 30,
      "functions": [
        "playwright-automation-server-playwright_console_logs",
        "playwright-automation-server-playwright_select",
        "playwright-automation-server-playwright_close",
        "playwright-automation-server-playwright_delete",
        "playwright-automation-server-playwright_put",
        "playwright-automation-server-playwright_click",
        "playwright-automation-server-playwright_post",
        "playwright-automation-server-clear_codegen_session",
        "playwright-automation-server-playwright_screenshot",
        "playwright-automation-server-playwright_go_back",
        "playwright-automation-server-get_codegen_session",
        "playwright-automation-server-end_codegen_session",
        "playwright-automation-server-playwright_get",
        "playwright-automation-server-playwright_hover",
        "playwright-automation-server-playwright_go_forward",
        "playwright-automation-server-playwright_assert_response",
        "playwright-automation-server-playwright_expect_response",
        "playwright-automation-server-playwright_navigate",
        "playwright-automation-server-playwright_fill",
        "playwright-automation-server-playwright_get_visible_html",
        "playwright-automation-server-start_codegen_session",
        "playwright-automation-server-playwright_evaluate",
        "playwright-automation-server-playwright_save_as_pdf",
        "playwright-automation-server-playwright_iframe_click",
        "playwright-automation-server-playwright_drag",
        "playwright-automation-server-playwright_press_key",
        "playwright-automation-server-playwright_click_and_switch_tab",
        "playwright-automation-server-playwright_get_visible_text",
        "playwright-automation-server-playwright_patch",
        "playwright-automation-server-playwright_custom_user_agent"
      ]
    },
    "CCXT MCP Server": {
      "is_stateful": true,
      "confidence": 0.98,
      "reasoning": "The CCXT MCP Server exhibits strong stateful behavior through multiple configuration and caching mechanisms that persist across function calls. Several tools modify global or exchange-specific settings (e.g., proxy, log level, market type, cache), and subsequent calls to data-fetching or trading functions depend on these settings. For example:\n\n- `set-proxy-config` modifies the global proxy configuration, which affects all future API requests made via exchange clients.\n- `set-log-level` changes logging behavior globally, indicating internal state modification.\n- `set-market-type` sets a default market type that influences how other functions like `get-ticker` or `get-orderbook` interpret requests unless overridden.\n- `clear-cache` and `clear-exchange-cache` imply the existence of a shared, mutable cache that impacts performance and possibly data freshness for read operations like `get-ticker`, `batch-get-tickers`, and `get-ohlcv`.\n- Tools like `set-leverage`, `set-margin-mode`, and `place-futures-market-order` require authentication credentials and likely interact with user-specific trading state on the exchange side, but also may rely on previously configured parameters (like market type or leverage tiers) that are set in prior calls.\n\nThese dependencies confirm that the server maintains and relies on persistent context between calls, making it clearly stateful.",
      "state_dependencies": [
        {
          "function_a": "set-proxy-config",
          "function_b": "test-proxy-connection",
          "state_description": "Proxy configuration set by set-proxy-config is used by test-proxy-connection to validate connectivity"
        },
        {
          "function_a": "set-proxy-config",
          "function_b": "get-ticker",
          "state_description": "Proxy settings affect how get-ticker connects to the exchange backend"
        },
        {
          "function_a": "set-market-type",
          "function_b": "get-ticker",
          "state_description": "Default market type set by set-market-type influences the market context used by get-ticker if not explicitly specified"
        },
        {
          "function_a": "set-market-type",
          "function_b": "get-orderbook",
          "state_description": "Default market type affects which orderbook (e.g., spot vs futures) is fetched when marketType is omitted"
        },
        {
          "function_a": "clear-cache",
          "function_b": "cache-stats",
          "state_description": "Clearing the cache with clear-cache will change the hit/miss statistics reported by cache-stats"
        },
        {
          "function_a": "set-log-level",
          "function_b": "get-exchange-info",
          "state_description": "Logging level set by set-log-level controls internal logging during execution of get-exchange-info"
        },
        {
          "function_a": "set-leverage",
          "function_b": "place-futures-market-order",
          "state_description": "Leverage setting may influence margin calculations or risk checks during order placement"
        },
        {
          "function_a": "set-margin-mode",
          "function_b": "place-futures-market-order",
          "state_description": "Margin mode (cross/isolated) set previously affects how positions are managed during order execution"
        }
      ],
      "token_usage": {
        "prompt_tokens": 4646,
        "completion_tokens": 681,
        "total_tokens": 5327
      },
      "function_count": 24,
      "functions": [
        "ccxt-mcp-server-clear-exchange-cache",
        "ccxt-mcp-server-list-exchanges",
        "ccxt-mcp-server-set-log-level",
        "ccxt-mcp-server-cache-stats",
        "ccxt-mcp-server-get-orderbook",
        "ccxt-mcp-server-place-futures-market-order",
        "ccxt-mcp-server-get-proxy-config",
        "ccxt-mcp-server-set-leverage",
        "ccxt-mcp-server-place-market-order",
        "ccxt-mcp-server-get-ohlcv",
        "ccxt-mcp-server-get-markets",
        "ccxt-mcp-server-get-leverage-tiers",
        "ccxt-mcp-server-get-funding-rates",
        "ccxt-mcp-server-batch-get-tickers",
        "ccxt-mcp-server-set-market-type",
        "ccxt-mcp-server-account-balance",
        "ccxt-mcp-server-set-proxy-config",
        "ccxt-mcp-server-get-exchange-info",
        "ccxt-mcp-server-set-margin-mode",
        "ccxt-mcp-server-get-trades",
        "ccxt-mcp-server-get-market-types",
        "ccxt-mcp-server-clear-cache",
        "ccxt-mcp-server-test-proxy-connection",
        "ccxt-mcp-server-get-ticker"
      ]
    },
    "Scientific Computation MCP Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Scientific Computation MCP Server maintains an in-memory tensor store that persists across function calls. Multiple functions both modify and depend on this shared state. Specifically, the `create_tensor` function stores a named tensor in this persistent store, and numerous other functions (e.g., `add_matrices`, `view_tensor`, `determinant`, etc.) require the presence of a previously created tensor by name to operate. The behavior of these functions is directly dependent on prior calls that establish the required state. Additionally, functions like `delete_tensor` explicitly remove state, further confirming the persistence and mutability of server-side context. This clear separation between state-modifying and state-dependent operations confirms that the server is stateful.",
      "state_dependencies": [
        {
          "function_a": "create_tensor",
          "function_b": "view_tensor",
          "state_description": "A tensor created with a specific name via create_tensor must exist for view_tensor to retrieve it from the in-memory store."
        },
        {
          "function_a": "create_tensor",
          "function_b": "add_matrices",
          "state_description": "Two tensors created and stored under specific names via create_tensor are required inputs for add_matrices to perform element-wise addition."
        },
        {
          "function_a": "create_tensor",
          "function_b": "subtract_matrices",
          "state_description": "Stored tensors by name are required as inputs for subtract_matrices to compute their difference."
        },
        {
          "function_a": "create_tensor",
          "function_b": "multiply_matrices",
          "state_description": "Matrix multiplication depends on two previously stored matrices existing in the tensor store under specified names."
        },
        {
          "function_a": "create_tensor",
          "function_b": "scale_matrix",
          "state_description": "The scale_matrix function operates on a tensor previously created and stored by create_tensor; if in_place=True, it modifies the same stored tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "matrix_inverse",
          "state_description": "The matrix_inverse function requires a square matrix to be present in the store under a given name, which must have been created earlier using create_tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "determinant",
          "state_description": "Computing the determinant requires a stored square matrix created previously with create_tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "rank",
          "state_description": "The rank function computes the rank of a tensor that must already exist in the store from a prior create_tensor call."
        },
        {
          "function_a": "create_tensor",
          "function_b": "compute_eigen",
          "state_description": "Eigenvalue computation requires a square matrix stored under a given name, established by create_tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "qr_decompose",
          "state_description": "QR decomposition operates on a matrix stored in memory after being created with create_tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "svd_decompose",
          "state_description": "SVD decomposition requires a matrix to be present in the tensor store, created via create_tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "find_orthonormal_basis",
          "state_description": "The orthonormal basis computation depends on a matrix previously stored using create_tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "change_basis",
          "state_description": "Changing the basis of a matrix requires the original matrix to exist in the store from a prior create_tensor call."
        },
        {
          "function_a": "create_tensor",
          "function_b": "vector_project",
          "state_description": "Projecting a vector requires it to have been stored earlier using create_tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "vector_dot_product",
          "state_description": "Dot product computation requires two vectors to be stored under specified names, created via create_tensor."
        },
        {
          "function_a": "create_tensor",
          "function_b": "vector_cross_product",
          "state_description": "Cross product depends on two stored 3D vectors created earlier with create_tensor."
        },
        {
          "function_a": "delete_tensor",
          "function_b": "view_tensor",
          "state_description": "Calling delete_tensor removes a tensor from the store, causing subsequent view_tensor calls with the same name to fail due to missing state."
        },
        {
          "function_a": "delete_tensor",
          "function_b": "add_matrices",
          "state_description": "Deleting one of the operand tensors via delete_tensor will cause future add_matrices calls referencing it to fail."
        }
      ],
      "token_usage": {
        "prompt_tokens": 5393,
        "completion_tokens": 1042,
        "total_tokens": 6435
      },
      "function_count": 26,
      "functions": [
        "scientific-computation-mcp-server-laplacian",
        "scientific-computation-mcp-server-plot_function",
        "scientific-computation-mcp-server-subtract_matrices",
        "scientific-computation-mcp-server-create_tensor",
        "scientific-computation-mcp-server-vector_project",
        "scientific-computation-mcp-server-vector_dot_product",
        "scientific-computation-mcp-server-delete_tensor",
        "scientific-computation-mcp-server-curl",
        "scientific-computation-mcp-server-rank",
        "scientific-computation-mcp-server-divergence",
        "scientific-computation-mcp-server-transpose",
        "scientific-computation-mcp-server-vector_cross_product",
        "scientific-computation-mcp-server-compute_eigen",
        "scientific-computation-mcp-server-matrix_inverse",
        "scientific-computation-mcp-server-plot_vector_field",
        "scientific-computation-mcp-server-change_basis",
        "scientific-computation-mcp-server-view_tensor",
        "scientific-computation-mcp-server-determinant",
        "scientific-computation-mcp-server-find_orthonormal_basis",
        "scientific-computation-mcp-server-qr_decompose",
        "scientific-computation-mcp-server-scale_matrix",
        "scientific-computation-mcp-server-gradient",
        "scientific-computation-mcp-server-add_matrices",
        "scientific-computation-mcp-server-multiply_matrices",
        "scientific-computation-mcp-server-directional_deriv",
        "scientific-computation-mcp-server-svd_decompose"
      ]
    },
    "Reddit Content Fetcher": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Both available functions, `fetch_reddit_hot_threads` and `fetch_reddit_post_content`, are read-only operations that retrieve data from Reddit based on direct inputs (subreddit name and post ID, respectively). Neither function modifies any system state, creates sessions, stores data, or alters configurations. Each function operates independently using only the parameters provided in the call. There is no indication that calling one function affects the behavior or output of the other. For example, fetching hot threads does not set up or influence the context needed for fetching a specific post’s content—the latter relies solely on the provided `post_id`, which is an external identifier from Reddit, not an internal state created by the server. Furthermore, no shared session, authentication token, or configuration persistence is indicated in the tool descriptions or parameters.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 827,
        "completion_tokens": 186,
        "total_tokens": 1013
      },
      "function_count": 2,
      "functions": [
        "reddit-content-fetcher-fetch_reddit_hot_threads",
        "reddit-content-fetcher-fetch_reddit_post_content"
      ]
    },
    "IBGE Municipality Listing Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the IBGE Municipality Listing Server are read-only operations that retrieve data based on explicit input parameters. None of the functions perform create, update, or delete operations that would modify persistent server state. Each function operates independently and does not rely on prior function calls to succeed. For example:\n\n- `GetUfPorIdentificdor` retrieves data about a Brazilian state (UF) using an identifier.\n- `GetMunicipiosPorUF` returns municipalities for a given UF code provided directly as a parameter.\n- `GetDistritosPorMunicipio` fetches districts using an explicit municipality code.\n- `GetPaisPorIdentificador` and `GetMunicipioPorIdentificador` similarly retrieve country and municipality data by direct identifiers.\n\nThere is no indication that calling one function sets up configuration, session context, cached data, or any other form of shared state that affects the behavior of another function. All required data is passed explicitly via parameters, and there are no side effects from function calls. Therefore, this MCP server exhibits stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1125,
        "completion_tokens": 240,
        "total_tokens": 1365
      },
      "function_count": 5,
      "functions": [
        "ibge-municipality-listing-server-GetDistritosPorMunicipio",
        "ibge-municipality-listing-server-GetUfPorIdentificdor",
        "ibge-municipality-listing-server-GetPaisPorIdentificador",
        "ibge-municipality-listing-server-GetMunicipioPorIdentificador",
        "ibge-municipality-listing-server-GetMunicipiosPorUF"
      ]
    },
    "Atlas Docs": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Atlas Docs MCP server provides read-only access to hosted documentation and does not include any functions that modify persistent state. All available tools (list_docs, search_docs, get_docs_index, get_docs_page, get_docs_full) are purely retrieval operations that fetch data based on input parameters without creating, updating, or deleting any system state. None of the functions depend on prior function calls to set up configurations, sessions, or stored data—each function operates independently using explicitly provided inputs (e.g., docName, pagePath, query). There is no shared context, session, or configuration that persists across calls. For example, calling search_docs does not rely on a prior call to list_docs; it only requires the correct docName, which could be known in advance. Similarly, retrieving a page via get_docs_page does not require any initialization step beyond knowing the docName and pagePath. Since there are no state-modifying operations and no dependencies on prior execution state, the server is stateless.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1192,
        "completion_tokens": 225,
        "total_tokens": 1417
      },
      "function_count": 5,
      "functions": [
        "atlas-docs-get_docs_index",
        "atlas-docs-get_docs_full",
        "atlas-docs-list_docs",
        "atlas-docs-get_docs_page",
        "atlas-docs-search_docs"
      ]
    },
    "MLB Stats Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all 46 tools provided by the MLB Stats Server, there is no evidence of stateful behavior. All available functions are read-only data retrieval or analytical operations that do not create, modify, or delete any persistent server-side state. Each function operates independently and does not rely on prior function calls to succeed. For example:\n\n- Functions like `get_player_stats`, `get_schedule`, `get_boxscore`, and `get_standings` retrieve data based solely on input parameters (e.g., player_id, game_id, date) without requiring any session setup or configuration.\n- Statcast data tools (`get_statcast_data`, `get_statcast_batter_data`, etc.) pull data from external sources using query parameters only.\n- Player lookup tools (`lookup_player`, `get_playerid_lookup`) return information based purely on name or ID inputs.\n- Visualization tools (`create_strike_zone_plot`, `create_spraychart_plot`, etc.) operate client-side on provided data frames and do not store or depend on server-side state.\n\nThere are no apparent functions for creating, updating, or deleting data (e.g., no \"set_\", \"update_\", \"create_\", or \"save_\" prefixed tools), which would indicate state modification. Furthermore, no function requires a token, session ID, or context established by a prior call. All dependencies are explicit in the form of required parameters, and no implicit shared state (such as configurations, sessions, or caches modified across calls) is evident.\n\nWhile it's theoretically possible that some internal caching or session tracking exists for performance, there is no observable API-level statefulness—each function call is self-contained and idempotent.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 12287,
        "completion_tokens": 360,
        "total_tokens": 12647
      },
      "function_count": 46,
      "functions": [
        "mlb-stats-server-get_league_leader_data",
        "mlb-stats-server-get_statcast_data",
        "mlb-stats-server-get_statcast_pitcher_percentile_ranks",
        "mlb-stats-server-create_strike_zone_plot",
        "mlb-stats-server-get_statcast_batter_exitvelo_barrels",
        "mlb-stats-server-get_player_splits",
        "mlb-stats-server-get_schedule",
        "mlb-stats-server-get_statcast_batter_data",
        "mlb-stats-server-get_team_roster",
        "mlb-stats-server-reverse_lookup_player",
        "mlb-stats-server-get_pitching_stats_range",
        "mlb-stats-server-get_pitching_stats_bref",
        "mlb-stats-server-get_notes",
        "mlb-stats-server-get_team_pitching",
        "mlb-stats-server-get_team_leaders",
        "mlb-stats-server-get_statcast_batter_pitch_arsenal",
        "mlb-stats-server-lookup_player",
        "mlb-stats-server-get_team_fielding",
        "mlb-stats-server-get_game_pace",
        "mlb-stats-server-get_boxscore",
        "mlb-stats-server-get_statcast_batter_percentile_ranks",
        "mlb-stats-server-get_linescore",
        "mlb-stats-server-get_statcast_pitcher_expected_stats",
        "mlb-stats-server-get_schedule_and_record",
        "mlb-stats-server-get_standings",
        "mlb-stats-server-get_game_highlight_data",
        "mlb-stats-server-get_pitching_stats",
        "mlb-stats-server-get_statcast_single_game",
        "mlb-stats-server-get_meta",
        "mlb-stats-server-get_pybaseball_standings",
        "mlb-stats-server-get_statcast_pitcher_data",
        "mlb-stats-server-get_top_prospects",
        "mlb-stats-server-get_team_batting",
        "mlb-stats-server-get_player_stats",
        "mlb-stats-server-get_statcast_pitcher_exitvelo_barrels",
        "mlb-stats-server-create_spraychart_plot",
        "mlb-stats-server-create_teams_plot",
        "mlb-stats-server-create_bb_profile_plot",
        "mlb-stats-server-get_last_game",
        "mlb-stats-server-get_next_game",
        "mlb-stats-server-get_stats",
        "mlb-stats-server-get_playerid_lookup",
        "mlb-stats-server-get_statcast_batter_expected_stats",
        "mlb-stats-server-get_statcast_pitcher_pitch_arsenal",
        "mlb-stats-server-get_available_endpoints",
        "mlb-stats-server-get_game_scoring_play_data"
      ]
    },
    "Desktop Commander": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Desktop Commander MCP server exhibits clear stateful behavior through multiple function interactions that involve persistent state modifications and dependencies. Several functions modify system state—such as file contents, directory structures, process execution states, and command blocking rules—and other functions depend on these changes. For example, writing to a file with `write_file` affects the output of subsequent `read_file` calls; executing a command creates a running session (with an associated PID), which must be referenced by `read_output`, `force_terminate`, or `list_sessions`. Similarly, blocking a command alters the behavior of future `execute_command` attempts. These cross-function dependencies on shared, mutable state confirm that the server maintains and relies on state across multiple invocations.",
      "state_dependencies": [
        {
          "function_a": "execute_command",
          "function_b": "read_output",
          "state_description": "Executing a command starts a terminal session with a specific PID; read_output depends on this PID to retrieve ongoing output from the same session."
        },
        {
          "function_a": "execute_command",
          "function_b": "force_terminate",
          "state_description": "The PID returned by execute_command identifies a running session that can be terminated using force_terminate."
        },
        {
          "function_a": "execute_command",
          "function_b": "list_sessions",
          "state_description": "Calling execute_command adds an entry to the list of active terminal sessions, which is retrievable via list_sessions."
        },
        {
          "function_a": "write_file",
          "function_b": "read_file",
          "state_description": "Writing content to a file with write_file changes the content that will be returned when read_file is called on the same path."
        },
        {
          "function_a": "write_file",
          "function_b": "edit_block",
          "state_description": "The edit_block function modifies parts of a file based on its current content, which may have been previously set by write_file."
        },
        {
          "function_a": "create_directory",
          "function_b": "list_directory",
          "state_description": "Creating a directory with create_directory affects the listing returned by list_directory when called on the parent or same path."
        },
        {
          "function_a": "create_directory",
          "function_b": "write_file",
          "state_description": "A directory must exist (possibly created via create_directory) before write_file can successfully write a file into it."
        },
        {
          "function_a": "move_file",
          "function_b": "read_file",
          "state_description": "After moving a file with move_file, the new location contains the file, affecting where read_file can access it."
        },
        {
          "function_a": "block_command",
          "function_b": "execute_command",
          "state_description": "Blocking a command via block_command prevents execute_command from running that command until it is unblocked."
        },
        {
          "function_a": "block_command",
          "function_b": "list_blocked_commands",
          "state_description": "Commands added via block_command appear in the list returned by list_blocked_commands."
        },
        {
          "function_a": "list_processes",
          "function_b": "kill_process",
          "state_description": "The list_processes function reveals PIDs of running processes, which are required inputs for kill_process to terminate them."
        }
      ],
      "token_usage": {
        "prompt_tokens": 2707,
        "completion_tokens": 722,
        "total_tokens": 3429
      },
      "function_count": 20,
      "functions": [
        "desktop-commander-search_files",
        "desktop-commander-move_file",
        "desktop-commander-search_code",
        "desktop-commander-list_allowed_directories",
        "desktop-commander-read_multiple_files",
        "desktop-commander-get_file_info",
        "desktop-commander-list_directory",
        "desktop-commander-read_file",
        "desktop-commander-create_directory",
        "desktop-commander-force_terminate",
        "desktop-commander-block_command",
        "desktop-commander-list_sessions",
        "desktop-commander-edit_block",
        "desktop-commander-execute_command",
        "desktop-commander-read_output",
        "desktop-commander-unblock_command",
        "desktop-commander-kill_process",
        "desktop-commander-write_file",
        "desktop-commander-list_processes",
        "desktop-commander-list_blocked_commands"
      ]
    },
    "MySQL MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MySQL MCP Server exhibits stateful behavior because several functions depend on a shared connection state that must be established before database operations can occur. Specifically, the `connect_database` function establishes a persistent session or connection context (e.g., authentication, active socket, session variables) that subsequent functions like `execute_query`, `show_tables`, and `describe_table` rely on to perform their operations. Without a successful call to `connect_database`, these read operations cannot access the database. Furthermore, `disconnect_database` explicitly terminates this shared state, reinforcing that the server maintains state across multiple function calls. Although no data modifications are allowed (read-only), the presence of setup-dependent execution flow confirms statefulness.",
      "state_dependencies": [
        {
          "function_a": "connect_database",
          "function_b": "execute_query",
          "state_description": "Database connection established by connect_database is required for execute_query to run SQL queries"
        },
        {
          "function_a": "connect_database",
          "function_b": "show_tables",
          "state_description": "Database connection established by connect_database is required for show_tables to list tables in the database"
        },
        {
          "function_a": "connect_database",
          "function_b": "describe_table",
          "state_description": "Database connection established by connect_database is required for describe_table to retrieve table schema information"
        },
        {
          "function_a": "connect_database",
          "function_b": "disconnect_database",
          "state_description": "disconnect_database operates on the existing connection created by connect_database; calling it without an active connection may have no effect or cause an error"
        }
      ],
      "token_usage": {
        "prompt_tokens": 909,
        "completion_tokens": 355,
        "total_tokens": 1264
      },
      "function_count": 5,
      "functions": [
        "mysql-mcp-server-show_tables",
        "mysql-mcp-server-execute_query",
        "mysql-mcp-server-connect_database",
        "mysql-mcp-server-disconnect_database",
        "mysql-mcp-server-describe_table"
      ]
    },
    "Weather Information Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The Weather Information Server provides read-only access to weather data through its available tools. None of the functions (ping, health_check, get_weather, compare_weather) perform operations that modify persistent state such as creating, updating, or deleting data. All function calls are independent and do not rely on prior interactions. There is no indication of session management, configuration changes, or stored context between calls. Each function retrieves real-time weather data based solely on input parameters without depending on side effects from other function invocations. Therefore, there is no evidence of stateful behavior in this MCP server.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 808,
        "completion_tokens": 142,
        "total_tokens": 950
      },
      "function_count": 11,
      "functions": [
        "weather-information-server-get_weather",
        "weather-information-server-get_live_temp",
        "weather-information-server-compare_weather",
        "weather-information-server-get_live_temp",
        "weather-information-server-get_weather_forecast_tool",
        "weather-information-server-ping",
        "weather-information-server-health_check",
        "weather-information-server-get_weather",
        "weather-information-server-search_locations_tool",
        "weather-information-server-get_current_weather_tool",
        "weather-information-server-get_weather"
      ]
    },
    "TusClasesParticulares Automation Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior due to the presence of authentication-dependent operations, shared session context, and interdependencies between functions that modify system state (e.g., login, sending messages, purchasing leads) and those that require such state to function properly. Multiple tools either depend on an active session or alter user-accessible data that subsequent functions rely on. For example:\n\n- Several tools (`tusclasesparticulares_navigate_messaging`, `tusclasesparticulares_send_message`, `tusclasesparticulares_buy_lead`, etc.) perform actions within the context of a logged-in user. While some include `autoLogin` parameters, the explicit `tusclasesparticulares_login` tool with a `keepSession` option indicates that maintaining a persistent session is both possible and intended.\n- Actions like `tusclasesparticulares_create_publication` and `tusclasesparticulares_edit_publication` modify server-side user content, which can later be retrieved via `tusclasesparticulares_get_publications`. This creates a write-read dependency chain.\n- Similarly, purchasing a lead modifies available leads and may initiate a conversation, which would then appear in `tusclasesparticulares_get_conversations` or affect messaging capabilities.\n- The use of indices (e.g., `conversationIndex`, `publicationIndex`, `leadIndex`) across multiple functions implies reliance on dynamically generated, session-consistent state that must persist across calls for correct operation.\n\nThese patterns confirm that the server maintains state across function calls, including authentication sessions and user-generated content visibility.",
      "state_dependencies": [
        {
          "function_a": "tusclasesparticulares_login",
          "function_b": "tusclasesparticulares_navigate_messaging",
          "state_description": "Authentication session established by login is used to access messaging; autoLogin may bypass but does not eliminate dependency on session state."
        },
        {
          "function_a": "tusclasesparticulares_login",
          "function_b": "tusclasesparticulares_send_message",
          "state_description": "Sending a message requires being logged in; the session from login enables authenticated message sending."
        },
        {
          "function_a": "tusclasesparticulares_create_publication",
          "function_b": "tusclasesparticulares_get_publications",
          "state_description": "Creating a publication modifies the list of publications, which will be reflected when retrieving publications."
        },
        {
          "function_a": "tusclasesparticulares_buy_lead",
          "function_b": "tusclasesparticulares_get_conversations",
          "state_description": "Purchasing a lead initiates a conversation thread, making it appear in the list of active conversations."
        },
        {
          "function_a": "tusclasesparticulares_send_message",
          "function_b": "tusclasesparticulares_extract_contact_info",
          "state_description": "Messages sent or received populate conversation content, which can later be parsed for contact information extraction."
        },
        {
          "function_a": "tusclasesparticulares_get_leads",
          "function_b": "tusclasesparticulares_buy_lead",
          "state_description": "The list of available leads retrieved influences which lead index can be purchased in a subsequent buy_lead call."
        }
      ],
      "token_usage": {
        "prompt_tokens": 2390,
        "completion_tokens": 728,
        "total_tokens": 3118
      },
      "function_count": 14,
      "functions": [
        "tusclasesparticulares-automation-server-tusclasesparticulares_get_leads",
        "tusclasesparticulares-automation-server-tusclasesparticulares_create_publication",
        "tusclasesparticulares-automation-server-tusclasesparticulares_screenshot",
        "tusclasesparticulares-automation-server-tusclasesparticulares_send_message",
        "tusclasesparticulares-automation-server-tusclasesparticulares_extract_contact_info",
        "tusclasesparticulares-automation-server-tusclasesparticulares_edit_publication",
        "tusclasesparticulares-automation-server-tusclasesparticulares_buy_lead",
        "tusclasesparticulares-automation-server-tusclasesparticulares_get_publications",
        "tusclasesparticulares-automation-server-tusclasesparticulares_navigate_messaging",
        "tusclasesparticulares-automation-server-tusclasesparticulares_bulk_operations",
        "tusclasesparticulares-automation-server-tusclasesparticulares_advanced_filtering",
        "tusclasesparticulares-automation-server-tusclasesparticulares_get_conversations",
        "tusclasesparticulares-automation-server-tusclasesparticulares_handle_subscription_limits",
        "tusclasesparticulares-automation-server-tusclasesparticulares_login"
      ]
    },
    "Windows Command Line MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "After analyzing all available tools in the Windows Command Line MCP Server, there is no evidence of functions that modify persistent system state in a way that affects the behavior of other functions. All provided tools are primarily read-only or execute transient operations:\n\n- Tools like `list_running_processes`, `get_system_info`, `get_network_info`, `get_scheduled_tasks`, and `get_service_info` retrieve system state but do not alter it.\n- The `execute_command` and `execute_powershell` tools can run arbitrary commands or scripts, which *in theory* could modify system state (e.g., create files, change configurations). However, **these tools do not expose any mechanism to persist or share state with other tool calls directly through the MCP interface**, nor is there any indication that their execution alters internal server state that influences subsequent tool behavior.\n- There is no explicit \"set\" or \"configure\" function that establishes context (like setting a session, changing default parameters, or storing data for later retrieval via other tools).\n- No tool requires prior invocation of another tool to function correctly (e.g., no need to call `execute_command` before using `get_service_info`).\n- The `list_allowed_commands` tool is purely informational and does not influence or depend on runtime state.\n\nWhile `execute_command` and `execute_powershell` have the potential to affect the underlying operating system (e.g., modifying services, tasks, or network settings), such changes would be external OS-level modifications, not shared context within the MCP server itself. Since the MCP specification focuses on **server-side state shared across tool calls** (not side effects on the host OS), and no tool explicitly depends on state set by another via the protocol, the server behaves statelessly from an MCP perspective.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1545,
        "completion_tokens": 383,
        "total_tokens": 1928
      },
      "function_count": 8,
      "functions": [
        "windows-command-line-mcp-server-get_system_info",
        "windows-command-line-mcp-server-get_scheduled_tasks",
        "windows-command-line-mcp-server-execute_powershell",
        "windows-command-line-mcp-server-execute_command",
        "windows-command-line-mcp-server-get_service_info",
        "windows-command-line-mcp-server-list_running_processes",
        "windows-command-line-mcp-server-list_allowed_commands",
        "windows-command-line-mcp-server-get_network_info"
      ]
    },
    "Crypto Research Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Crypto Research Server are read-only operations that retrieve data based on input parameters. None of the functions perform create, update, delete, or any kind of state-modifying operation. Each function operates independently and does not rely on prior calls to set up context, configurations, sessions, or stored data. For example, `research_get_project_by_twitter` retrieves project details solely based on the provided Twitter username, and `research_search_reports` returns reports based only on the given keyword and optional filters—no shared mutable state is involved. There is no evidence of functions setting configurations, establishing sessions, or storing data that would affect subsequent function behavior. Therefore, the server exhibits stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1311,
        "completion_tokens": 167,
        "total_tokens": 1478
      },
      "function_count": 5,
      "functions": [
        "crypto-research-server-research_get_project_reports_by_twitter",
        "crypto-research-server-research_search_reports",
        "crypto-research-server-research_get_project_by_twitter",
        "crypto-research-server-research_search_news",
        "crypto-research-server-research_get_projects"
      ]
    },
    "AI Research Assistant - Semantic Scholar": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The provided MCP server tools for \"AI Research Assistant - Semantic Scholar\" are entirely read-only and do not include any functions that create, modify, or delete persistent state on the server. All available tools are query-based (e.g., searching papers, retrieving citations, fetching author information) and operate independently of one another. There is no evidence of:  \n- Functions that establish sessions, configurations, or mutable context (e.g., login, set_preference, create_cache).  \n- Any function requiring prior execution of another function to succeed (e.g., no tool requires a token, session ID, or result handle generated by another).  \n- Shared mutable state such as cached queries, user-specific filters, or temporary data stores that persist across calls.  \n\nEach function takes explicit identifiers (e.g., paperId, authorId, title) or search parameters and returns results based solely on those inputs, with no indication of internal state being altered or relied upon across calls. While some tools may conceptually relate (e.g., using `papers-search-basic` to find a paper and then `papers-get` to retrieve its details), this represents a client-side workflow, not server-enforced statefulness. The server does not retain any context from one call to influence the next.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2405,
        "completion_tokens": 279,
        "total_tokens": 2684
      },
      "function_count": 10,
      "functions": [
        "ai-research-assistant---semantic-scholar-papers-references",
        "ai-research-assistant---semantic-scholar-analysis-citation-network",
        "ai-research-assistant---semantic-scholar-papers-match",
        "ai-research-assistant---semantic-scholar-papers-citations",
        "ai-research-assistant---semantic-scholar-authors-papers",
        "ai-research-assistant---semantic-scholar-papers-batch",
        "ai-research-assistant---semantic-scholar-authors-search",
        "ai-research-assistant---semantic-scholar-papers-get",
        "ai-research-assistant---semantic-scholar-papers-search-advanced",
        "ai-research-assistant---semantic-scholar-papers-search-basic"
      ]
    },
    "WildFly MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The WildFly MCP Server provides functions that modify persistent server state (e.g., logging configuration) and other functions that retrieve or depend on the current state of the server, deployments, or logs. Specifically, `enableWildFlyLoggingCategory` modifies the server's runtime configuration by enabling a logging category, which persists until removed. This change directly affects the behavior and output of subsequent operations such as `getWildFlyLogFileContent`, which may now include additional log entries from the newly enabled category. Similarly, `removeWildFlyLoggingCategory` reverses this state change, indicating a clear mutative effect on server state.\n\nAdditionally, several tools like `getDeploymentFileContent`, `getDeploymentFilePaths`, and `getWildFlyServerAndDeploymentsStatus` are read operations that depend on the current deployment and server state, which could be altered via external or internal management operations (including `invokeWildFlyCLIOperation`). While most tools are read-only, the presence of at least one write operation (`enableWildFlyLoggingCategory`) that affects future reads establishes statefulness.\n\nThe shared context—such as host, port, and server-side configuration—persists across calls, and multiple tools accept these parameters to target specific server instances, further suggesting a session-like interaction model where prior mutations influence later queries.",
      "state_dependencies": [
        {
          "function_a": "enableWildFlyLoggingCategory",
          "function_b": "getWildFlyLogFileContent",
          "state_description": "Enabling a logging category increases the verbosity of logs; subsequent log retrieval will include messages from that category if it was enabled."
        },
        {
          "function_a": "enableWildFlyLoggingCategory",
          "function_b": "removeWildFlyLoggingCategory",
          "state_description": "The removal operation can only affect a logging category that was previously added or enabled, implying shared state about currently active logging categories."
        },
        {
          "function_a": "invokeWildFlyCLIOperation",
          "function_b": "getWildFlyServerAndDeploymentsStatus",
          "state_description": "CLI operations can change server or deployment state (e.g., deploy/undeploy), which would be reflected in the status query results."
        },
        {
          "function_a": "invokeWildFlyCLIOperation",
          "function_b": "getDeploymentFilePaths",
          "state_description": "A CLI command that deploys an application modifies the set of available deployments, affecting the paths returned by getDeploymentFilePaths."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1289,
        "completion_tokens": 529,
        "total_tokens": 1818
      },
      "function_count": 10,
      "functions": [
        "wildfly-mcp-server-getDeploymentFileContent",
        "wildfly-mcp-server-getWildFlyServerAndDeploymentsStatus",
        "wildfly-mcp-server-invokeWildFlyCLIOperation",
        "wildfly-mcp-server-getDeploymentFilePaths",
        "wildfly-mcp-server-getWildFlyLogFileContent",
        "wildfly-mcp-server-getWildFlyServerAndJVMInfo",
        "wildfly-mcp-server-getWildFlyServerConfiguration",
        "wildfly-mcp-server-enableWildFlyLoggingCategory",
        "wildfly-mcp-server-removeWildFlyLoggingCategory",
        "wildfly-mcp-server-getWildFlyPrometheusMetrics"
      ]
    },
    "Python-to-TypeScript Porting": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior through its notebook and ephemeral journal management tools. Several functions create or modify persistent state (e.g., creating notebooks or journals), while others depend on that state to function correctly. For example, `create-porting-notebook` generates a notebook at a specific path, which is later required by `add-porting-step` and `execute-notebook-cell` to operate on the same notebook. Similarly, ephemeral journals are created with `create-ephemeral-journal`, assigned an ID, and then used in subsequent calls like `add-journal-entry`, `get-journal-content`, and `save-journal-snapshot`. These dependencies indicate shared mutable state across function calls. Additionally, the existence of `list-ephemeral-journals` implies a runtime registry of active journals, further confirming internal state persistence. The server maintains context (notebooks, journals, entries) that persists across multiple tool invocations within a session.",
      "state_dependencies": [
        {
          "function_a": "create-porting-notebook",
          "function_b": "add-porting-step",
          "state_description": "The notebook file created by create-porting-notebook is referenced via its path in add-porting-step to append new porting steps."
        },
        {
          "function_a": "add-porting-step",
          "function_b": "execute-notebook-cell",
          "state_description": "Cells added via add-porting-step are executed later using execute-notebook-cell, which depends on the cell existing in the notebook."
        },
        {
          "function_a": "create-ephemeral-journal",
          "function_b": "add-journal-entry",
          "state_description": "An ephemeral journal created by create-ephemeral-journal produces a journalId that must be used by add-journal-entry to target the correct journal."
        },
        {
          "function_a": "create-ephemeral-journal",
          "function_b": "get-journal-content",
          "state_description": "The journalId from create-ephemeral-journal is required by get-journal-content to retrieve the content of the specified journal."
        },
        {
          "function_a": "create-ephemeral-journal",
          "function_b": "save-journal-snapshot",
          "state_description": "The journalId generated during journal creation is needed by save-journal-snapshot to persist the ephemeral journal as a permanent notebook."
        },
        {
          "function_a": "add-journal-entry",
          "function_b": "get-journal-content",
          "state_description": "Entries added via add-journal-entry modify the journal's content, which is then retrieved when calling get-journal-content."
        }
      ],
      "token_usage": {
        "prompt_tokens": 3627,
        "completion_tokens": 587,
        "total_tokens": 4214
      },
      "function_count": 13,
      "functions": [
        "python-to-typescript-porting-validation-strategy",
        "python-to-typescript-porting-get-journal-content",
        "python-to-typescript-porting-porting-strategy",
        "python-to-typescript-porting-create-ephemeral-journal",
        "python-to-typescript-porting-save-journal-snapshot",
        "python-to-typescript-porting-execute-notebook-cell",
        "python-to-typescript-porting-type-analysis",
        "python-to-typescript-porting-library-mapping",
        "python-to-typescript-porting-add-journal-entry",
        "python-to-typescript-porting-create-porting-notebook",
        "python-to-typescript-porting-list-ephemeral-journals",
        "python-to-typescript-porting-add-porting-step",
        "python-to-typescript-porting-pattern-mapping"
      ]
    },
    "Academic Author Network": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Both available functions, `get_coauthors` and `get_author_keywords`, are read-only operations that retrieve data based on input parameters (name, surname, optional institution, and field). There is no indication in the function descriptions, parameters, or return values that either function modifies any persistent state (e.g., creating sessions, storing data, setting configurations, or updating author records). All inputs required for functionality are provided explicitly in each function call, with no reliance on prior calls to establish context. Furthermore, there is no shared mutable state evident between the tools—each appears to operate independently by querying external academic APIs (e.g., Google Scholar) using self-contained arguments. Without any write, create, update, or delete operations, and without evidence of cross-function context persistence, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 942,
        "completion_tokens": 187,
        "total_tokens": 1129
      },
      "function_count": 2,
      "functions": [
        "academic-author-network-get_coauthors",
        "academic-author-network-get_author_keywords"
      ]
    },
    "shadcn/ui Component Reference Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The shadcn/ui Component Reference Server provides read-only access to documentation, examples, and component metadata. All available tools—`list_shadcn_components`, `get_component_details`, `get_component_examples`, and `search_components`—are idempotent and do not modify any system state. They retrieve static or pre-defined information about UI components without creating, updating, or deleting data. There is no indication of session management, configuration changes, or persistent storage modifications. Each function operates independently and does not rely on prior function calls to succeed. For example, calling `get_component_details` with a valid component name will always return the same result regardless of whether `list_shadcn_components` was called beforehand. Similarly, searching for components by keyword does not alter the server’s behavior for subsequent requests. Therefore, there are no stateful dependencies between functions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 785,
        "completion_tokens": 198,
        "total_tokens": 983
      },
      "function_count": 4,
      "functions": [
        "shadcn/ui-component-reference-server-get_component_examples",
        "shadcn/ui-component-reference-server-get_component_details",
        "shadcn/ui-component-reference-server-search_components",
        "shadcn/ui-component-reference-server-list_shadcn_components"
      ]
    },
    "Pulse CN MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Pulse CN MCP Server are read-only functions that retrieve real-time data from external sources via API calls. None of the functions perform create, update, or delete operations that would modify persistent state on the server. Each function operates independently, with no indication of shared context, sessions, configurations, or internal state that persists or evolves across calls. For example, calling `get-weibo-hotspots` does not affect the behavior or output of `douyin-hotspots` or any other tool. Parameters are limited to filtering or limiting results (e.g., `limit`, `time`, `type`, `random`) and do not alter server-side state. The descriptions consistently emphasize \"real-time\" data retrieval \"through API,\" suggesting stateless, idempotent queries rather than interactions with a mutable internal state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2179,
        "completion_tokens": 193,
        "total_tokens": 2372
      },
      "function_count": 18,
      "functions": [
        "pulse-cn-mcp-server-insect-hotspots",
        "pulse-cn-mcp-server-douban-group-hotspots",
        "pulse-cn-mcp-server-zhihu-daily-hotspots",
        "pulse-cn-mcp-server-douyin-hotspots",
        "pulse-cn-mcp-server-the-paper-news-hotspots",
        "pulse-cn-mcp-server-get-realtime-horoscope",
        "pulse-cn-mcp-server-zhihu-realtime-hotspots",
        "pulse-cn-mcp-server-today-headlines-hotspots",
        "pulse-cn-mcp-server-get-weibo-hotspots",
        "pulse-cn-mcp-server-in-information-hotspots",
        "pulse-cn-mcp-server-36-krypton-24-hour-hotspots",
        "pulse-cn-mcp-server-huxiu-hotspots",
        "pulse-cn-mcp-server-internet-hotspots-aggregator",
        "pulse-cn-mcp-server-get-inspirational-english-sentence",
        "pulse-cn-mcp-server-baidu-hotspots",
        "pulse-cn-mcp-server-hupu-pedestrian-street-hotspots",
        "pulse-cn-mcp-server-bilibili-daily-hotspots",
        "pulse-cn-mcp-server-product-manager-hotspots"
      ]
    },
    "Memory Bank": {
      "is_stateful": true,
      "confidence": 0.98,
      "reasoning": "The MCP server exhibits strong stateful behavior, as multiple functions modify persistent state (e.g., writing files, updating context, initializing memory), and other functions depend on that state to operate correctly. For example, `write_memory_bank_file` creates or updates a file in the Memory Bank, and `read_memory_bank_file` retrieves content from that same file—its output directly depends on prior writes. Similarly, `initialize_memory_bank` sets up the foundational directory structure, which is required for most other operations (like reading, writing, listing files) to succeed. Without initialization, these operations would fail or return empty results. Additionally, `set_memory_bank_path` modifies the active path used by all subsequent file operations, meaning tools like `read_memory_bank_file`, `write_memory_bank_file`, and `list_memory_bank_files` rely on this configured path. Functions such as `track_progress`, `update_active_context`, and `log_decision` also mutate shared state that influences later reads or processing via `read_memory_bank_file` or debugging tools. This clear pattern of state mutation and dependency confirms the server is stateful.",
      "state_dependencies": [
        {
          "function_a": "initialize_memory_bank",
          "function_b": "read_memory_bank_file",
          "state_description": "Initializes the Memory Bank directory; required for file read operations to have a valid location to retrieve files from."
        },
        {
          "function_a": "initialize_memory_bank",
          "function_b": "write_memory_bank_file",
          "state_description": "Sets up the Memory Bank storage location; write operations depend on this initialized path to store data."
        },
        {
          "function_a": "set_memory_bank_path",
          "function_b": "write_memory_bank_file",
          "state_description": "Changes the target directory for the Memory Bank; write operations use this updated path instead of the default."
        },
        {
          "function_a": "set_memory_bank_path",
          "function_b": "read_memory_bank_file",
          "state_description": "Updates the base path for the Memory Bank; read operations will look in this modified location for files."
        },
        {
          "function_a": "write_memory_bank_file",
          "function_b": "read_memory_bank_file",
          "state_description": "Writes content to a file; subsequent reads of the same filename return the written content, showing direct state dependency."
        },
        {
          "function_a": "write_memory_bank_file",
          "function_b": "list_memory_bank_files",
          "state_description": "Adding a new file affects the list of files returned by list_memory_bank_files, indicating state persistence across calls."
        },
        {
          "function_a": "track_progress",
          "function_b": "read_memory_bank_file",
          "state_description": "Updates progress in Memory Bank files; these changes are reflected when reading the corresponding files later."
        },
        {
          "function_a": "update_active_context",
          "function_b": "read_memory_bank_file",
          "state_description": "Modifies the active context file; the updated content can be retrieved through reading the file afterward."
        },
        {
          "function_a": "log_decision",
          "function_b": "read_memory_bank_file",
          "state_description": "Appends or creates a decision log entry in persistent storage; the logged data becomes accessible via file read operations."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1844,
        "completion_tokens": 716,
        "total_tokens": 2560
      },
      "function_count": 15,
      "functions": [
        "memory-bank-read_memory_bank_file",
        "memory-bank-list_memory_bank_files",
        "memory-bank-process_umb_command",
        "memory-bank-set_memory_bank_path",
        "memory-bank-migrate_file_naming",
        "memory-bank-get_memory_bank_status",
        "memory-bank-log_decision",
        "memory-bank-switch_mode",
        "memory-bank-write_memory_bank_file",
        "memory-bank-debug_mcp_config",
        "memory-bank-initialize_memory_bank",
        "memory-bank-track_progress",
        "memory-bank-complete_umb",
        "memory-bank-get_current_mode",
        "memory-bank-update_active_context"
      ]
    },
    "Weather": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The provided MCP server for Weather offers two functions: `get_alerts` and `get_forecast`. Both functions are read-only operations that retrieve weather data based on explicit input parameters (a state code for `get_alerts`, and latitude/longitude for `get_forecast`). There is no indication that either function modifies any persistent system state such as configurations, sessions, stored data, or context. Neither function relies on side effects from the other, nor do they share mutable state across calls. Each function operates independently using only the arguments provided in the request. There are no create, update, or delete operations present, and no mechanism for one call to influence the behavior or output of another. Therefore, the server behaves in a purely stateless manner.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 688,
        "completion_tokens": 177,
        "total_tokens": 865
      },
      "function_count": 6,
      "functions": [
        "weather-get_forecast",
        "weather-get_alerts",
        "weather-get-alerts",
        "weather-get-forecast",
        "weather-get_alerts",
        "weather-get_forecast"
      ]
    },
    "PubMed Enhanced Search Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the PubMed Enhanced Search Server are read-only operations that query external data sources (primarily PubMed and MeSH databases) without modifying any persistent state on the server. None of the functions perform create, update, or delete operations. Each function operates independently, accepting all necessary input parameters explicitly and returning results based solely on those inputs. There is no indication of shared context, session management, stored configurations, or side effects that would affect subsequent calls. For example:\n- `search_pubmed` performs a keyword search using provided parameters and returns results.\n- `get_mesh_terms` queries standardized terminology based solely on the input search word.\n- `get_pubmed_count` returns counts for given search terms without storing them.\n- `format_paper_details` retrieves article details by explicitly provided PubMed IDs.\n- `pico_search` generates search queries and counts from provided PICO elements.\n\nNo function requires or depends on the outcome of a prior function call to operate correctly, and no internal state is exposed or maintained between calls. While users may *logically* chain functions (e.g., use MeSH terms to improve a PubMed search), this workflow dependency is client-managed and does not imply server-side statefulness.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1773,
        "completion_tokens": 270,
        "total_tokens": 2043
      },
      "function_count": 5,
      "functions": [
        "pubmed-enhanced-search-server-pico_search",
        "pubmed-enhanced-search-server-search_pubmed",
        "pubmed-enhanced-search-server-get_pubmed_count",
        "pubmed-enhanced-search-server-get_mesh_terms",
        "pubmed-enhanced-search-server-format_paper_details"
      ]
    },
    "Weather Forecast Server with AI Assistant": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The provided tools in the \"Weather Forecast Server with AI Assistant\" do not exhibit any clear indications of modifying or relying on persistent state across function calls. All functions appear to be stateless and idempotent:\n\n- `get_weather_by_coordinates`, `get_weather_by_city`, and `get_weather` are pure data retrieval functions that take input parameters (coordinates, city name) and return weather data without side effects.\n- `chat_weather_assistant` appears to process user messages and may internally extract context such as location, but there is no evidence that this context is stored persistently or affects subsequent calls to other functions unless explicitly passed within the message each time.\n- `weather_greeting` is a simple greeting function with no inputs and likely returns a static or templated response.\n\nThere is no indication of:\n- Session creation or management\n- Configuration settings being modified\n- Data storage or caching that influences future calls\n- Any function requiring prior execution of another to succeed\n\nEven though `chat_weather_assistant` might maintain conversational context (e.g., remembering a previously mentioned city), unless this context is shared globally or persists outside the scope of a single call (and based on the tool description, it does not seem to affect other tools), it would fall under local ephemeral context rather than server-wide state.\n\nThus, there is no cross-function state dependency that would classify the MCP server as stateful.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1336,
        "completion_tokens": 308,
        "total_tokens": 1644
      },
      "function_count": 5,
      "functions": [
        "weather-forecast-server-with-ai-assistant-get_weather",
        "weather-forecast-server-with-ai-assistant-weather_greeting",
        "weather-forecast-server-with-ai-assistant-get_weather_by_city",
        "weather-forecast-server-with-ai-assistant-chat_weather_assistant",
        "weather-forecast-server-with-ai-assistant-get_weather_by_coordinates"
      ]
    },
    "Current Forest Fire Status in Korea": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "After analyzing all available functions in the MCP server \"Current Forest Fire Status in Korea\", there is no evidence of state-modifying operations (e.g., create, update, delete) or shared persistent state between function calls. All provided functions appear to be read-only and idempotent: they retrieve data from external sources (e.g., forest fire status, evacuation shelters, Google search) without altering any internal system state.  \n\n- `get_forest_fire_info`, `get_formatted_fire_info`, and `get_comprehensive_fire_info` retrieve real-time or formatted fire data but do not indicate side effects or configuration changes.  \n- `find_evacuation_shelters` and `search_google` are query-based tools that fetch results based on input parameters without implying session creation or state persistence.  \n- `get_comprehensive_fire_info` may combine fire data with shelter information, but it does so based solely on its input (`location`) rather than relying on prior function calls. There's no indication that calling another function first alters its behavior.  \n\nNo function requires or depends on a previous call to set up context, configuration, or session. All outputs are determined purely by inputs and external data sources, not internal mutable state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1120,
        "completion_tokens": 270,
        "total_tokens": 1390
      },
      "function_count": 5,
      "functions": [
        "current-forest-fire-status-in-korea-get_formatted_fire_info",
        "current-forest-fire-status-in-korea-search_google",
        "current-forest-fire-status-in-korea-get_forest_fire_info",
        "current-forest-fire-status-in-korea-get_comprehensive_fire_info",
        "current-forest-fire-status-in-korea-find_evacuation_shelters"
      ]
    },
    "App Market Intelligence": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "After analyzing all 20 tools provided by the \"App Market Intelligence\" MCP server, there is no evidence of stateful behavior. All available functions are read-only operations that retrieve data from external sources (Apple App Store and Google Play Store). None of the tools perform create, update, delete, or any kind of mutation operation that would alter internal server state. Each function call operates independently, relying solely on input parameters (such as app IDs, search terms, country codes) to fetch data directly from public APIs. There are no shared sessions, configurations, authentication tokens, or persistent contexts established or used across calls. Furthermore, no function requires prior execution of another function to succeed—each can be called in isolation with appropriate inputs. Since no state is modified or maintained between requests, the server behaves purely as a stateless gateway to third-party app store data.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 8998,
        "completion_tokens": 198,
        "total_tokens": 9196
      },
      "function_count": 20,
      "functions": [
        "app-market-intelligence-app-store-similar",
        "app-market-intelligence-app-store-version-history",
        "app-market-intelligence-app-store-privacy",
        "app-market-intelligence-app-store-details",
        "app-market-intelligence-app-store-list",
        "app-market-intelligence-google-play-search",
        "app-market-intelligence-app-store-reviews",
        "app-market-intelligence-app-store-suggest",
        "app-market-intelligence-google-play-permissions",
        "app-market-intelligence-app-store-search",
        "app-market-intelligence-google-play-developer",
        "app-market-intelligence-google-play-reviews",
        "app-market-intelligence-google-play-details",
        "app-market-intelligence-google-play-list",
        "app-market-intelligence-google-play-categories",
        "app-market-intelligence-app-store-ratings",
        "app-market-intelligence-google-play-suggest",
        "app-market-intelligence-google-play-datasafety",
        "app-market-intelligence-app-store-developer",
        "app-market-intelligence-google-play-similar"
      ]
    },
    "MediaWiki": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior due to the presence of functions that modify persistent or session-scoped state, which subsequently affects the behavior of other functions. Specifically, the `set-wiki` function establishes the target wiki for all subsequent operations in the session by setting a configuration context (the current wiki URL). Without this prior call, other functions like `get-page`, `update-page`, `create-page`, etc., would not know which wiki instance to interact with. This creates a dependency where multiple read and write operations rely on the state established by `set-wiki`. Additionally, content-modifying functions such as `create-page` and `update-page` alter the persistent state of the wiki (i.e., page content), which can later be retrieved or influence results from `get-page`, `get-page-history`, or `search-page`, further reinforcing statefulness.",
      "state_dependencies": [
        {
          "function_a": "set-wiki",
          "function_b": "get-page",
          "state_description": "The wiki URL set by set-wiki determines the wiki instance from which get-page retrieves the page."
        },
        {
          "function_a": "set-wiki",
          "function_b": "get-page-history",
          "state_description": "The wiki URL set by set-wiki determines the wiki instance from which get-page-history retrieves revision history."
        },
        {
          "function_a": "set-wiki",
          "function_b": "search-page",
          "state_description": "The wiki URL set by set-wiki determines the wiki instance in which search-page performs its query."
        },
        {
          "function_a": "set-wiki",
          "function_b": "update-page",
          "state_description": "The wiki URL set by set-wiki determines the wiki instance where update-page applies changes."
        },
        {
          "function_a": "set-wiki",
          "function_b": "get-file",
          "state_description": "The wiki URL set by set-wiki determines the wiki instance from which get-file retrieves file information."
        },
        {
          "function_a": "set-wiki",
          "function_b": "create-page",
          "state_description": "The wiki URL set by set-wiki determines the wiki instance where create-page creates the new page."
        },
        {
          "function_a": "create-page",
          "function_b": "get-page",
          "state_description": "The page created by create-page can be retrieved by get-page, indicating that create-page modifies persistent state accessed by get-page."
        },
        {
          "function_a": "update-page",
          "function_b": "get-page-history",
          "state_description": "Edits made by update-page contribute to the revision history returned by get-page-history."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1663,
        "completion_tokens": 594,
        "total_tokens": 2257
      },
      "function_count": 7,
      "functions": [
        "mediawiki-create-page",
        "mediawiki-update-page",
        "mediawiki-search-page",
        "mediawiki-get-page",
        "mediawiki-get-file",
        "mediawiki-set-wiki",
        "mediawiki-get-page-history"
      ]
    },
    "Calculator": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Calculator MCP server provides pure mathematical functions (add, sub, mul, div) that operate solely on their input parameters and do not modify or depend on any external or shared state. Each function performs a deterministic computation based only on the provided arguments (a and b), with no side effects such as storing data, modifying configurations, creating sessions, or updating internal variables that persist across calls. There is no indication of inter-function dependency where one function's invocation alters the behavior or output of another. All operations are stateless and idempotent, meaning repeated calls with the same inputs always produce the same outputs regardless of prior interactions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 820,
        "completion_tokens": 151,
        "total_tokens": 971
      },
      "function_count": 5,
      "functions": [
        "calculator-add",
        "calculator-mul",
        "calculator-div",
        "calculator-sub",
        "calculator-calculate"
      ]
    },
    "ClinicalTrials MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The ClinicalTrials MCP Server exhibits clear stateful behavior due to the presence of functions that write data (specifically CSV files) to persistent storage and other functions that read from those same files. Specifically, multiple tools such as `search_clinical_trials_and_save_studies_to_csv`, `get_full_studies_and_save`, and `get_studies_by_keyword` have side effects that modify the system state by saving CSV files to disk. These saved files represent persistent state that can later be accessed or reloaded by the `load_csv_data` function. Additionally, the `list_saved_csv_files` function allows discovery of the artifacts created by prior function calls, further indicating that the server maintains a shared, mutable state across interactions. The output and success of `load_csv_data` directly depend on whether a prior function has created the file it attempts to load—this inter-function dependency on shared filesystem state confirms statefulness.",
      "state_dependencies": [
        {
          "function_a": "search_clinical_trials_and_save_studies_to_csv",
          "function_b": "load_csv_data",
          "state_description": "Saves a CSV file with search results; load_csv_data depends on this file existing to read its contents"
        },
        {
          "function_a": "get_full_studies_and_save",
          "function_b": "load_csv_data",
          "state_description": "Generates and saves a full studies CSV file; load_csv_data requires this file to be present to display its data"
        },
        {
          "function_a": "get_studies_by_keyword",
          "function_b": "load_csv_data",
          "state_description": "Can save a CSV file when save_csv=True; subsequent loading via load_csv_data depends on this generated file"
        },
        {
          "function_a": "search_clinical_trials_and_save_studies_to_csv",
          "function_b": "list_saved_csv_files",
          "state_description": "Creates a CSV file which appears in the list returned by list_saved_csv_files"
        },
        {
          "function_a": "get_full_studies_and_save",
          "function_b": "list_saved_csv_files",
          "state_description": "Creates a CSV file entry visible when listing saved files"
        },
        {
          "function_a": "get_studies_by_keyword",
          "function_b": "list_saved_csv_files",
          "state_description": "May create a CSV file that becomes part of the listed available files"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1669,
        "completion_tokens": 529,
        "total_tokens": 2198
      },
      "function_count": 7,
      "functions": [
        "clinicaltrials-mcp-server-load_csv_data",
        "clinicaltrials-mcp-server-get_full_studies_and_save",
        "clinicaltrials-mcp-server-list_saved_csv_files",
        "clinicaltrials-mcp-server-get_study_statistics",
        "clinicaltrials-mcp-server-get_studies_by_keyword",
        "clinicaltrials-mcp-server-get_full_study_details",
        "clinicaltrials-mcp-server-search_clinical_trials_and_save_studies_to_csv"
      ]
    },
    "GeekNews Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The two available functions, `get_articles` and `get_weekly_news`, are both read-only operations that retrieve news content from GeekNews. Neither function modifies any system state, creates sessions, stores data, or alters configurations. The `get_articles` function fetches articles based on type and limit, while `get_weekly_news` retrieves a weekly news summary based on an optional ID—both behave as pure retrieval functions with no indication of side effects or persistent state modification. There is no evidence that the output or behavior of one function depends on a prior call to the other. All parameters are explicitly passed, and defaults are self-contained. Therefore, there is no functional dependency on shared mutable state across calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 794,
        "completion_tokens": 169,
        "total_tokens": 963
      },
      "function_count": 2,
      "functions": [
        "geeknews-server-get_articles",
        "geeknews-server-get_weekly_news"
      ]
    },
    "Cloudflare Playwright": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Cloudflare Playwright MCP server exhibits clear stateful behavior, as multiple functions both modify and depend on shared browser session state. The entire toolset operates within the context of a persistent browser session involving navigation history, open tabs, page content, user interactions, and UI state (e.g., dialogs, console messages). For example, navigating to a URL with `browser_navigate` changes the current page context, which affects all subsequent interaction functions like `browser_click`, `browser_type`, or `browser_snapshot`. These functions require an active page context and will fail or behave differently depending on the current state of the browser. Similarly, actions such as opening or closing tabs (`browser_tab_new`, `browser_tab_close`) alter the tab list, which directly impacts `browser_tab_select` and `browser_tab_list`. Functions like `browser_resize` change the viewport dimensions, which can affect layout and visibility for future interactions. Furthermore, `browser_handle_dialog` implies the existence of a dialog state triggered by prior page behavior, and handling it modifies that transient UI state. All interaction tools (`browser_click`, `browser_hover`, `browser_type`, etc.) rely on element references (`ref`) obtained via `browser_snapshot`, establishing a strict dependency where snapshotting must precede safe interaction. This interdependence confirms that the outcome of one function call is influenced by previous calls, indicating a shared, evolving context across invocations.",
      "state_dependencies": [
        {
          "function_a": "browser_navigate",
          "function_b": "browser_snapshot",
          "state_description": "The page content loaded by browser_navigate determines what elements are captured in the accessibility snapshot."
        },
        {
          "function_a": "browser_snapshot",
          "function_b": "browser_click",
          "state_description": "Element references (ref) from browser_snapshot are required to safely perform clicks using browser_click."
        },
        {
          "function_a": "browser_snapshot",
          "function_b": "browser_type",
          "state_description": "Element references (ref) from browser_snapshot are required to type into specific fields using browser_type."
        },
        {
          "function_a": "browser_snapshot",
          "function_b": "browser_select_option",
          "state_description": "Element references (ref) from browser_snapshot are required to select options in dropdowns using browser_select_option."
        },
        {
          "function_a": "browser_tab_new",
          "function_b": "browser_tab_select",
          "state_description": "New tabs created with browser_tab_new increase the number of available tabs, which affects valid indices for browser_tab_select."
        },
        {
          "function_a": "browser_tab_new",
          "function_b": "browser_tab_list",
          "state_description": "Opening new tabs with browser_tab_new changes the list of tabs returned by browser_tab_list."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_navigate_back",
          "state_description": "Navigating forward via browser_navigate adds entries to the navigation history, enabling browser_navigate_back to return to the previous page."
        },
        {
          "function_a": "browser_navigate_back",
          "function_b": "browser_navigate_forward",
          "state_description": "Going back with browser_navigate_back enables going forward again via browser_navigate_forward using the navigation stack."
        },
        {
          "function_a": "browser_resize",
          "function_b": "browser_take_screenshot",
          "state_description": "The browser window size set by browser_resize affects the dimensions and content visible in screenshots taken by browser_take_screenshot."
        },
        {
          "function_a": "browser_press_key",
          "function_b": "browser_console_messages",
          "state_description": "Pressing certain keys may trigger JavaScript that logs messages to the console, which are then retrieved by browser_console_messages."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_network_requests",
          "state_description": "Network requests captured by browser_network_requests are those made after navigating to a page via browser_navigate."
        }
      ],
      "token_usage": {
        "prompt_tokens": 3177,
        "completion_tokens": 866,
        "total_tokens": 4043
      },
      "function_count": 24,
      "functions": [
        "cloudflare-playwright-browser_close",
        "cloudflare-playwright-browser_tab_close",
        "cloudflare-playwright-browser_network_requests",
        "cloudflare-playwright-browser_type",
        "cloudflare-playwright-browser_press_key",
        "cloudflare-playwright-browser_pdf_save",
        "cloudflare-playwright-browser_navigate",
        "cloudflare-playwright-browser_click",
        "cloudflare-playwright-browser_navigate_back",
        "cloudflare-playwright-browser_resize",
        "cloudflare-playwright-browser_navigate_forward",
        "cloudflare-playwright-browser_file_upload",
        "cloudflare-playwright-browser_tab_select",
        "cloudflare-playwright-browser_snapshot",
        "cloudflare-playwright-browser_hover",
        "cloudflare-playwright-browser_handle_dialog",
        "cloudflare-playwright-browser_tab_list",
        "cloudflare-playwright-browser_tab_new",
        "cloudflare-playwright-browser_take_screenshot",
        "cloudflare-playwright-browser_install",
        "cloudflare-playwright-browser_wait",
        "cloudflare-playwright-browser_select_option",
        "cloudflare-playwright-browser_console_messages",
        "cloudflare-playwright-browser_drag"
      ]
    },
    "Poker Win Calculator": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "Both functions provided by the MCP server, `analyse_poker_cards` and `get_best_nim_move`, are purely stateless computational functions. They take input parameters, perform deterministic calculations (Monte Carlo simulations for poker hand evaluation and nim-sum strategy computation for Nim), and return results without modifying or relying on any persistent internal state. There is no indication of configuration settings, session management, stored game contexts, or side effects that persist across calls. Each function call operates independently and would produce the same output for the same inputs regardless of previous calls. Furthermore, the two functions belong to entirely different domains (poker and Nim), suggesting they do not share context or state. No function performs a \"write\" operation that another function could later \"read.\"",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1034,
        "completion_tokens": 178,
        "total_tokens": 1212
      },
      "function_count": 2,
      "functions": [
        "poker-win-calculator-get_best_nim_move",
        "poker-win-calculator-analyse_poker_cards"
      ]
    },
    "bioRxiv MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The bioRxiv MCP Server provides functions for searching preprints and retrieving metadata, all of which are read-only operations. None of the available tools (search_biorxiv_key_words, search_biorxiv_advanced, get_biorxiv_metadata) perform create, update, or delete actions that would modify persistent state on the server. Each function operates independently, relying solely on external data sources (the bioRxiv database) rather than any internal mutable state set by prior function calls. There is no indication of shared context, sessions, configurations, or cached data that persist across or influence sequential calls. All inputs are provided explicitly in each function call, and outputs do not depend on previous interactions. Therefore, there is no evidence of stateful behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1194,
        "completion_tokens": 175,
        "total_tokens": 1369
      },
      "function_count": 3,
      "functions": [
        "biorxiv-mcp-server-search_biorxiv_key_words",
        "biorxiv-mcp-server-search_biorxiv_advanced",
        "biorxiv-mcp-server-get_biorxiv_metadata"
      ]
    },
    "Figma API Integration": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior due to the presence of configuration state that persists across function calls. Specifically, the `set_api_key` function stores a Figma API personal access token in a persistent configuration file (`~/.mcp-figma/config.json`). Subsequent API calls (e.g., `get_file`, `post_comment`, `get_team_projects`, etc.) require this API key to authenticate requests to Figma's API. Without a configured key, these functions would fail or return authentication errors. This dependency on a previously set credential demonstrates that the outcome of multiple functions depends on the state established by `set_api_key`. Additionally, `check_api_key` explicitly allows inspection of this stored state, further confirming its persistence and shared context across tool invocations.",
      "state_dependencies": [
        {
          "function_a": "set_api_key",
          "function_b": "get_file",
          "state_description": "API key set by set_api_key is required for get_file to authenticate and retrieve a Figma file"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_file_nodes",
          "state_description": "API key set by set_api_key is required for get_file_nodes to authenticate and retrieve nodes from a Figma file"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_image",
          "state_description": "API key set by set_api_key is required for get_image to authenticate and retrieve rendered images"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_image_fills",
          "state_description": "API key set by set_api_key is required for get_image_fills to authenticate and retrieve image fill URLs"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_comments",
          "state_description": "API key set by set_api_key is required for get_comments to authenticate and retrieve comments"
        },
        {
          "function_a": "set_api_key",
          "function_b": "post_comment",
          "state_description": "API key set by set_api_key is required for post_comment to authenticate and create a new comment"
        },
        {
          "function_a": "set_api_key",
          "function_b": "delete_comment",
          "state_description": "API key set by set_api_key is required for delete_comment to authenticate and remove a comment"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_team_projects",
          "state_description": "API key set by set_api_key is required for get_team_projects to authenticate and retrieve team projects"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_project_files",
          "state_description": "API key set by set_api_key is required for get_project_files to authenticate and retrieve project files"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_team_components",
          "state_description": "API key set by set_api_key is required for get_team_components to authenticate and retrieve team components"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_file_components",
          "state_description": "API key set by set_api_key is required for get_file_components to authenticate and retrieve components from a file"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_component",
          "state_description": "API key set by set_api_key is required for get_component to authenticate and retrieve a component by key"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_team_component_sets",
          "state_description": "API key set by set_api_key is required for get_team_component_sets to authenticate and retrieve component sets"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_team_styles",
          "state_description": "API key set by set_api_key is required for get_team_styles to authenticate and retrieve styles for a team"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_file_styles",
          "state_description": "API key set by set_api_key is required for get_file_styles to authenticate and retrieve styles from a file"
        },
        {
          "function_a": "set_api_key",
          "function_b": "get_style",
          "state_description": "API key set by set_api_key is required for get_style to authenticate and retrieve a style by key"
        },
        {
          "function_a": "set_api_key",
          "function_b": "check_api_key",
          "state_description": "check_api_key reads the API key state set by set_api_key to determine if authentication is configured"
        }
      ],
      "token_usage": {
        "prompt_tokens": 2755,
        "completion_tokens": 1039,
        "total_tokens": 3794
      },
      "function_count": 18,
      "functions": [
        "figma-api-integration-post_comment",
        "figma-api-integration-get_team_component_sets",
        "figma-api-integration-get_team_projects",
        "figma-api-integration-get_team_components",
        "figma-api-integration-get_image",
        "figma-api-integration-set_api_key",
        "figma-api-integration-delete_comment",
        "figma-api-integration-get_image_fills",
        "figma-api-integration-get_style",
        "figma-api-integration-get_project_files",
        "figma-api-integration-get_file_styles",
        "figma-api-integration-get_comments",
        "figma-api-integration-check_api_key",
        "figma-api-integration-get_file_components",
        "figma-api-integration-get_file",
        "figma-api-integration-get_component",
        "figma-api-integration-get_file_nodes",
        "figma-api-integration-get_team_styles"
      ]
    },
    "Quran MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Quran MCP Server provides read-only access to static religious content (Quranic text, translations, metadata, and structural divisions). All available tools are retrieval functions that accept explicit parameters (e.g., edition_name, chapter_no, juz_no) and return data without any indication of modifying server-side state. There are no operations for creating, updating, or deleting content, nor any mechanisms such as authentication, session initialization, configuration setting, or caching that would introduce persistent context between calls. Each function operates independently based solely on input parameters and does not rely on prior interactions. The presence of multiple getters with no corresponding setters or state-modifying actions strongly indicates a stateless design typical of content delivery APIs.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2925,
        "completion_tokens": 167,
        "total_tokens": 3092
      },
      "function_count": 12,
      "functions": [
        "quran-mcp-server-get_quran_fonts",
        "quran-mcp-server-get_quran_editions",
        "quran-mcp-server-get_quran_editions_min",
        "quran-mcp-server-get_quran_manzil",
        "quran-mcp-server-get_quran_info",
        "quran-mcp-server-get_quran_verse",
        "quran-mcp-server-get_quran_maqra",
        "quran-mcp-server-get_quran_ruku",
        "quran-mcp-server-get_quran_full",
        "quran-mcp-server-get_quran_page",
        "quran-mcp-server-get_quran_chapter",
        "quran-mcp-server-get_quran_juz"
      ]
    },
    "Framer Plugin Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Framer Plugin Server exhibits stateful behavior because the `create_plugin` function creates a plugin project directory with specified web3 features, which modifies the system state by generating files and configuration in the file system at the given `outputPath`. The `build_plugin` function then depends on this state, as it requires an existing plugin directory (created by `create_plugin`) to perform the build operation. Without a prior call to `create_plugin`, `build_plugin` would fail or have no meaningful target to build. This represents a clear dependency where one function establishes necessary context (a created plugin project) that another function consumes. The shared context is the existence and structure of the plugin project on the file system, including its configuration and included web3 features.",
      "state_dependencies": [
        {
          "function_a": "create_plugin",
          "function_b": "build_plugin",
          "state_description": "Plugin project directory and configuration created by create_plugin are required for build_plugin to execute successfully"
        }
      ],
      "token_usage": {
        "prompt_tokens": 747,
        "completion_tokens": 223,
        "total_tokens": 970
      },
      "function_count": 2,
      "functions": [
        "framer-plugin-server-create_plugin",
        "framer-plugin-server-build_plugin"
      ]
    },
    "Math-MCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All functions in the Math-MCP server are pure mathematical operations that take explicit input parameters and return deterministic outputs without modifying or relying on any shared, persistent state. Each function operates independently: for example, `add`, `subtract`, `multiply`, and `division` perform binary arithmetic; `sum`, `mean`, `median`, `mode`, `min`, `max` compute statistics over provided arrays; and `floor`, `ceiling`, `round` perform rounding operations on individual numbers. None of the functions create, update, or depend on configurations, sessions, caches, or stored data across calls. There is no indication of side effects or shared context between function invocations. Therefore, the server is stateless.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2014,
        "completion_tokens": 170,
        "total_tokens": 2184
      },
      "function_count": 13,
      "functions": [
        "math-mcp-subtract",
        "math-mcp-sum",
        "math-mcp-max",
        "math-mcp-median",
        "math-mcp-round",
        "math-mcp-division",
        "math-mcp-floor",
        "math-mcp-mean",
        "math-mcp-mode",
        "math-mcp-add",
        "math-mcp-min",
        "math-mcp-ceiling",
        "math-mcp-multiply"
      ]
    },
    "Medical Calculation Server": {
      "is_stateful": false,
      "confidence": 0.99,
      "reasoning": "All available tools in the Medical Calculation Server are purely computational and deterministic functions that take explicit input parameters and return results based solely on those inputs. None of the tools perform operations that modify persistent state (e.g., no data storage, session creation, configuration changes, or side effects). Each function is self-contained, with no indication of internal state being stored or modified across calls. Furthermore, no function depends on prior execution of another function—every required parameter must be explicitly provided at call time. For example, while `prevent_cvd_risk` includes an `egfr` parameter, it does not implicitly depend on a prior call to `egfr_epi`; rather, the caller must supply the eGFR value regardless of how it was obtained. Similarly, tools like `pregnancy_calculator` accept dates and cycle lengths but do not store or reference previously calculated due dates. There is no shared context, session management, or global configuration that persists across function invocations. Therefore, the server behaves as a stateless collection of medical calculators.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 8334,
        "completion_tokens": 237,
        "total_tokens": 8571
      },
      "function_count": 22,
      "functions": [
        "medical-calculation-server-pregnancy_calculator",
        "medical-calculation-server-calculate_mme",
        "medical-calculation-server-chads2_vasc_score",
        "medical-calculation-server-wells_pe_criteria",
        "medical-calculation-server-crcl_cockcroft_gault",
        "medical-calculation-server-bp_children",
        "medical-calculation-server-meld_3",
        "medical-calculation-server-homa_ir",
        "medical-calculation-server-corrected_sodium",
        "medical-calculation-server-egfr_epi",
        "medical-calculation-server-qtc_calculator",
        "medical-calculation-server-revised_cardiac_risk_index",
        "medical-calculation-server-bmi_bsa_calculator",
        "medical-calculation-server-map_calculator",
        "medical-calculation-server-corrected_calcium",
        "medical-calculation-server-egfr_epi_cr_cys",
        "medical-calculation-server-ibw_abw_calculator",
        "medical-calculation-server-maintenance_fluids",
        "medical-calculation-server-framingham_risk_score",
        "medical-calculation-server-prevent_cvd_risk",
        "medical-calculation-server-child_pugh_score",
        "medical-calculation-server-steroid_conversion"
      ]
    },
    "虚拟币价格查询服务": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the \"虚拟币价格查询服务\" are read-only operations that retrieve data from external sources (e.g., cryptocurrency price APIs, market data endpoints). None of the functions perform create, update, delete, or modify operations on any persistent state. Each function operates independently, taking explicit input parameters (such as coin_id, symbol, query, etc.) and returning data without relying on or altering shared context, sessions, configurations, or server-side state. There is no indication that calling one function affects the behavior or output of another. For example, calling `get_coin_price` does not influence the result of `get_trending_coins`, nor does any function require prior setup (like authentication or initialization) to function correctly. All data dependencies are passed directly through arguments, not maintained implicitly across calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2398,
        "completion_tokens": 189,
        "total_tokens": 2587
      },
      "function_count": 12,
      "functions": [
        "虚拟币价格查询服务-get_trade_amount",
        "虚拟币价格查询服务-get_exchange_position",
        "虚拟币价格查询服务-get_kline_data",
        "虚拟币价格查询服务-get_coin_price",
        "虚拟币价格查询服务-get_trending_coins",
        "虚拟币价格查询服务-get_coin_info",
        "虚拟币价格查询服务-get_common_coins_prices",
        "虚拟币价格查询服务-get_trade_volume",
        "虚拟币价格查询服务-search_coins",
        "虚拟币价格查询服务-get_position_info",
        "虚拟币价格查询服务-get_global_market_data",
        "虚拟币价格查询服务-get_coin_detail"
      ]
    },
    "Terminal Controller": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Terminal Controller MCP server is clearly stateful because multiple functions modify or depend on shared persistent state across calls. Specifically, several functions alter the file system (e.g., writing, updating, or deleting file content) or change the execution context (e.g., current directory), and other functions' behavior depends on these changes. For example, writing to a file with `write_file` affects the output of subsequent `read_file` calls to the same path. Similarly, changing the directory with `change_directory` affects the results of `get_current_directory`, `list_directory`, and any file operations that use relative paths. Additionally, command history is maintained between calls, as evidenced by the `get_command_history` function, which implies that `execute_command` modifies a shared history log. These cross-function dependencies on mutable state confirm stateful behavior.",
      "state_dependencies": [
        {
          "function_a": "write_file",
          "function_b": "read_file",
          "state_description": "File content written by write_file is read by read_file when accessing the same file path"
        },
        {
          "function_a": "write_file",
          "function_b": "update_file_content",
          "state_description": "File must exist and contain data from write_file before update_file_content can modify it"
        },
        {
          "function_a": "write_file",
          "function_b": "insert_file_content",
          "state_description": "File must be created or modified by write_file before insert_file_content can operate on it"
        },
        {
          "function_a": "write_file",
          "function_b": "delete_file_content",
          "state_description": "File content created by write_file is subject to deletion via delete_file_content"
        },
        {
          "function_a": "change_directory",
          "function_b": "get_current_directory",
          "state_description": "Current working directory is updated by change_directory and returned by get_current_directory"
        },
        {
          "function_a": "change_directory",
          "function_b": "list_directory",
          "state_description": "The directory listed by list_directory defaults to the current working directory set by change_directory when no path is provided"
        },
        {
          "function_a": "execute_command",
          "function_b": "get_command_history",
          "state_description": "Each call to execute_command adds an entry to the command history retrieved by get_command_history"
        },
        {
          "function_a": "update_file_content",
          "function_b": "read_file",
          "state_description": "Changes made by update_file_content to a file are reflected when read_file is called on the same path"
        },
        {
          "function_a": "insert_file_content",
          "function_b": "read_file",
          "state_description": "Content inserted into a file via insert_file_content is included in the output of read_file for that file"
        },
        {
          "function_a": "delete_file_content",
          "function_b": "read_file",
          "state_description": "Deletions performed by delete_file_content affect the content returned by subsequent read_file calls"
        }
      ],
      "token_usage": {
        "prompt_tokens": 2162,
        "completion_tokens": 665,
        "total_tokens": 2827
      },
      "function_count": 10,
      "functions": [
        "terminal-controller-change_directory",
        "terminal-controller-list_directory",
        "terminal-controller-delete_file_content",
        "terminal-controller-insert_file_content",
        "terminal-controller-update_file_content",
        "terminal-controller-read_file",
        "terminal-controller-write_file",
        "terminal-controller-execute_command",
        "terminal-controller-get_current_directory",
        "terminal-controller-get_command_history"
      ]
    },
    "WaPulse Whatsapp MCP Server": {
      "is_stateful": true,
      "confidence": 0.98,
      "reasoning": "The WaPulse WhatsApp MCP server exhibits strong stateful behavior, as multiple functions modify persistent state that subsequent functions depend on. Key indicators include the management of WhatsApp instances (via `create_instance`, `start_instance`, `stop_instance`, `delete_instance`), group administration operations (such as adding/removing participants, promoting/demoting admins), and messaging capabilities that rely on existing chat contexts.\n\nSeveral function pairs demonstrate clear state dependencies:\n- Instance lifecycle functions (`create_instance`, `start_instance`) establish a runtime context required by nearly all other tools (e.g., sending messages or retrieving chats). Without a created and started instance, most operations would fail.\n- Group creation via `create_whatsapp_group` produces a group ID that is later used in dependent functions like `add_group_participants`, `get_group_invite_link`, or `load_chat_messages`. These functions cannot operate meaningfully without the prior existence of the group.\n- Functions such as `send_whatsapp_message` or `send_whatsapp_files` alter the message state of a chat, which can then be retrieved later using `load_chat_messages`, implying that the latter depends on prior sends.\n- Operations like `approve_group_request` or `reject_group_request` depend on pending requests generated externally but managed within the group's internal state, which must first exist via group configuration.\n\nAdditionally, many tools accept optional `customToken` and `customInstanceID` parameters, indicating that they interact with shared session or authentication state tied to a specific instance. This further supports the conclusion that the server maintains cross-call context.\n\nThe presence of bidirectional interactions—where one function creates an entity and others read or modify it—is definitive evidence of statefulness in an MCP server.",
      "state_dependencies": [
        {
          "function_a": "create_instance",
          "function_b": "start_instance",
          "state_description": "An instance must be created before it can be started; start_instance depends on the existence of an instance established by create_instance"
        },
        {
          "function_a": "start_instance",
          "function_b": "send_whatsapp_message",
          "state_description": "Messages can only be sent when an instance is running; send_whatsapp_message requires the active session state set up by start_instance"
        },
        {
          "function_a": "create_whatsapp_group",
          "function_b": "add_group_participants",
          "state_description": "Participants can only be added to an existing group; add_group_participants depends on the group created by create_whatsapp_group"
        },
        {
          "function_a": "create_whatsapp_group",
          "function_b": "get_group_invite_link",
          "state_description": "An invite link can only be retrieved for an already-created group; get_group_invite_link depends on the group state from create_whatsapp_group"
        },
        {
          "function_a": "send_whatsapp_message",
          "function_b": "load_chat_messages",
          "state_description": "Messages retrieved by load_chat_messages include those previously sent via send_whatsapp_message; the latter modifies chat history state read by the former"
        },
        {
          "function_a": "create_whatsapp_group",
          "function_b": "promote_group_participants",
          "state_description": "Participants can only be promoted in an existing group created by create_whatsapp_group; promote_group_participants depends on the group's existence and membership state"
        },
        {
          "function_a": "start_instance",
          "function_b": "get_all_chats",
          "state_description": "Chat list can only be retrieved from a running instance; get_all_chats depends on the connected session state initialized by start_instance"
        },
        {
          "function_a": "create_instance",
          "function_b": "get_qr_code",
          "state_description": "A QR code for WhatsApp Web login is generated for a specific instance; get_qr_code depends on the instance being created via create_instance"
        }
      ],
      "token_usage": {
        "prompt_tokens": 4654,
        "completion_tokens": 832,
        "total_tokens": 5486
      },
      "function_count": 25,
      "functions": [
        "wapulse-whatsapp-mcp-server-change_group_invite_code",
        "wapulse-whatsapp-mcp-server-send_whatsapp_audio",
        "wapulse-whatsapp-mcp-server-check_id_exists",
        "wapulse-whatsapp-mcp-server-get_group_invite_link",
        "wapulse-whatsapp-mcp-server-get_all_chats",
        "wapulse-whatsapp-mcp-server-promote_group_participants",
        "wapulse-whatsapp-mcp-server-create_whatsapp_group",
        "wapulse-whatsapp-mcp-server-get_all_groups",
        "wapulse-whatsapp-mcp-server-start_instance",
        "wapulse-whatsapp-mcp-server-reject_group_request",
        "wapulse-whatsapp-mcp-server-load_chat_messages",
        "wapulse-whatsapp-mcp-server-delete_instance",
        "wapulse-whatsapp-mcp-server-add_group_participants",
        "wapulse-whatsapp-mcp-server-get_qr_code",
        "wapulse-whatsapp-mcp-server-approve_group_request",
        "wapulse-whatsapp-mcp-server-validate_phone_number",
        "wapulse-whatsapp-mcp-server-get_group_requests",
        "wapulse-whatsapp-mcp-server-get_wapulse_documentation",
        "wapulse-whatsapp-mcp-server-send_whatsapp_message",
        "wapulse-whatsapp-mcp-server-create_instance",
        "wapulse-whatsapp-mcp-server-demote_group_participants",
        "wapulse-whatsapp-mcp-server-leave_whatsapp_group",
        "wapulse-whatsapp-mcp-server-remove_group_participants",
        "wapulse-whatsapp-mcp-server-stop_instance",
        "wapulse-whatsapp-mcp-server-send_whatsapp_files"
      ]
    },
    "Stepstone Job Listings Fetcher": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "stepstone-job-listings-fetcher-search_jobs"
      ]
    },
    "Playwright Browser Automation Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Playwright Browser Automation Server maintains a persistent browser context across function calls, which includes the current page state, navigation history, open tabs, console messages, network requests, and user interactions. Multiple functions both modify and depend on this shared state. For example, `browser_navigate` changes the current page URL, which affects the output of subsequent calls to `browser_snapshot`, `browser_console_messages`, or `browser_network_requests`. Similarly, actions like `browser_click`, `browser_type`, or `browser_select_option` depend on prior state such as the DOM structure captured in a previous snapshot (via `browser_snapshot`) to locate elements using `ref` identifiers. Furthermore, tab management functions (`browser_tab_new`, `browser_tab_select`, `browser_tab_close`) explicitly manipulate and rely on a shared, mutable set of open tabs. The dependency of interaction tools on element references (`ref`) from prior snapshots confirms that the server retains and builds upon state across calls. This tight coupling between action and context demonstrates clear statefulness.",
      "state_dependencies": [
        {
          "function_a": "browser_navigate",
          "function_b": "browser_snapshot",
          "state_description": "The page content captured by browser_snapshot depends on the URL loaded via browser_navigate."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_console_messages",
          "state_description": "Console messages returned by browser_console_messages are generated after navigating to a page with browser_navigate."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_network_requests",
          "state_description": "Network requests tracked by browser_network_requests originate from resources loaded during or after browser_navigate."
        },
        {
          "function_a": "browser_snapshot",
          "function_b": "browser_click",
          "state_description": "The element reference (ref) used in browser_click must come from a prior accessibility snapshot taken by browser_snapshot."
        },
        {
          "function_a": "browser_snapshot",
          "function_b": "browser_type",
          "state_description": "The element reference (ref) used in browser_type must be obtained from a previous browser_snapshot."
        },
        {
          "function_a": "browser_snapshot",
          "function_b": "browser_hover",
          "state_description": "The element reference (ref) used in browser_hover is derived from a prior browser_snapshot."
        },
        {
          "function_a": "browser_snapshot",
          "function_b": "browser_select_option",
          "state_description": "The element reference (ref) used in browser_select_option must be retrieved from a previous browser_snapshot."
        },
        {
          "function_a": "browser_tab_new",
          "function_b": "browser_tab_select",
          "state_description": "The new tab created by browser_tab_new can be selected later using browser_tab_select with its index."
        },
        {
          "function_a": "browser_tab_new",
          "function_b": "browser_tab_close",
          "state_description": "Tabs opened with browser_tab_new can be closed by specifying their index in browser_tab_close."
        },
        {
          "function_a": "browser_resize",
          "function_b": "browser_take_screenshot",
          "state_description": "The dimensions of the screenshot taken by browser_take_screenshot are affected by the window size set via browser_resize."
        },
        {
          "function_a": "browser_type",
          "function_b": "browser_press_key",
          "state_description": "Both functions interact with the same active input field on the page, implying shared focus state within the browser context."
        },
        {
          "function_a": "browser_navigate_back",
          "function_b": "browser_navigate_forward",
          "state_description": "The ability to go forward depends on having previously gone back, relying on navigation history state modified by browser_navigate_back."
        },
        {
          "function_a": "browser_navigate",
          "function_b": "browser_navigate_back",
          "state_description": "Navigation back depends on prior navigation actions performed by browser_navigate creating history entries."
        }
      ],
      "token_usage": {
        "prompt_tokens": 3507,
        "completion_tokens": 870,
        "total_tokens": 4377
      },
      "function_count": 23,
      "functions": [
        "playwright-browser-automation-server-browser_navigate_forward",
        "playwright-browser-automation-server-browser_select_option",
        "playwright-browser-automation-server-browser_handle_dialog",
        "playwright-browser-automation-server-browser_hover",
        "playwright-browser-automation-server-browser_resize",
        "playwright-browser-automation-server-browser_tab_close",
        "playwright-browser-automation-server-browser_navigate_back",
        "playwright-browser-automation-server-browser_console_messages",
        "playwright-browser-automation-server-browser_snapshot",
        "playwright-browser-automation-server-browser_type",
        "playwright-browser-automation-server-browser_file_upload",
        "playwright-browser-automation-server-browser_click",
        "playwright-browser-automation-server-browser_close",
        "playwright-browser-automation-server-browser_tab_new",
        "playwright-browser-automation-server-browser_navigate",
        "playwright-browser-automation-server-browser_wait",
        "playwright-browser-automation-server-browser_take_screenshot",
        "playwright-browser-automation-server-browser_tab_list",
        "playwright-browser-automation-server-browser_press_key",
        "playwright-browser-automation-server-browser_tab_select",
        "playwright-browser-automation-server-browser_drag",
        "playwright-browser-automation-server-browser_pdf_save",
        "playwright-browser-automation-server-browser_install"
      ]
    },
    "Shadcn Vue MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Shadcn Vue MCP Server exhibits stateful behavior due to the sequential and dependent nature of its tool interactions, where the output or internal state from one function is required for another to operate correctly. Specifically:\n\n1. **State Modification**: The `requirement-structuring` tool processes raw user input and generates a structured requirement document. While it may not explicitly mutate server-side persistent storage, it establishes a contextual state (structured requirements) that subsequent tools depend on.\n\n2. **State Dependency**: The `components-filter` tool requires the *output* of `requirement-structuring` as its input (`message` parameter described as \"requirement json from requirement-structuring tool\"). This indicates that `components-filter` cannot function correctly without prior execution of `requirement-structuring`, implying shared context/state.\n\n3. **Chained Tool Usage**: The `component-builder` tool expects filtered components from `components-filter` (via the `components` and `charts` arrays in its parameters). Thus, it depends on the state established by earlier tools in the pipeline.\n\n4. **Validation Based on Generated Output**: The `component-quality-check` tool requires the component code generated by `component-builder`. This creates a clear dependency chain where `component-quality-check` relies on the output (a form of transient state) produced by `component-builder`.\n\nAlthough no explicit long-term persistence (e.g., database writes) is indicated, the system maintains and depends on **transient, session-like context** across function calls—this is characteristic of stateful systems in the context of MCP protocols, especially when tools are designed to work in a pipeline with tightly coupled inputs and outputs.",
      "state_dependencies": [
        {
          "function_a": "requirement-structuring",
          "function_b": "components-filter",
          "state_description": "Structured requirement JSON output from requirement-structuring is used as input message for components-filter"
        },
        {
          "function_a": "components-filter",
          "function_b": "component-builder",
          "state_description": "Filtered list of components and charts from components-filter is passed to component-builder to generate actual component snippets"
        },
        {
          "function_a": "component-builder",
          "function_b": "component-quality-check",
          "state_description": "Generated Vue component code from component-builder is provided as input to component-quality-check for validation"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1393,
        "completion_tokens": 501,
        "total_tokens": 1894
      },
      "function_count": 5,
      "functions": [
        "shadcn-vue-mcp-server-component-usage-doc",
        "shadcn-vue-mcp-server-component-quality-check",
        "shadcn-vue-mcp-server-components-filter",
        "shadcn-vue-mcp-server-component-builder",
        "shadcn-vue-mcp-server-requirement-structuring"
      ]
    },
    "鸣潮 MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the 鸣潮 MCP Server are read-only operations that retrieve static information (e.g., character details, artifacts, profiles) from an external source (库街区). None of the functions perform create, update, delete, or configuration-setting actions that would modify persistent state. Each function operates independently, taking a name as input and returning data without relying on or altering shared context, sessions, or configurations. There is no indication that calling one function affects the behavior or output of another. The absence of any state-modifying or state-dependent functionality strongly suggests this server is stateless.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 889,
        "completion_tokens": 146,
        "total_tokens": 1035
      },
      "function_count": 3,
      "functions": [
        "鸣潮-mcp-server-get_artifact_info",
        "鸣潮-mcp-server-get_character_info",
        "鸣潮-mcp-server-get_character_profile"
      ]
    },
    "OpenAPI MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The OpenAPI MCP Server provides two read-only functions—`getApiOverview` and `getApiOperation`—that retrieve metadata about OpenAPI specifications. Neither function performs mutations, creates, updates, or deletes any system state. Both functions are idempotent and depend solely on their input parameters (`id`, and optionally `operationIdOrRoute`) to fetch data. There is no indication of shared context, session state, configuration storage, or side effects that persist across calls. The design follows a purely functional pattern where each call is independent and self-contained. While one might logically call `getApiOverview` before `getApiOperation` for workflow efficiency, this is a logical dependency, not a stateful one—the second function does not rely on any internal state set by the first.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2328,
        "completion_tokens": 182,
        "total_tokens": 2510
      },
      "function_count": 2,
      "functions": [
        "openapi-mcp-server-getApiOperation",
        "openapi-mcp-server-getApiOverview"
      ]
    },
    "Clear Thought Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Clear Thought Server exhibits strong indicators of stateful behavior through multiple tools that maintain, reference, and build upon shared context across function calls. Several tools include parameters that imply persistent session identifiers, iterative reasoning states, and interdependencies where the output or execution of one function directly influences another.\n\nKey evidence includes:\n\n1. **Session Identifiers**: Multiple tools (e.g., `collaborativereasoning`, `decisionframework`, `scientificmethod`, `metacognitivemonitoring`) include a `sessionId`, `decisionId`, `inquiryId`, or `monitoringId` parameter. These IDs suggest the existence of persistent sessions that can be referenced and updated across multiple invocations.\n\n2. **Iteration Tracking**: Tools like `collaborativereasoning`, `decisionframework`, `scientificmethod`, and `metacognitivemonitoring` all include an `iteration` field (with minimum value 0), indicating that these processes evolve over time and expect continuity across calls. This implies that calling the same tool multiple times with the same ID advances or modifies an ongoing process.\n\n3. **State Evolution via Dependencies**:\n   - In `collaborativereasoning`, the `contributions` array contains a history of inputs from personas, and fields like `consensusPoints`, `disagreements`, and `keyInsights` accumulate over time. Subsequent calls would depend on prior contributions.\n   - In `decisionframework`, the `possibleOutcomes` and evaluation depend on earlier stages such as `criteria-definition` and `options-generation`. The presence of `nextStageNeeded` suggests multi-step progression.\n   - In `scientificmethod`, each stage (observation → hypothesis → experiment → analysis) builds on previous outputs. The `hypothesisId` is used in the `experiment` object, creating a direct dependency between stages.\n   - In `visualreasoning`, the `diagramId` persists across operations (`create`, `update`, `transform`), indicating that visual state is maintained and modified incrementally.\n\n4. **Cross-Call Coordination**: The `sequentialthinking` tool supports revision (`isRevision`, `revisesThought`) and branching (`branchFromThought`, `branchId`), which require maintaining a record of prior thoughts to support coherent evolution of reasoning. The `nextThoughtNeeded` flag further indicates that the process is meant to continue across multiple calls.\n\nThese patterns confirm that state is not only preserved but is essential for correct functionality—calling a later stage without prior setup would result in incomplete or invalid processing.",
      "state_dependencies": [
        {
          "function_a": "collaborativereasoning",
          "function_b": "collaborativereasoning",
          "state_description": "Subsequent calls to collaborativereasoning depend on the sessionId and prior contributions, consensus points, and disagreements established in earlier calls."
        },
        {
          "function_a": "scientificmethod",
          "function_b": "scientificmethod",
          "state_description": "The experiment stage depends on the hypothesisId and variables defined in a prior hypothesis stage within the same inquiryId."
        },
        {
          "function_a": "decisionframework",
          "function_b": "decisionframework",
          "state_description": "Evaluation and recommendation stages depend on previously defined options, criteria, and possible outcomes under the same decisionId."
        },
        {
          "function_a": "visualreasoning",
          "function_b": "visualreasoning",
          "state_description": "Update or transform operations depend on a diagramId previously created in an earlier call with the same diagramId."
        },
        {
          "function_a": "sequentialthinking",
          "function_b": "sequentialthinking",
          "state_description": "Later thoughts may revise or branch from earlier ones, requiring persistence of thoughtNumber, branchId, and content from prior calls."
        },
        {
          "function_a": "metacognitivemonitoring",
          "function_b": "metacognitivemonitoring",
          "state_description": "Monitoring stages evolve over iterations under the same monitoringId, with claims and reasoning steps accumulating or being revised."
        }
      ],
      "token_usage": {
        "prompt_tokens": 7294,
        "completion_tokens": 874,
        "total_tokens": 8168
      },
      "function_count": 11,
      "functions": [
        "clear-thought-server-debuggingapproach",
        "clear-thought-server-decisionframework",
        "clear-thought-server-metacognitivemonitoring",
        "clear-thought-server-collaborativereasoning",
        "clear-thought-server-mentalmodel",
        "clear-thought-server-designpattern",
        "clear-thought-server-sequentialthinking",
        "clear-thought-server-visualreasoning",
        "clear-thought-server-programmingparadigm",
        "clear-thought-server-scientificmethod",
        "clear-thought-server-structuredargumentation"
      ]
    },
    "Bazi Calculator": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Bazi Calculator MCP server are pure functions—each takes explicit input parameters and returns deterministic output based solely on those inputs, with no indication of persistent state modification or dependency on prior calls.  \n\n- **Tool 1 (getBaziDetail)**, **Tool 4 (buildBaziFromLunarDatetime)**, and **Tool 5 (buildBaziFromSolarDatetime)** compute八字 (BaZi) charts from time and gender inputs. They do not create, update, or store data; they only calculate and return results.  \n- **Tool 2 (getSolarTimes)** converts a given BaZi string back into possible solar times. It operates purely on the provided八字 string and does not rely on any external or previously set context.  \n- **Tool 3 (getChineseCalendar)** retrieves traditional calendar information for a given solar datetime, if provided, or defaults to the current date. This is a read-only operation with no side effects.\n\nNone of the functions perform create, update, or delete operations. There is no shared session, configuration, or cached state that persists across function calls. Each function call is independent and idempotent. For example, calling `getBaziDetail` does not alter the behavior of `getSolarTimes` or any other function. Even though multiple tools may operate on similar domains (e.g., converting between solar/lunar and八字), they do so independently without relying on mutable state.\n\nThere is no evidence of configuration settings (like `eightCharProviderSect`) being stored globally or affecting other calls beyond the scope of a single request. These are transient parameters, not persistent state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1627,
        "completion_tokens": 362,
        "total_tokens": 1989
      },
      "function_count": 5,
      "functions": [
        "bazi-calculator-getChineseCalendar",
        "bazi-calculator-buildBaziFromSolarDatetime",
        "bazi-calculator-buildBaziFromLunarDatetime",
        "bazi-calculator-getSolarTimes",
        "bazi-calculator-getBaziDetail"
      ]
    },
    "Swagger MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior through its template management functionality. Specifically, the `template-save` tool creates or updates a named template (modifying persistent state), and subsequent calls to `template-get` or `template-list` (with `includeContent: true`) can retrieve this saved template content. This indicates that the server maintains shared, persistent state across function calls in the form of user-defined templates. Additionally, `template-delete` modifies the system state by removing a previously stored template, which affects the output of future `template-list` or `template-get` calls. These dependencies confirm that the outcome of certain functions depends on prior invocations that alter the server's internal state.",
      "state_dependencies": [
        {
          "function_a": "template-save",
          "function_b": "template-get",
          "state_description": "Template content saved via template-save is retrieved by template-get using the template ID"
        },
        {
          "function_a": "template-save",
          "function_b": "template-list",
          "state_description": "Custom templates added via template-save appear in the list returned by template-list when filtering by type or framework"
        },
        {
          "function_a": "template-delete",
          "function_b": "template-get",
          "state_description": "After deleting a template with template-delete, attempts to retrieve it via template-get will fail or return not found"
        },
        {
          "function_a": "template-delete",
          "function_b": "template-list",
          "state_description": "Templates removed via template-delete no longer appear in the results of template-list"
        }
      ],
      "token_usage": {
        "prompt_tokens": 4447,
        "completion_tokens": 351,
        "total_tokens": 4798
      },
      "function_count": 12,
      "functions": [
        "swagger-mcp-server-parse-swagger-optimized",
        "swagger-mcp-server-generate-api-client",
        "swagger-mcp-server-generate-api-client-optimized",
        "swagger-mcp-server-parse-swagger-lite",
        "swagger-mcp-server-parse-swagger",
        "swagger-mcp-server-template-get",
        "swagger-mcp-server-generate-typescript-types-optimized",
        "swagger-mcp-server-template-list",
        "swagger-mcp-server-template-delete",
        "swagger-mcp-server-file_writer",
        "swagger-mcp-server-generate-typescript-types",
        "swagger-mcp-server-template-save"
      ]
    },
    "Think Tank": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The MCP Think Tank server is explicitly designed to maintain persistent state across function calls, primarily through its **Knowledge Graph Memory system** and **Task Management Tools**, both of which are described as having persistent, shared context. Multiple tools modify and depend on this shared state:\n\n- Several tools (e.g., `upsert_entities`, `add_observations`, `create_relations`) **modify** the knowledge graph by creating or updating entities and relationships.\n- Other tools (e.g., `read_graph`, `search_nodes`, `open_nodes`, `memory_query`) **retrieve** data from the same knowledge graph, meaning their output depends directly on prior modifications.\n- Task-related tools like `plan_tasks`, `next_task`, and `complete_task` imply a shared, mutable task state that evolves over time—calling `next_task` changes the state (marking a task as in-progress), which affects future calls.\n- The `think` tool can optionally store thoughts in memory (`storeInMemory: true`), linking reasoning to the persistent graph.\n\nThese create clear interdependencies where the behavior of read/query tools depends on prior write operations. The entire architecture revolves around **persistent context**, confirming statefulness with maximum confidence.",
      "state_dependencies": [
        {
          "function_a": "upsert_entities",
          "function_b": "search_nodes",
          "state_description": "Entities created or updated by upsert_entities are discoverable via search_nodes"
        },
        {
          "function_a": "upsert_entities",
          "function_b": "open_nodes",
          "state_description": "Entities inserted via upsert_entities can be retrieved individually using open_nodes"
        },
        {
          "function_a": "add_observations",
          "function_b": "memory_query",
          "state_description": "Observations added via add_observations can be retrieved later through memory_query with matching filters"
        },
        {
          "function_a": "create_relations",
          "function_b": "read_graph",
          "state_description": "Relations created by create_relations are included in the full graph returned by read_graph"
        },
        {
          "function_a": "plan_tasks",
          "function_b": "next_task",
          "state_description": "Tasks planned via plan_tasks populate the task queue, which next_task draws from and modifies"
        },
        {
          "function_a": "next_task",
          "function_b": "complete_task",
          "state_description": "The task marked in-progress by next_task must be referenced when calling complete_task"
        },
        {
          "function_a": "think",
          "function_b": "read_graph",
          "state_description": "When think is used with storeInMemory=true, it adds structured reasoning to the knowledge graph, making it accessible via read_graph"
        },
        {
          "function_a": "exa_answer",
          "function_b": "memory_query",
          "state_description": "Sourced answers from exa_answer may be stored in memory (by client logic) and later retrieved via memory_query based on keyword or agent"
        }
      ],
      "token_usage": {
        "prompt_tokens": 4734,
        "completion_tokens": 647,
        "total_tokens": 5381
      },
      "function_count": 20,
      "functions": [
        "think-tank-create_relations",
        "think-tank-update_relations",
        "think-tank-complete_task",
        "think-tank-upsert_entities",
        "think-tank-update_tasks",
        "think-tank-next_task",
        "think-tank-memory_query",
        "think-tank-plan_tasks",
        "think-tank-delete_entities",
        "think-tank-add_observations",
        "think-tank-delete_observations",
        "think-tank-show_memory_path",
        "think-tank-think",
        "think-tank-read_graph",
        "think-tank-delete_relations",
        "think-tank-list_tasks",
        "think-tank-open_nodes",
        "think-tank-exa_search",
        "think-tank-exa_answer",
        "think-tank-search_nodes"
      ]
    },
    "Yahoo Finance Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Yahoo Finance Server are read-only operations that retrieve financial data based on input parameters (primarily a ticker symbol and optional filters like date, type, or period). None of the functions perform create, update, or delete operations that would modify persistent state on the server. Each function call is self-contained and does not rely on prior calls to set up context, configurations, sessions, or stored data. For example, calling `get_option_expiration_dates` returns a list of dates for a given ticker, which could inform a subsequent call to `get_option_chain`, but this represents logical workflow dependency rather than stateful server behavior—the latter does not require or remember previous interactions. There is no evidence of shared mutable state, session tokens, cached configurations, or side effects that persist across requests. The server appears to act as a stateless API wrapper around Yahoo Finance data.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2221,
        "completion_tokens": 204,
        "total_tokens": 2425
      },
      "function_count": 9,
      "functions": [
        "yahoo-finance-server-get_yahoo_finance_news",
        "yahoo-finance-server-get_historical_stock_prices",
        "yahoo-finance-server-get_option_chain",
        "yahoo-finance-server-get_option_expiration_dates",
        "yahoo-finance-server-get_stock_actions",
        "yahoo-finance-server-get_financial_statement",
        "yahoo-finance-server-get_recommendations",
        "yahoo-finance-server-get_stock_info",
        "yahoo-finance-server-get_holder_info"
      ]
    },
    "PowerShell Exec Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "After analyzing all available tools in the PowerShell Exec Server, there is no evidence of persistent state being modified or shared across function calls. All tools are designed to perform atomic operations—either executing PowerShell commands, retrieving system information, or generating scripts—without creating, modifying, or relying on any server-side persistent state between invocations.  \n\n- Tools like `run_powershell`, `get_system_info`, `get_running_services`, `get_processes`, and `get_event_logs` are read-only and do not alter system state.\n- Script generation tools (`generate_script_from_template`, `generate_custom_script`, `generate_intune_*`, `generate_bigfix_*`) generate content based solely on input parameters and return results directly; they do not store generated scripts on the server unless an explicit output path is provided by the user. Even then, file creation would be a side effect of the script logic (via PowerShell), not a maintained internal server state.\n- The presence of `ctx: Context` in some functions relates to request-scoped logging and progress reporting, not cross-request state persistence. The context is transient and tied to individual tool executions.\n- No tool exposes functionality to retrieve or depend on artifacts from prior tool calls unless those artifacts were explicitly saved to the filesystem using provided paths—and even then, dependency would be external (file-based), not internal server state.\n\nThere are no function pairs where one tool implicitly sets up state that another tool automatically depends on. All interactions are stateless and idempotent.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 8309,
        "completion_tokens": 326,
        "total_tokens": 8635
      },
      "function_count": 14,
      "functions": [
        "powershell-exec-server-generate_bigfix_action_script",
        "powershell-exec-server-get_running_services",
        "powershell-exec-server-run_powershell_with_progress",
        "powershell-exec-server-generate_bigfix_relevance_script",
        "powershell-exec-server-ensure_directory",
        "powershell-exec-server-generate_intune_script_pair",
        "powershell-exec-server-generate_bigfix_script_pair",
        "powershell-exec-server-generate_script_from_template",
        "powershell-exec-server-run_powershell",
        "powershell-exec-server-get_event_logs",
        "powershell-exec-server-generate_custom_script",
        "powershell-exec-server-get_processes",
        "powershell-exec-server-get_system_info",
        "powershell-exec-server-generate_intune_remediation_script"
      ]
    },
    "Price MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "Both available tools in the Price MCP Server — \"Steam Games Price Checker\" and \"Query cryptocurrency tool\" — are purely read-only, stateless functions. They retrieve real-time pricing data based on input parameters (appId/countryCode and symbol, respectively) without modifying any system state. There is no indication of configuration settings, session creation, stored context, or side effects that persist across calls. Each function call is independent and idempotent, relying solely on external data sources rather than internal mutable state. Furthermore, no pair of functions exhibits a producer-consumer relationship where one sets up state for the other. The absence of create, update, delete, or set operations strongly supports a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 668,
        "completion_tokens": 167,
        "total_tokens": 835
      },
      "function_count": 2,
      "functions": [
        "price-mcp-server-Query cryptocurrency tool",
        "price-mcp-server-Steam Games Price Checker"
      ]
    },
    "Coinranking": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server includes a `configure_api_key` function that explicitly sets an API key for the session, which is a clear modification of persistent client-side or session-level configuration state. All other tools (e.g., `list_coins`, `get_coin`, `get_price_history`, etc.) likely depend on this configured API key to authenticate requests. Without calling `configure_api_key` first, subsequent function calls may fail due to lack of authentication, indicating a stateful dependency. This pattern—where one function establishes required context (authentication state) that affects the behavior of other functions—is a hallmark of stateful systems. While the API key might alternatively be provided per-request under the hood, the presence of a dedicated configuration function named \"configure\" implies session-scoped state setup.",
      "state_dependencies": [
        {
          "function_a": "configure_api_key",
          "function_b": "list_coins",
          "state_description": "API key set by configure_api_key is required for list_coins to authenticate and retrieve cryptocurrency data"
        },
        {
          "function_a": "configure_api_key",
          "function_b": "get_coin",
          "state_description": "API key set by configure_api_key is required for get_coin to authenticate and retrieve detailed coin data"
        },
        {
          "function_a": "configure_api_key",
          "function_b": "get_price_history",
          "state_description": "API key set by configure_api_key is required for get_price_history to authenticate and retrieve historical price data"
        },
        {
          "function_a": "configure_api_key",
          "function_b": "search",
          "state_description": "API key set by configure_api_key is required for search to authenticate and return results"
        },
        {
          "function_a": "configure_api_key",
          "function_b": "get_global_stats",
          "state_description": "API key set by configure_api_key is required for get_global_stats to authenticate and retrieve global market data"
        },
        {
          "function_a": "configure_api_key",
          "function_b": "list_exchanges",
          "state_description": "API key set by configure_api_key is required for list_exchanges to authenticate, especially since it 'requires Pro API key'"
        },
        {
          "function_a": "configure_api_key",
          "function_b": "get_coin_price",
          "state_description": "API key set by configure_api_key is required for get_coin_price to authenticate and return current price"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1969,
        "completion_tokens": 534,
        "total_tokens": 2503
      },
      "function_count": 11,
      "functions": [
        "coinranking-search",
        "coinranking-configure_api_key",
        "coinranking-get_reference_currencies",
        "coinranking-get_trending_coins",
        "coinranking-list_coins",
        "coinranking-get_coin_price",
        "coinranking-get_categories",
        "coinranking-get_global_stats",
        "coinranking-get_price_history",
        "coinranking-list_exchanges",
        "coinranking-get_coin"
      ]
    },
    "Sherlock MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Sherlock MCP Server provides two functions, `get_links` and `get_nsfw_links`, both of which perform independent searches using the underlying Sherlock OSINT tool. Neither function modifies any persistent state on the server—each call is self-contained and operates solely based on the input `username`. There is no indication that either function creates, updates, or deletes data that persists across calls, nor do they rely on configurations, sessions, or context established by prior invocations. Both functions are read-only in nature, querying external platforms for the presence of a username without storing results or altering system state. Additionally, while `get_nsfw_links` includes NSFW sites (a behavioral variation), this difference is static and built into the function's implementation rather than being driven by mutable state. No function depends on output or side effects from another, and there are no shared contexts or session mechanisms described in the interface.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 880,
        "completion_tokens": 209,
        "total_tokens": 1089
      },
      "function_count": 2,
      "functions": [
        "sherlock-mcp-server-get_nsfw_links",
        "sherlock-mcp-server-get_links"
      ]
    },
    "Playwright": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Playwright MCP server maintains a persistent browser context across function calls, which inherently makes it stateful. Multiple functions operate on the current page or browser state that is modified and shared across invocations. For example, `navigate` changes the current page context by loading a new URL, and subsequent calls to `get_all_content`, `get_visible_content`, or `get_interactive_elements` depend on the page loaded by the most recent `navigate` call. Similarly, actions like `move_mouse`, `mouse_click`, and `drag_and_drop` rely on the current page's layout and DOM structure, which are determined by prior navigation or interaction steps. This shared context—such as the currently open page, scroll position, mouse position, and element visibility—is preserved between function calls, indicating strong stateful behavior.",
      "state_dependencies": [
        {
          "function_a": "navigate",
          "function_b": "get_all_content",
          "state_description": "The page content retrieved by get_all_content depends on the URL loaded via navigate"
        },
        {
          "function_a": "navigate",
          "function_b": "get_visible_content",
          "state_description": "The visible content returned by get_visible_content is based on the page loaded by navigate and current viewport state"
        },
        {
          "function_a": "navigate",
          "function_b": "get_interactive_elements",
          "state_description": "The interactive elements detected depend on the DOM structure of the page loaded by navigate"
        },
        {
          "function_a": "navigate",
          "function_b": "mouse_click",
          "state_description": "Mouse click behavior depends on the elements present on the page loaded by navigate"
        },
        {
          "function_a": "mouse_wheel",
          "function_b": "get_visible_content",
          "state_description": "Scrolling via mouse_wheel changes which elements are visible, affecting the output of get_visible_content"
        },
        {
          "function_a": "mouse_wheel",
          "function_b": "get_interactive_elements",
          "state_description": "Scrolling can change element positions or trigger dynamic content loading, affecting interactive element detection"
        },
        {
          "function_a": "move_mouse",
          "function_b": "mouse_click",
          "state_description": "The location of the mouse click may depend on the last known mouse position set by move_mouse"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1428,
        "completion_tokens": 511,
        "total_tokens": 1939
      },
      "function_count": 9,
      "functions": [
        "playwright-get_all_content",
        "playwright-echo",
        "playwright-drag_and_drop",
        "playwright-get_interactive_elements",
        "playwright-mouse_click",
        "playwright-mouse_wheel",
        "playwright-move_mouse",
        "playwright-get_visible_content",
        "playwright-navigate"
      ]
    },
    "Macrostrat API Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Macrostrat API Server provides read-only access to geologic data through its available tools. All functions are query-based and do not include any operations that create, modify, or delete persistent state on the server (e.g., no \"create\", \"update\", \"delete\", or \"set\" type actions). Each function operates independently, taking explicit input parameters (such as coordinates, queries, or identifiers) and returning data without relying on prior interactions. There is no indication of shared context such as sessions, authentication tokens, configurations, or cached states that persist across requests. For example, calling `find-columns` does not alter the behavior of subsequent calls to `find-units`, as both rely solely on their input parameters and backend data sources rather than mutable internal state. Similarly, tools like `defs-autocomplete` and `mineral-info` are idempotent and state-independent. The absence of any write operations or session management strongly indicates a stateless design typical of RESTful APIs serving static or database-backed scientific data.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1238,
        "completion_tokens": 232,
        "total_tokens": 1470
      },
      "function_count": 6,
      "functions": [
        "macrostrat-api-server-timescale",
        "macrostrat-api-server-defs",
        "macrostrat-api-server-defs-autocomplete",
        "macrostrat-api-server-mineral-info",
        "macrostrat-api-server-find-units",
        "macrostrat-api-server-find-columns"
      ]
    },
    "Test Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server provides functions that modify persistent state (e.g., `create_user`) and other functions that retrieve or depend on that state (e.g., `find_user` and `find_all_users`). Specifically, calling `create_user` adds a new user to the database, which alters the system's persistent state. Subsequent calls to `find_user` with the same email can retrieve the created user, indicating dependence on prior state modifications. Similarly, `find_all_users` will return different results depending on how many users have been created, meaning its output is directly influenced by previous invocations of `create_user`. This clear pattern of write operations affecting the behavior and output of read operations demonstrates stateful behavior. Additionally, there are no indications that user data is stored temporarily or per-request; the terminology (\"database\") implies persistence across function calls.",
      "state_dependencies": [
        {
          "function_a": "create_user",
          "function_b": "find_user",
          "state_description": "User record created in the database by create_user can be retrieved by find_user using the email"
        },
        {
          "function_a": "create_user",
          "function_b": "find_all_users",
          "state_description": "Users added via create_user appear in the list returned by find_all_users"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1047,
        "completion_tokens": 287,
        "total_tokens": 1334
      },
      "function_count": 6,
      "functions": [
        "test-server-get_greeting",
        "test-server-get_crypto_price",
        "test-server-find_user",
        "test-server-get_binance_price",
        "test-server-find_all_users",
        "test-server-create_user"
      ]
    },
    "GDB MCP 服务器": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The GDB MCP 服务器 provides a set of tools that interact with running GDB processes, which are inherently stateful debugging sessions. Multiple tool functions require or affect the state of a GDB process identified by `gdb_pid`, indicating that the server maintains and depends on persistent execution context across function calls. For example, before executing most debugging operations (e.g., setting breakpoints, stepping, examining memory), a GDB session must first be established—either by starting a new one via `sys_start_gdb_with_remote` or attaching to an existing one via `sys_attach_to_gdb`. Once such a session exists, other functions like `gdb_execute_command`, `gdb_set_breakpoint`, and `gdb_get_stack` operate within that session's context. The presence of `gdb_pid` as an optional but widely shared parameter across many functions strongly suggests it is used to reference an ongoing debugging session. Without prior setup (launching or attaching), subsequent debug commands would have no target to act upon. This dependency chain confirms stateful behavior.",
      "state_dependencies": [
        {
          "function_a": "sys_start_gdb_with_remote",
          "function_b": "gdb_execute_command",
          "state_description": "A GDB process started by sys_start_gdb_with_remote creates a debugging session (identified by gdb_pid) that gdb_execute_command uses to send commands to the correct debugger instance."
        },
        {
          "function_a": "sys_attach_to_gdb",
          "function_b": "gdb_set_breakpoint",
          "state_description": "Attaching to a GDB process via sys_attach_to_gdb establishes an active session; gdb_set_breakpoint depends on this session being present and uses the attached gdb_pid to apply breakpoints in the correct context."
        },
        {
          "function_a": "gdb_set_breakpoint",
          "function_b": "gdb_continue",
          "state_description": "Breakpoints set by gdb_set_breakpoint persist in the GDB session and affect program behavior when gdb_continue resumes execution, potentially stopping at the breakpoint."
        },
        {
          "function_a": "sys_start_gdb_with_remote",
          "function_b": "gdb_connect_remote",
          "state_description": "Although both can initiate remote connections, gdb_connect_remote may depend on an already-started GDB session (created by sys_start_gdb_with_remote) to attach to a target, sharing the same gdb_pid context."
        },
        {
          "function_a": "gdb_execute_command",
          "function_b": "gdb_get_registers",
          "state_description": "Commands executed via gdb_execute_command (e.g., 'step', 'next') change the program state; subsequent calls to gdb_get_registers reflect updated register values from the modified execution state."
        },
        {
          "function_a": "gdb_step",
          "function_b": "gdb_get_stack",
          "state_description": "Executing gdb_step advances the program counter and possibly changes the call stack; gdb_get_stack then returns the updated stack trace reflecting the new execution point."
        }
      ],
      "token_usage": {
        "prompt_tokens": 2040,
        "completion_tokens": 654,
        "total_tokens": 2694
      },
      "function_count": 16,
      "functions": [
        "gdb-mcp-服务器-gdb_execute_command",
        "gdb-mcp-服务器-sys_attach_to_gdb",
        "gdb-mcp-服务器-gdb_next",
        "gdb-mcp-服务器-gdb_finish",
        "gdb-mcp-服务器-gdb_examine_memory",
        "gdb-mcp-服务器-gdb_get_locals",
        "gdb-mcp-服务器-gdb_set_breakpoint",
        "gdb-mcp-服务器-gdb_continue",
        "gdb-mcp-服务器-gdb_get_stack",
        "gdb-mcp-服务器-gdb_disassemble",
        "gdb-mcp-服务器-gdb_delete_breakpoint",
        "gdb-mcp-服务器-sys_start_gdb_with_remote",
        "gdb-mcp-服务器-gdb_step",
        "gdb-mcp-服务器-gdb_get_registers",
        "gdb-mcp-服务器-gdb_connect_remote",
        "gdb-mcp-服务器-sys_find_gdb_processes"
      ]
    },
    "Bible Verse Access Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the Bible Verse Access Server are read-only operations that retrieve data without modifying any persistent state. There are no functions that create, update, or delete resources (e.g., no user sessions, cached configurations, stored preferences, or mutable data). Each function operates independently and returns results based solely on input parameters or static data sources. For example:\n- `get_random_bible_verse` selects a random verse, optionally filtered by book or testament, but does not alter any internal state.\n- `get_bible_verse` retrieves a specific verse based on reference and translation, with default values used if unspecified.\n- `list_bible_translations`, `list_bible_books`, and `list_bible_chapters` provide metadata about available content and are purely informational.\n\nNo function depends on side effects from another function call. All parameters are explicitly passed, and there is no indication of shared context, session state, or configuration that persists across requests. The server behaves like a stateless API where each request is self-contained.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1132,
        "completion_tokens": 234,
        "total_tokens": 1366
      },
      "function_count": 5,
      "functions": [
        "bible-verse-access-server-get_bible_verse",
        "bible-verse-access-server-get_random_bible_verse",
        "bible-verse-access-server-list_bible_translations",
        "bible-verse-access-server-list_bible_books",
        "bible-verse-access-server-list_bible_chapters"
      ]
    },
    "QR Code Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "qr-code-server-generate-qrcode"
      ]
    },
    "Suricata Network Traffic Analysis Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The available functions in the Suricata Network Traffic Analysis Server do not appear to modify or depend on shared persistent state across calls. Each function operates independently and performs a self-contained operation:\n\n1. **State Modification**: None of the functions explicitly create, update, or delete global or session-based state that persists beyond the scope of a single function call. The `get_alerts_from_pcap_file` and `get_stats_from_pcap_file` functions process a PCAP file and read output logs (`fast.log`, `stats.log`) from a specified directory, but they do so in a way that depends only on input parameters (file paths) and not on prior function invocations.\n\n2. **State Dependency**: There is no indication that `get_suricata_version` or `get_suricata_help` alter any configuration or context used by other functions. These are pure read operations that return static information about the Suricata installation.\n\n3. **Function Pairs & Shared Context**: While both `get_alerts_from_pcap_file` and `get_stats_from_pcap_file` run Suricata on a PCAP file and write results to a destination folder, they generate separate log files (`fast.log` vs `stats.log`). One function does not rely on the output or side effects of the other. Even if both functions write to the same `destination_folder_results`, they do not require each other's presence or prior execution — each invokes Suricata independently.\n\n4. **No Shared Sessions or Configurations**: There is no evidence of session tokens, configuration flags, or runtime settings being stored server-side between calls. All necessary context (e.g., file paths) is passed explicitly as parameters.\n\nAlthough there is a minor possibility that concurrent access to the same `destination_folder_results` could cause interference (e.g., overwriting files), this would constitute a race condition rather than intentional statefulness. The design appears to be stateless with respect to inter-function dependencies.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1093,
        "completion_tokens": 423,
        "total_tokens": 1516
      },
      "function_count": 4,
      "functions": [
        "suricata-network-traffic-analysis-server-get_suricata_version",
        "suricata-network-traffic-analysis-server-get_stats_from_pcap_file",
        "suricata-network-traffic-analysis-server-get_alerts_from_pcap_file",
        "suricata-network-traffic-analysis-server-get_suricata_help"
      ]
    },
    "EVE Online Market Data Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server includes authentication-related functions (`get-auth-url`, `authenticate`, and `refresh-token`) that establish and manage user sessions via OAuth2. Specifically, `authenticate` exchanges an authorization code for an access token, which implies the creation of a session or authentication context that subsequent API calls may depend on (even if not explicitly shown in other tool parameters). Furthermore, `refresh-token` allows renewing an expired access token using a refresh token—this directly indicates persistence of authentication state across function calls. Although most tools (e.g., `get-market-orders`, `get-structure-orders`) do not explicitly require authentication parameters, their ability to return protected market data would logically depend on prior successful authentication. This suggests that the server maintains session or authentication state set by `authenticate` and refreshed by `refresh-token`, which affects the behavior of other tools. Therefore, there is clear evidence of stateful behavior through shared authentication context.",
      "state_dependencies": [
        {
          "function_a": "authenticate",
          "function_b": "get-structure-orders",
          "state_description": "Authentication state (access token) established by 'authenticate' is required for accessing protected structure order data in 'get-structure-orders'"
        },
        {
          "function_a": "authenticate",
          "function_b": "get-market-orders",
          "state_description": "Authentication state (access token) established by 'authenticate' may be required for accessing restricted region market data"
        },
        {
          "function_a": "refresh-token",
          "function_b": "authenticate",
          "state_description": "Refresh token issued during prior authentication is used by 'refresh-token' to maintain persistent access, indicating ongoing session state"
        },
        {
          "function_a": "get-auth-url",
          "function_b": "authenticate",
          "state_description": "OAuth2 'state' parameter generated by 'get-auth-url' should be validated during 'authenticate' to prevent CSRF, implying state must be retained between calls"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1710,
        "completion_tokens": 426,
        "total_tokens": 2136
      },
      "function_count": 10,
      "functions": [
        "eve-online-market-data-server-get-auth-url",
        "eve-online-market-data-server-refresh-token",
        "eve-online-market-data-server-get-structure-type-orders",
        "eve-online-market-data-server-get-market-history",
        "eve-online-market-data-server-authenticate",
        "eve-online-market-data-server-get-market-prices",
        "eve-online-market-data-server-get-market-groups",
        "eve-online-market-data-server-get-market-orders",
        "eve-online-market-data-server-get-structure-orders",
        "eve-online-market-data-server-get-market-stats"
      ]
    },
    "Food Tracker": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior because several functions modify persistent user-specific state, and other functions depend on that modified state to alter their behavior or output. Specifically:\n\n- `manage_user_restrictions` modifies a user's dietary restrictions (e.g., adding an allergen like \"peanuts\" with severity \"avoid\"). This is a write operation that changes the user’s profile.\n- `check_product_compatibility` depends on the restrictions set by `manage_user_restrictions` to determine whether a product is safe for the user. Its output will vary based on prior calls to manage restrictions.\n- `log_food_consumption` writes data to the user’s food log, modifying persistent state associated with the user and date.\n- `get_user_food_log` retrieves this logged data, meaning its output directly depends on previous calls to `log_food_consumption`.\n- Additionally, while `analyze_nutrition` and `get_product_by_barcode` appear stateless (they operate solely on product barcode), the overall system maintains user-level context through logs and restrictions.\n\nThese dependencies confirm that the server maintains and uses shared state across multiple function calls, particularly at the user level, which is characteristic of a stateful system.",
      "state_dependencies": [
        {
          "function_a": "manage_user_restrictions",
          "function_b": "check_product_compatibility",
          "state_description": "User's dietary restrictions (e.g., allergens, diets) set by manage_user_restrictions are used by check_product_compatibility to evaluate product safety."
        },
        {
          "function_a": "log_food_consumption",
          "function_b": "get_user_food_log",
          "state_description": "Food items logged via log_food_consumption are stored in the user's food log and retrieved by get_user_food_log for a given date."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1800,
        "completion_tokens": 393,
        "total_tokens": 2193
      },
      "function_count": 7,
      "functions": [
        "food-tracker-log_food_consumption",
        "food-tracker-get_user_food_log",
        "food-tracker-search_products",
        "food-tracker-manage_user_restrictions",
        "food-tracker-analyze_nutrition",
        "food-tracker-check_product_compatibility",
        "food-tracker-get_product_by_barcode"
      ]
    },
    "Mapas Mentais Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "All available tools in the \"Mapas Mentais Server\" are generative functions that produce mind maps for specific purposes (e.g., comparison, review, problem analysis, presentation, or knowledge level). Each function takes a topic (or two topics) as input and generates an output independently. There is no indication in the tool descriptions or parameters that any of these functions:  \n1. Modify persistent state (e.g., no create, update, or delete operations on server-side resources),  \n2. Depend on prior function calls (e.g., no requirement for a session, configuration, or stored data from another call),  \n3. Share context such as sessions, configurations, or intermediate data across invocations.  \n\nAll functions appear to be stateless transformations—given a topic, they generate a corresponding mind map without relying on or altering global or session-scoped state. Without evidence of side effects or inter-function dependencies, the server behaves in a stateless manner.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1041,
        "completion_tokens": 219,
        "total_tokens": 1260
      },
      "function_count": 6,
      "functions": [
        "mapas-mentais-server-intermediario",
        "mapas-mentais-server-problemas",
        "mapas-mentais-server-compara",
        "mapas-mentais-server-inicial",
        "mapas-mentais-server-revisa",
        "mapas-mentais-server-apresenta"
      ]
    },
    "Lorenz Woehr Portfolio": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available functions in the Lorenz Woehr Portfolio MCP server are read-only operations that retrieve static information (profile, projects, specific project by slug, contact details). None of the functions perform create, update, delete, or configuration-setting actions that would modify persistent state. There is no indication that the output of any function depends on prior function calls—for example, retrieving a project by slug does not require prior invocation of get_projects, and no session, context, or configuration appears to be established or modified during usage. The absence of any state-modifying operations or interdependencies between function calls confirms that this server is stateless.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 629,
        "completion_tokens": 150,
        "total_tokens": 779
      },
      "function_count": 4,
      "functions": [
        "lorenz-woehr-portfolio-get_profile",
        "lorenz-woehr-portfolio-get_projects",
        "lorenz-woehr-portfolio-get_project_by_slug",
        "lorenz-woehr-portfolio-get_contact"
      ]
    },
    "Fetch MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the Fetch MCP Server are read-only operations that retrieve content from a given URL in different formats (HTML, Markdown, plain text, JSON). None of the functions perform create, update, or delete operations, nor do they modify any persistent state on the server side. Each function operates independently, taking only input parameters (such as URL, headers, max_length, and start_index) and returning fetched content without storing or altering shared context, sessions, or configurations. There is no indication that calling one function affects the behavior or output of another. The tools do not share mutable state across calls, and each request appears to be stateless and idempotent.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1132,
        "completion_tokens": 161,
        "total_tokens": 1293
      },
      "function_count": 4,
      "functions": [
        "fetch-mcp-server-fetch_json",
        "fetch-mcp-server-fetch_html",
        "fetch-mcp-server-fetch_markdown",
        "fetch-mcp-server-fetch_txt"
      ]
    },
    "Bitcoin SV Tools Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available tools in the Bitcoin SV Tools Server, there is no evidence of stateful behavior. All functions are read-only or data-transformation operations that do not create, modify, or delete persistent server-side state. Specifically:\n\n- **bsv_getPrice**: Retrieves real-time BSV price; purely an external API fetch with no internal state modification.\n- **bsv_decodeTransaction**: Decodes transaction data provided as input; operates entirely on supplied parameters without storing or altering state.\n- **bsv_explore**: Queries blockchain data via the WhatsOnChain API; all endpoints are read-only and require explicit parameters (e.g., txHash, address) to retrieve data.\n- **ordinals_getInscription**, **ordinals_searchInscriptions**, **ordinals_marketListings**, **ordinals_marketSales**, **ordinals_getTokenByIdOrTicker**: These are all query-based tools that retrieve ordinal or marketplace data from external sources based solely on input parameters. They do not alter any system state.\n- **utils_convertData**: Performs deterministic, stateless encoding conversions between formats (hex, base64, etc.) with no side effects.\n\nNone of the functions establish sessions, set configurations, store data, or depend on prior function calls. Each call is independent and idempotent. There are no function pairs where one sets up context (like a session or wallet) that another later depends on. All outputs depend only on inputs, not on shared mutable state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 4365,
        "completion_tokens": 322,
        "total_tokens": 4687
      },
      "function_count": 9,
      "functions": [
        "bitcoin-sv-tools-server-bsv_decodeTransaction",
        "bitcoin-sv-tools-server-ordinals_searchInscriptions",
        "bitcoin-sv-tools-server-ordinals_marketListings",
        "bitcoin-sv-tools-server-ordinals_marketSales",
        "bitcoin-sv-tools-server-bsv_explore",
        "bitcoin-sv-tools-server-ordinals_getInscription",
        "bitcoin-sv-tools-server-bsv_getPrice",
        "bitcoin-sv-tools-server-ordinals_getTokenByIdOrTicker",
        "bitcoin-sv-tools-server-utils_convertData"
      ]
    },
    "Math Operations Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Math Operations Server provides two functions, `add` and `multiply`, both of which are pure mathematical operations. These functions take two integer inputs and return a result based solely on those inputs, with no indication of internal state modification or persistence. There are no operations that create, update, or delete any system-level state (such as configurations, sessions, or stored data). Furthermore, neither function depends on the outcome or side effects of the other. Each call is independent and idempotent, meaning repeated calls with the same inputs will always produce the same outputs without any side effects. There is no shared context, session, or configuration that persists across function calls. Therefore, there is no evidence of stateful behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 717,
        "completion_tokens": 169,
        "total_tokens": 886
      },
      "function_count": 2,
      "functions": [
        "math-operations-server-add",
        "math-operations-server-multiply"
      ]
    },
    "Weather Calculator": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The three available functions — `calculate`, `get_weather`, and `get_exchange_rates` — are all stateless in nature. Each function performs an independent query or computation without modifying any persistent system state. Specifically:  \n- `calculate` evaluates a mathematical expression and returns a result; it does not store or alter any data between calls.  \n- `get_weather` retrieves current weather for a specified city; it is a read-only operation dependent only on external weather data, not on prior function calls.  \n- `get_exchange_rates` fetches current USD exchange rates, optionally with a base currency override. Even though it has a default base currency (USD), this is a static default value, not a mutable configuration that persists across requests. There is no indication that setting a base currency in one call affects future calls unless explicitly provided.  \n\nThere are no create, update, or delete operations, nor any session management, shared context, or configuration storage mechanisms exposed in the tool definitions. All functions appear to be idempotent and independent, with no observable side effects or interdependencies.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 721,
        "completion_tokens": 244,
        "total_tokens": 965
      },
      "function_count": 3,
      "functions": [
        "weather-calculator-get_weather",
        "weather-calculator-calculate",
        "weather-calculator-get_exchange_rates"
      ]
    },
    "JSON MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The JSON MCP Server provides two tools—`split` and `merge`—that operate on JSON files via file system paths. The `split` function modifies persistent state by taking a JSON file at a given `path` and splitting it into multiple objects, which implies writing new data or altering the structure of existing files (or creating new ones) in the file system. The `merge` function also operates on a `path`, implying it reads from or combines JSON files located there, likely depending on the presence or structure of files that could have been altered by a prior `split` operation. Since both functions access and potentially modify shared resources (i.e., JSON files at specified paths), the behavior of `merge` can be affected by a previous call to `split` if they operate on overlapping or related file paths. This creates a state dependency through the shared file system state. Although the exact side effects are not detailed, the nature of split/merge operations on persistent file paths strongly suggests stateful interaction.",
      "state_dependencies": [
        {
          "function_a": "split",
          "function_b": "merge",
          "state_description": "The 'split' function may divide a JSON file into multiple parts at a given path; subsequent 'merge' operations on the same or related paths may depend on the resulting file structure or existence of split output files."
        }
      ],
      "token_usage": {
        "prompt_tokens": 691,
        "completion_tokens": 300,
        "total_tokens": 991
      },
      "function_count": 2,
      "functions": [
        "json-mcp-server-merge",
        "json-mcp-server-split"
      ]
    },
    "AI Agent with MCP": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Based on the provided tool descriptions, none of the functions appear to modify persistent state that affects the behavior of other functions. The \"Hello Tool\" is a simple response generator with no side effects. The \"Users Tool\" fetches data from an external API but does not indicate any mutation (e.g., creating or updating users), nor does it suggest dependency on prior function calls. The \"Textract Tool\" sends an image for analysis, which may involve transient processing state, but there is no indication that this state persists or influences subsequent calls to itself or other tools. There is no evidence of shared context, sessions, configurations, or data storage across function invocations. All functions seem to operate independently and idempotently based on their inputs and external systems, without maintaining internal server-side state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 633,
        "completion_tokens": 186,
        "total_tokens": 819
      },
      "function_count": 3,
      "functions": [
        "ai-agent-with-mcp-Hello Tool",
        "ai-agent-with-mcp-Users Tool",
        "ai-agent-with-mcp-Textract Tool"
      ]
    },
    "Emoji Hub Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Emoji Hub Server provides only read-only operations for retrieving emojis, either randomly or in bulk, filtered by category or group. None of the available tools perform create, update, delete, or configuration-setting actions that would modify server state. All functions are independent and do not rely on prior function calls to influence their behavior or output. There is no indication of shared context, sessions, configurations, or persistent data modifications across tool invocations. Each function call retrieves data directly based on input parameters without dependency on prior interactions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1196,
        "completion_tokens": 128,
        "total_tokens": 1324
      },
      "function_count": 6,
      "functions": [
        "emoji-hub-server-get_random_emoji_tool",
        "emoji-hub-server-get_random_emoji_by_category_tool",
        "emoji-hub-server-get_emojis_by_group_tool",
        "emoji-hub-server-get_emojis_by_category_tool",
        "emoji-hub-server-get_random_emoji_by_group_tool",
        "emoji-hub-server-get_all_emojis_tool"
      ]
    },
    "Paper Search": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits stateful behavior due to dependencies between download and read functions that rely on the existence of a downloaded PDF file in persistent storage. Specifically, the `read_arxiv_paper`, `read_biorxiv_paper`, and `read_medrxiv_paper` functions attempt to extract text from a paper's PDF, but they do not independently ensure the PDF is present. Instead, they depend on prior execution of their corresponding download functions (`download_arxiv`, `download_biorxiv`, `download_medrxiv`) to place the PDF in the expected directory (default: `./downloads`). While these read functions may trigger a download if the file is missing, their correct and efficient operation assumes prior state — namely, the presence of the PDF file — established by a previous function call. This creates a state dependency where the outcome or performance of the read operation is affected by earlier actions.\n\nAdditionally, although `save_path` is configurable, the default path is shared across tools, reinforcing the assumption of a shared filesystem state. The fact that `read_pubmed_paper` explicitly states it does not support direct reading further highlights that for other platforms (arXiv, bioRxiv, medRxiv), the system expects a side effect (file download) to have occurred — a hallmark of stateful interaction.",
      "state_dependencies": [
        {
          "function_a": "download_arxiv",
          "function_b": "read_arxiv_paper",
          "state_description": "The PDF file of an arXiv paper is saved to disk by download_arxiv; read_arxiv_paper depends on this file being present at the specified save_path to extract text."
        },
        {
          "function_a": "download_biorxiv",
          "function_b": "read_biorxiv_paper",
          "state_description": "The PDF file of a bioRxiv paper is saved to disk by download_biorxiv; read_biorxiv_paper depends on this file being present at the specified save_path to extract text."
        },
        {
          "function_a": "download_medrxiv",
          "function_b": "read_medrxiv_paper",
          "state_description": "The PDF file of a medRxiv paper is saved to disk by download_medrxiv; read_medrxiv_paper depends on this file being present at the specified save_path to extract text."
        }
      ],
      "token_usage": {
        "prompt_tokens": 2582,
        "completion_tokens": 500,
        "total_tokens": 3082
      },
      "function_count": 13,
      "functions": [
        "paper-search-search_google_scholar",
        "paper-search-read_medrxiv_paper",
        "paper-search-search_pubmed",
        "paper-search-search_biorxiv",
        "paper-search-search_medrxiv",
        "paper-search-download_biorxiv",
        "paper-search-download_pubmed",
        "paper-search-read_arxiv_paper",
        "paper-search-read_pubmed_paper",
        "paper-search-download_medrxiv",
        "paper-search-read_biorxiv_paper",
        "paper-search-search_arxiv",
        "paper-search-download_arxiv"
      ]
    },
    "Minecraft Wiki Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available tools in the \"Minecraft Wiki Server\" MCP are read-only operations that retrieve information from the Minecraft Wiki. None of the functions perform create, update, delete, or modify operations on any persistent state. Each function operates independently based on input parameters (e.g., page title, query, category) and does not alter server-side state such as configurations, sessions, or stored data. Furthermore, no function requires or depends on prior function calls to succeed—any dependencies between functions (e.g., using `MinecraftWiki_searchWiki` before `MinecraftWiki_getPageSummary`) are logical workflow recommendations for efficient use, not technical state dependencies. The server does not maintain shared context, sessions, or configurations across calls. Therefore, there is no evidence of stateful behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1524,
        "completion_tokens": 182,
        "total_tokens": 1706
      },
      "function_count": 9,
      "functions": [
        "minecraft-wiki-server-MinecraftWiki_getCategoriesForPage",
        "minecraft-wiki-server-MinecraftWiki_getPageSummary",
        "minecraft-wiki-server-MinecraftWiki_getPageContent",
        "minecraft-wiki-server-MinecraftWiki_listCategoryMembers",
        "minecraft-wiki-server-MinecraftWiki_getSectionsInPage",
        "minecraft-wiki-server-MinecraftWiki_getPageSection",
        "minecraft-wiki-server-MinecraftWiki_listAllCategories",
        "minecraft-wiki-server-MinecraftWiki_searchWiki",
        "minecraft-wiki-server-MinecraftWiki_resolveRedirect"
      ]
    },
    "AIM Guard": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "After analyzing the three available tools in the AIM Guard MCP server, there is no evidence of stateful behavior. Each tool operates independently and does not modify or rely on persistent state across function calls:\n\n1. **ai-safety-guard**: This tool generates caution instructions based on input parameters (mcp_type, operation_type, sensitivity_level). It does not store or modify any system state; it is purely a deterministic generator of security guidance based on inputs.\n\n2. **aim-text-guard**: This tool analyzes provided text for harmful content. It takes a string input and returns an analysis. There is no indication that it stores the text, retains results, or modifies any global or session-based state. The analysis is self-contained within the call.\n\n3. **aim-security-prompt-tool**: This tool enhances a user prompt with security instructions based on the provided security_level. Like the others, it transforms input into output without creating, updating, or depending on prior state.\n\nNone of the functions perform create/update/delete operations that persist beyond the scope of a single invocation. There are no shared contexts, sessions, or configurations established by one function and used by another. All outputs depend solely on inputs to each individual function call, with no side effects or cross-function dependencies.\n\nAdditionally, the descriptions and parameter schemas do not mention any session tokens, configuration flags, or contextual memory mechanisms that would imply statefulness.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 995,
        "completion_tokens": 303,
        "total_tokens": 1298
      },
      "function_count": 3,
      "functions": [
        "aim-guard-aim-text-guard",
        "aim-guard-ai-safety-guard",
        "aim-guard-aim-security-prompt-tool"
      ]
    },
    "Desktop TXT File Manager": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior due to the interaction between file-modifying and file-querying operations. Specifically, the `create_desktop_txt_file` function modifies persistent state by creating a new `.txt` file on the desktop, which directly affects the results of subsequent calls to `count_desktop_txt_files` and `list_desktop_txt_files`. These latter functions depend on the current state of the filesystem (i.e., which `.txt` files exist), meaning their output will change based on prior invocations of `create_desktop_txt_file`. This creates a dependency where the outcome of listing or counting files is influenced by previous actions, indicating statefulness. Additionally, since the created files persist on the desktop (a shared, external state), this state survives across function calls and sessions, reinforcing the stateful nature of the server.",
      "state_dependencies": [
        {
          "function_a": "create_desktop_txt_file",
          "function_b": "count_desktop_txt_files",
          "state_description": "The number of .txt files returned by count_desktop_txt_files increases when create_desktop_txt_file successfully creates a new file."
        },
        {
          "function_a": "create_desktop_txt_file",
          "function_b": "list_desktop_txt_files",
          "state_description": "The list of filenames returned by list_desktop_txt_files includes newly created files from prior calls to create_desktop_txt_file."
        }
      ],
      "token_usage": {
        "prompt_tokens": 840,
        "completion_tokens": 314,
        "total_tokens": 1154
      },
      "function_count": 4,
      "functions": [
        "desktop-txt-file-manager-count_desktop_txt_files",
        "desktop-txt-file-manager-list_desktop_txt_files",
        "desktop-txt-file-manager-get_alerts",
        "desktop-txt-file-manager-create_desktop_txt_file"
      ]
    },
    "Context7": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits stateful behavior due to a required dependency between `resolve-library-id` and `get-library-docs`. Specifically, `resolve-library-id` must be called first to obtain a Context7-compatible library ID unless the user explicitly provides one. This means that `get-library-docs` depends on the output (i.e., resolved library ID) from a prior call to `resolve-library-id` when such an ID is not provided upfront. This creates a form of contextual state where the successful execution of `get-library-docs` in many cases relies on the preceding resolution step, which establishes valid input for it. Although no explicit persistent storage or session creation is mentioned, the functional workflow enforces a stateful sequence: the system maintains transient context (the resolved library ID) across function calls to ensure correctness and toolchain integrity. This shared context—especially the requirement to resolve IDs before fetching documentation—constitutes stateful interaction.",
      "state_dependencies": [
        {
          "function_a": "resolve-library-id",
          "function_b": "get-library-docs",
          "state_description": "The Context7-compatible library ID resolved by 'resolve-library-id' is required as input for 'get-library-docs' when the user does not explicitly provide it. This creates a state dependency where the output of the first function determines the correct operation of the second."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1111,
        "completion_tokens": 300,
        "total_tokens": 1411
      },
      "function_count": 5,
      "functions": [
        "context7-get-library-docs",
        "context7-resolve-library-id",
        "context7-get-library-docs",
        "context7-resolve-library-id",
        "context7-get-library-docs"
      ]
    },
    "Brasil API": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Brasil API are read-only operations that retrieve public data from external systems (e.g., postal codes, company registrations, bank information, exchange rates). None of the functions perform create, update, or delete operations that would modify persistent server-side state. Each function call is self-contained and does not rely on prior interactions. For example, calling `cep-search` does not alter any configuration or session that would affect the outcome of a subsequent `cnpj-search`. There is no evidence of shared context such as authentication sessions, cached user data, or transactional state being maintained across requests. The absence of any write-capable endpoints (like registration, login, or state initialization) further supports the conclusion that this MCP server operates in a stateless manner.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1617,
        "completion_tokens": 180,
        "total_tokens": 1797
      },
      "function_count": 11,
      "functions": [
        "brasil-api-ibge-state-search",
        "brasil-api-ddd-info",
        "brasil-api-cambio-currencies-list",
        "brasil-api-cambio-rate",
        "brasil-api-bank-search",
        "brasil-api-registrobr-domain-check",
        "brasil-api-ibge-states-list",
        "brasil-api-ibge-municipalities-list",
        "brasil-api-bank-list",
        "brasil-api-cnpj-search",
        "brasil-api-cep-search"
      ]
    },
    "Met Museum Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "After analyzing the available tools in the Met Museum Server, there is no evidence of stateful behavior. None of the functions perform create, update, or delete operations that would modify persistent server-side state. All functions are read-only and idempotent:  \n- `list-departments` retrieves a static list of departments without altering any configuration or data.  \n- `search-museum-objects` performs a query against the museum's collection based on input parameters but does not store or modify any state.  \n- `get-museum-object` fetches a specific object by ID and optionally returns its image; while it may add an image to \"server resources\" when `returnImage=true`, this appears to be a transient side effect for client rendering rather than a modification of persistent server state accessible across future calls.  \n\nThere is no indication that calling one function changes the behavior or output of another. The use of `departmentId` from `list-departments` in `search-museum-objects` represents logical workflow usage (client-side reference), not server-enforced state dependency. Similarly, retrieving an `objectId` via search before using `get-museum-object` is a natural data flow, not a stateful coupling enforced by the server. No sessions, configurations, or contexts are established or maintained across requests.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1003,
        "completion_tokens": 291,
        "total_tokens": 1294
      },
      "function_count": 3,
      "functions": [
        "met-museum-server-search-museum-objects",
        "met-museum-server-list-departments",
        "met-museum-server-get-museum-object"
      ]
    },
    "PubMed Article Search and Analysis Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The provided tools in the PubMed Article Search and Analysis Server are purely retrieval and search operations. None of the functions perform create, update, or delete actions that would modify persistent state on the server. Specifically:  \n- `search_pubmed_key_words` and `search_pubmed_advanced` are read-only search functions that return article results based on input parameters without storing any data or altering configurations.  \n- `get_pubmed_article_metadata` retrieves metadata for a given PMID; it does not depend on prior function calls and requires only the PMID as input.  \n- `download_pubmed_pdf` requests a PDF download for a specific PMID, again relying solely on the provided identifier with no indication of session creation or state modification.  \n\nThere is no evidence of shared context, sessions, stored configurations, or side effects that persist across calls. Each function operates independently and idempotently, depending only on its input parameters rather than any external mutable state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1186,
        "completion_tokens": 215,
        "total_tokens": 1401
      },
      "function_count": 4,
      "functions": [
        "pubmed-article-search-and-analysis-server-get_pubmed_article_metadata",
        "pubmed-article-search-and-analysis-server-search_pubmed_advanced",
        "pubmed-article-search-and-analysis-server-download_pubmed_pdf",
        "pubmed-article-search-and-analysis-server-search_pubmed_key_words"
      ]
    },
    "Google Scholar Search Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The Google Scholar Search Server provides three tools: two for searching academic papers (via keywords or advanced criteria) and one for retrieving author information. None of the functions imply modification of persistent state — all appear to be read-only operations that retrieve data based on input parameters. The search functions do not create, update, or delete any system state, and the get_author_info function operates independently by querying information based on an author name. There is no indication that calling one function alters configuration, establishes sessions, or stores data that would influence the behavior of subsequent calls. Each function call is self-contained and idempotent, depending only on its input parameters rather than shared context or prior interactions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 886,
        "completion_tokens": 162,
        "total_tokens": 1048
      },
      "function_count": 5,
      "functions": [
        "google-scholar-search-server-search_google_scholar_key_words",
        "google-scholar-search-server-search_google_scholar_advanced",
        "google-scholar-search-server-search_google_scholar_key_words",
        "google-scholar-search-server-search_google_scholar_advanced",
        "google-scholar-search-server-get_author_info"
      ]
    },
    "Cultural Heritage Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "All available functions in the Cultural Heritage Server are read-only operations that do not modify any persistent state. There are no indications of create, update, or delete operations. Each function operates independently based on its input parameters and does not rely on prior side effects from other function calls. Specifically:  \n- `search_cultural_heritage` performs a query based solely on the provided search term and limit.  \n- `get_artwork_details` retrieves information using only the given artwork ID.  \n- `get_collections_by_institution` returns data based exclusively on the institution name.  \n- `get_cultural_recommendations` generates results based purely on the user interest string, with no evidence of maintaining or updating user profiles or historical context across calls.  \n\nThere is no shared session, configuration, or stored context between function invocations. No function requires or benefits from a preceding call to set up state. Therefore, there is no observable stateful behavior in this tool set.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1039,
        "completion_tokens": 220,
        "total_tokens": 1259
      },
      "function_count": 4,
      "functions": [
        "cultural-heritage-server-get_cultural_recommendations",
        "cultural-heritage-server-get_artwork_details",
        "cultural-heritage-server-search_cultural_heritage",
        "cultural-heritage-server-get_collections_by_institution"
      ]
    },
    "Collaborative Reasoning Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "collaborative-reasoning-server-collaborativeReasoning"
      ]
    },
    "OKX Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "Both available functions, `get_price` and `get_candlesticks`, are read-only operations that retrieve real-time or historical market data from the OKX exchange. Neither function performs any modification of system state such as setting configurations, creating sessions, storing data, or updating resources. There is no indication that calling one function affects the behavior or output of the other. Both functions operate independently, requiring only an `instrument` parameter (and optional `bar` and `limit` for candlesticks), with no shared mutable context, session, or configuration that persists across calls. The server appears to provide stateless access to public market data, where each request is self-contained and does not rely on prior interactions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 728,
        "completion_tokens": 167,
        "total_tokens": 895
      },
      "function_count": 2,
      "functions": [
        "okx-server-get_candlesticks",
        "okx-server-get_price"
      ]
    },
    "Sci-Hub MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Sci-Hub MCP Server are read-only operations that retrieve data based on explicit input parameters (e.g., DOI, title, keyword, PDF URL). None of the functions perform create, update, or delete operations that would modify persistent state on the server. Each function operates independently and does not rely on prior function calls to succeed. For example:\n- `search_scihub_by_doi`, `search_scihub_by_title`, and `search_scihub_by_keyword` return search results based solely on their input and do not store or alter any system state.\n- `get_paper_metadata` retrieves metadata using only the provided DOI, with no dependency on previous calls.\n- `download_scihub_pdf` downloads a PDF from a given URL to a specified path; it uses no internal state set by other functions and its behavior is fully determined by its arguments.\n\nThere is no evidence of shared context such as sessions, authentication tokens, cached configurations, or stored data that persist across calls. The server appears to act as a stateless facade over external Sci-Hub services, where each request is self-contained and idempotent.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 925,
        "completion_tokens": 257,
        "total_tokens": 1182
      },
      "function_count": 5,
      "functions": [
        "sci-hub-mcp-server-search_scihub_by_doi",
        "sci-hub-mcp-server-download_scihub_pdf",
        "sci-hub-mcp-server-search_scihub_by_keyword",
        "sci-hub-mcp-server-search_scihub_by_title",
        "sci-hub-mcp-server-get_paper_metadata"
      ]
    },
    "PubChem Data Access Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The PubChem Data Access Server provides read-only access to chemical and bioassay data through its available tools. All functions—`search_compound`, `get_compound_details`, `get_compound_properties`, `search_bioassay`, and `get_substance_details`—are idempotent retrieval operations that do not create, modify, or delete any system state. Each function call is independent and depends only on the input parameters (e.g., query string, CID, SID), not on any prior interactions with the server. There are no indications of session management, configuration settings, authentication tokens, or cached states that persist across requests. Since no function modifies persistent state and no function's behavior is influenced by previous calls, the server exhibits purely stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1158,
        "completion_tokens": 179,
        "total_tokens": 1337
      },
      "function_count": 5,
      "functions": [
        "pubchem-data-access-server-get_compound_details",
        "pubchem-data-access-server-search_bioassay",
        "pubchem-data-access-server-get_substance_details",
        "pubchem-data-access-server-get_compound_properties",
        "pubchem-data-access-server-search_compound"
      ]
    },
    "Semantic Scholar Academic Research MCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available tools in the Semantic Scholar Academic Research MCP server are read-only operations that retrieve data based on explicit input parameters (e.g., query strings, paper IDs, author IDs). None of the functions perform create, update, or delete operations that would modify persistent state on the server. Each function call is independent and does not rely on or alter any shared context, session, configuration, or internal state that could affect subsequent calls. For example, `search_semantic_scholar` returns results purely based on the provided query and number of results, with no indication that calling it changes how `get_semantic_scholar_paper_details` behaves later. Similarly, recommendation functions like `get_semantic_scholar_paper_recommendations_from_lists` take all necessary inputs (positive/negative paper IDs) directly as arguments and do not depend on prior side-effecting calls. There is no evidence of session management, cached contexts, or stateful configurations across tool invocations. Therefore, the server exhibits purely stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2372,
        "completion_tokens": 229,
        "total_tokens": 2601
      },
      "function_count": 12,
      "functions": [
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_paper_autocomplete",
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_paper_match",
        "semantic-scholar-academic-research-mcp-search_semantic_scholar_authors",
        "semantic-scholar-academic-research-mcp-search_semantic_scholar",
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_paper_recommendations",
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_paper_recommendations_from_lists",
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_author_details",
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_paper_details",
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_authors_batch",
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_papers_batch",
        "semantic-scholar-academic-research-mcp-search_semantic_scholar_snippets",
        "semantic-scholar-academic-research-mcp-get_semantic_scholar_citations_and_references"
      ]
    },
    "BioMCP": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After thorough analysis of all nine tools provided by the BioMCP server, no evidence of stateful behavior is present. All functions are read-only operations that retrieve data from external biomedical databases (e.g., PubMed, ClinicalTrials.gov, MyVariant.info, PubTator3) based solely on input parameters. None of the functions perform create, update, or delete operations that would modify persistent state. Each function call is independent and does not rely on prior calls to set configurations, establish sessions, or store intermediate data. For example, retrieving article details via `article_details` requires only a PMID and does not depend on a prior search; similarly, clinical trial modules (`trial_protocol`, `trial_locations`, etc.) each accept an NCT ID directly and fetch corresponding data without requiring initialization. The presence of pagination support in `trial_searcher` and `variant_searcher` via `next_page_hash` and `offset` parameters does not imply statefulness, as these are idempotent query modifiers rather than references to mutable server-side session state. There is no shared context, session token, or configuration cache indicated in the tool definitions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 6290,
        "completion_tokens": 255,
        "total_tokens": 6545
      },
      "function_count": 9,
      "functions": [
        "biomcp-trial_locations",
        "biomcp-article_details",
        "biomcp-article_searcher",
        "biomcp-trial_references",
        "biomcp-trial_outcomes",
        "biomcp-trial_searcher",
        "biomcp-variant_searcher",
        "biomcp-trial_protocol",
        "biomcp-variant_details"
      ]
    },
    "Dog Image Fetcher": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the \"Dog Image Fetcher\" MCP server are read-only operations that retrieve data from an external dog image API. None of the functions perform create, update, delete, or configuration-setting actions that would modify persistent state. Each function operates independently and does not rely on prior function calls to set up context, sessions, or configurations. For example:\n- `get_random_dog_image` fetches random images with optional filters but does not alter any system state.\n- `get_dog_breeds` returns breed information based on pagination and search parameters without storing or modifying data.\n- `search_dog_images` searches for images by breed name, a query operation with no side effects.\n- `check_dog_api_status` retrieves connection status, likely reflecting static or externally determined conditions rather than internal mutable state.\n\nThere is no evidence of shared mutable context, session management, authentication tokens, configuration flags, or cached data that persists across calls and influences behavior. All inputs are provided explicitly per request, and outputs depend solely on current input parameters and the external API’s responses.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1193,
        "completion_tokens": 244,
        "total_tokens": 1437
      },
      "function_count": 4,
      "functions": [
        "dog-image-fetcher-search_dog_images",
        "dog-image-fetcher-check_dog_api_status",
        "dog-image-fetcher-get_random_dog_image",
        "dog-image-fetcher-get_dog_breeds"
      ]
    },
    "12306 MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "12306-mcp-server-search"
      ]
    },
    "Mina Archive Node API": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Mina Archive Node API provides read-only access to blockchain data through three functions: `query-actions`, `query-events`, and `get-network-state`. All of these functions are queries that retrieve data based on input parameters without any indication of modifying server-side state. There are no operations for creating, updating, or deleting data (e.g., no \"submit-transaction\", \"set-config\", or \"create-session\" type functions). Each function call is self-contained and does not rely on prior interactions. The responses depend solely on the blockchain state at query time and the provided filters, not on any session, configuration, or context established by previous calls. Therefore, there is no evidence of state being modified by one function and used by another.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1061,
        "completion_tokens": 175,
        "total_tokens": 1236
      },
      "function_count": 3,
      "functions": [
        "mina-archive-node-api-get-network-state",
        "mina-archive-node-api-query-actions",
        "mina-archive-node-api-query-events"
      ]
    },
    "QuickChart Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The QuickChart Server provides two functions—`generate_chart` and `download_chart`—both of which appear to be stateless operations. The `generate_chart` function generates a chart image based on input configuration (type, labels, datasets, etc.) and returns it, but there is no indication that this operation stores or modifies any persistent server-side state. Similarly, `download_chart` takes a complete chart configuration as input and saves the resulting image to a specified local path; it does not rely on prior side effects from previous calls. Crucially, `download_chart` requires the full `config` object as a parameter, meaning it does not depend on any session, cached configuration, or previously set state from `generate_chart` or any other call. There is no shared context, session management, or persistent configuration implied by the tool definitions. Each function operates independently based solely on its input parameters.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 937,
        "completion_tokens": 207,
        "total_tokens": 1144
      },
      "function_count": 2,
      "functions": [
        "quickchart-server-download_chart",
        "quickchart-server-generate_chart"
      ]
    },
    "Terraform MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Terraform MCP Server exhibits stateful behavior due to explicit dependencies between functions where the output of one function is a required input for another. Specifically, `resolveProviderDocID` must be called before `getProviderDocs`, as the latter requires a `providerDocID` generated by the former. Similarly, `searchModules` must precede `moduleDetails`, because `moduleDetails` requires a `moduleID` that can only be obtained through `searchModules`. These constraints indicate that the server maintains contextual state—specifically, valid identifiers and their associated metadata—that persists across and influences subsequent function calls. This dependency on prior execution outcomes demonstrates a clear stateful design pattern, even though no explicit mutation operations (like create/update/delete) are exposed directly in the tool interface. The required sequencing and data flow between tools confirm that internal or contextual state is being maintained and relied upon.",
      "state_dependencies": [
        {
          "function_a": "resolveProviderDocID",
          "function_b": "getProviderDocs",
          "state_description": "The providerDocID returned by resolveProviderDocID is required to fetch documentation via getProviderDocs"
        },
        {
          "function_a": "searchModules",
          "function_b": "moduleDetails",
          "state_description": "The moduleID returned by searchModules is required to retrieve module details via moduleDetails"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1485,
        "completion_tokens": 300,
        "total_tokens": 1785
      },
      "function_count": 4,
      "functions": [
        "terraform-mcp-server-searchModules",
        "terraform-mcp-server-moduleDetails",
        "terraform-mcp-server-resolveProviderDocID",
        "terraform-mcp-server-getProviderDocs"
      ]
    },
    "FrankfurterMCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available functions in the FrankfurterMCP server are read-only operations that retrieve exchange rate data or perform conversions based on publicly available or time-specific rates. None of the functions have parameters or documented behaviors indicating they modify persistent state (e.g., no functions for setting configurations, creating sessions, storing data, or updating settings). Each function operates independently using only the input parameters provided (such as base currency, target currencies, amount, or date), and their outputs depend solely on external data sources (like the Frankfurter API) rather than any internal mutable state maintained across calls. There is no evidence of shared context, session management, or configuration that persists between function invocations. Therefore, the server exhibits purely stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1642,
        "completion_tokens": 172,
        "total_tokens": 1814
      },
      "function_count": 5,
      "functions": [
        "frankfurtermcp-convert_currency_latest",
        "frankfurtermcp-convert_currency_specific_date",
        "frankfurtermcp-get_historical_exchange_rates",
        "frankfurtermcp-get_latest_exchange_rates",
        "frankfurtermcp-get_supported_currencies"
      ]
    },
    "MCP Server for Singapore Government Open Data": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits stateful behavior due to the presence of a two-step download mechanism involving `datagovsg_initiate_download` and `datagovsg_poll_download`. The `datagovsg_initiate_download` function initiates a download job on the server, which creates a persistent or temporary state associated with that specific dataset and its filtering parameters. This state includes the initiated download context (e.g., requested columns, filters) and likely triggers asynchronous processing. The `datagovsg_poll_download` function does not return data directly but instead checks the status of this previously initiated download and retrieves a download URL only if the request matches the prior initiation. Crucially, `poll_download` will fail or return no result unless `initiate_download` was called first with the same parameters. This dependency indicates that the server maintains state between calls — specifically, the existence and configuration of an active download job.\n\nFurthermore, the requirement in `datagovsg_poll_download` for optional parameters like `columnNames` and `filters` to \"match\" those used in `initiate_download` implies that the server must store these parameters server-side after initiation, reinforcing the stateful nature. There is no indication that the download URL or job ID is returned by `initiate_download`; thus, the client must use the same identifying parameters (especially `datasetId`) to poll correctly, relying on internal server tracking of the download state.\n\nNo other tools show clear create-update-delete side effects or session-based dependencies. All other functions (e.g., search, metadata retrieval) appear to be stateless read operations.",
      "state_dependencies": [
        {
          "function_a": "datagovsg_initiate_download",
          "function_b": "datagovsg_poll_download",
          "state_description": "Server maintains a download job state including datasetId, columnNames, and filters after initiate_download is called; poll_download depends on this state to check progress and retrieve the download URL"
        }
      ],
      "token_usage": {
        "prompt_tokens": 2458,
        "completion_tokens": 423,
        "total_tokens": 2881
      },
      "function_count": 10,
      "functions": [
        "mcp-server-for-singapore-government-open-data-datagovsg_list_collections",
        "mcp-server-for-singapore-government-open-data-datagovsg_poll_download",
        "mcp-server-for-singapore-government-open-data-datagovsg_list_datasets",
        "mcp-server-for-singapore-government-open-data-datagovsg_initiate_download",
        "mcp-server-for-singapore-government-open-data-datagovsg_search_dataset",
        "mcp-server-for-singapore-government-open-data-singstat_search_resources",
        "mcp-server-for-singapore-government-open-data-datagovsg_get_collection",
        "mcp-server-for-singapore-government-open-data-datagovsg_get_dataset_metadata",
        "mcp-server-for-singapore-government-open-data-singstat_get_metadata",
        "mcp-server-for-singapore-government-open-data-singstat_get_table_data"
      ]
    },
    "CoinGecko API Server": {
      "is_stateful": false,
      "confidence": 0.99,
      "reasoning": "The CoinGecko API Server is a read-only proxy to the public CoinGecko API, providing access to cryptocurrency data without any state modification capabilities. All available tools are purely retrieval functions that fetch data from external sources (e.g., coin prices, market data, trending searches) and do not support create, update, or delete operations. None of the functions modify persistent state, set configurations, or establish sessions. Each function call operates independently with no dependency on previous calls, as all required parameters are explicitly passed in each request (such as coin IDs, currencies, or search queries). There are no shared contexts, sessions, or configurations that persist across calls. The server acts as a stateless gateway to cryptocurrency data, where identical requests will always return the same results regardless of previous interactions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 126729,
        "completion_tokens": 183,
        "total_tokens": 126912
      },
      "function_count": 7,
      "functions": [
        "coingecko-api-server-API-coins-list",
        "coingecko-api-server-API-trending-search",
        "coingecko-api-server-API-coins-id",
        "coingecko-api-server-API-coins-id-ohlc",
        "coingecko-api-server-API-simple-price",
        "coingecko-api-server-API-coins-markets",
        "coingecko-api-server-API-search-data"
      ]
    },
    "Votars MCP": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The available tools in the Votars MCP server—“Votars fetch a specific transcript” and “Votars fetch recent transcripts”—are both read-only operations. Neither function modifies system state, as there are no indications of create, update, or delete functionality among the provided tools. Both functions retrieve existing transcripts based on either an ID or recency, but there is no evidence that calling one affects the behavior or output of the other. There are no shared sessions, configurations, or context-modifying side effects described in the tool definitions. Without any state-altering operations, the server behaves statelessly: each call is independent and idempotent.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 593,
        "completion_tokens": 158,
        "total_tokens": 751
      },
      "function_count": 2,
      "functions": [
        "votars-mcp-Votars fetch a specific transcript",
        "votars-mcp-Votars fetch recent transcripts"
      ]
    },
    "Manga Translator": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "manga-translator-get_random_joke"
      ]
    },
    "AutoGen Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The AutoGen Server exhibits clear stateful behavior based on the provided tools. Several functions create persistent entities (agents, workflows) that must exist prior to being used in subsequent operations. Specifically:  \n1. **create_agent** modifies system state by creating an agent with a unique name and configuration. This agent must exist before it can be referenced in other functions.  \n2. **create_streaming_workflow** creates a workflow that includes agent configurations—this implies it likely references previously created agents or stores workflow state that persists across calls.  \n3. **start_streaming_chat** depends on the existence of an agent (via `agent_name`), meaning it relies on state established by a prior call to **create_agent**.  \n4. **execute_workflow** requires a `workflow_name`, indicating it depends on a workflow previously created via **create_streaming_workflow**.  \n\nThese dependencies confirm that the outcome of certain function calls (e.g., starting a chat or executing a workflow) is contingent upon prior setup operations, which is a hallmark of stateful systems. Without the prior creation of agents or workflows, the execution functions would fail due to missing resources.",
      "state_dependencies": [
        {
          "function_a": "create_agent",
          "function_b": "start_streaming_chat",
          "state_description": "Agent created by create_agent must exist for start_streaming_chat to reference it by name"
        },
        {
          "function_a": "create_agent",
          "function_b": "create_streaming_workflow",
          "state_description": "Agent created by create_agent may be included in the agents list during workflow creation"
        },
        {
          "function_a": "create_streaming_workflow",
          "function_b": "execute_workflow",
          "state_description": "Workflow configuration and definition created by create_streaming_workflow must exist for execute_workflow to run it"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1024,
        "completion_tokens": 401,
        "total_tokens": 1425
      },
      "function_count": 4,
      "functions": [
        "autogen-server-create_streaming_workflow",
        "autogen-server-start_streaming_chat",
        "autogen-server-execute_workflow",
        "autogen-server-create_agent"
      ]
    },
    "Velt Analytics Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available tools in the Velt Analytics Server, there is no evidence of stateful behavior. All functions are read-only analytics queries that retrieve data based on input parameters such as date ranges, filters, and pagination tokens. None of the functions perform create, update, or delete operations that would modify persistent server state. The `pageToken` parameter in `get_events_analytics` is used for pagination but does not imply statefulness—it is a common pattern in stateless APIs where the token encodes cursor information (e.g., timestamp or offset) rather than referencing mutable server-side session state. There are no indications that calling one function alters configuration, creates sessions, or stores data that affects the behavior of subsequent calls to other functions. Each function operates independently and deterministically based solely on its input parameters, with no shared mutable context between invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 3274,
        "completion_tokens": 198,
        "total_tokens": 3472
      },
      "function_count": 6,
      "functions": [
        "velt-analytics-server-get_organization_top_number_analytics",
        "velt-analytics-server-get_feature_analytics_count",
        "velt-analytics-server-get_attachment_analytics_values",
        "velt-analytics-server-get_document_top_number_analytics",
        "velt-analytics-server-get_user_top_number_analytics",
        "velt-analytics-server-get_events_analytics"
      ]
    },
    "MCP Server Semgrep": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits stateful behavior because several functions modify persistent state (e.g., creating rules or generating scan results), and subsequent functions depend on that state to operate. For example, the `create_rule` function writes a new Semgrep rule file to a specified path, which can then be used in future scans—potentially via the `scan_directory` function if referenced in its `config` parameter. Similarly, `scan_directory` produces output (implied by result analysis tools) that is consumed by other functions such as `analyze_results`, `filter_results`, `export_results`, and `compare_results`. These consumer functions require the existence and content of JSON results files generated by prior scan operations, indicating a clear dependency on previously created state. While the server does not manage sessions or global configurations explicitly, it relies on the file system as shared persistent state across function calls.",
      "state_dependencies": [
        {
          "function_a": "scan_directory",
          "function_b": "analyze_results",
          "state_description": "The scan_directory function generates a JSON results file that is required as input for analyze_results"
        },
        {
          "function_a": "scan_directory",
          "function_b": "filter_results",
          "state_description": "The scan_directory function generates a JSON results file that is used as input for filtering by filter_results"
        },
        {
          "function_a": "scan_directory",
          "function_b": "export_results",
          "state_description": "The scan_directory function generates a JSON results file that must be provided to export_results for exporting in different formats"
        },
        {
          "function_a": "scan_directory",
          "function_b": "compare_results",
          "state_description": "The scan_directory function generates two separate JSON results files (old and new) that are compared using compare_results"
        },
        {
          "function_a": "create_rule",
          "function_b": "scan_directory",
          "state_description": "The create_rule function creates a rule file at a specified path, which can be referenced in the config parameter of scan_directory to perform custom scans"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1425,
        "completion_tokens": 453,
        "total_tokens": 1878
      },
      "function_count": 7,
      "functions": [
        "mcp-server-semgrep-list_rules",
        "mcp-server-semgrep-scan_directory",
        "mcp-server-semgrep-export_results",
        "mcp-server-semgrep-compare_results",
        "mcp-server-semgrep-filter_results",
        "mcp-server-semgrep-analyze_results",
        "mcp-server-semgrep-create_rule"
      ]
    },
    "Erick Wendel Contributions": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The provided MCP server tools consist exclusively of read-only operations: `get_talks`, `get_posts`, `get_videos`, and `check_status`. None of the functions perform create, update, delete, or any other state-modifying actions. All functions accept filtering and pagination parameters but do not alter any underlying system state, configuration, session, or data store. There is no indication of shared mutable context, persistent sessions, or configurations established by one function and used by another. Each function call appears to be independent and idempotent, relying solely on input parameters and external data sources rather than internal mutable state. Therefore, there is no evidence of stateful behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1333,
        "completion_tokens": 160,
        "total_tokens": 1493
      },
      "function_count": 4,
      "functions": [
        "erick-wendel-contributions-get_talks",
        "erick-wendel-contributions-check_status",
        "erick-wendel-contributions-get_posts",
        "erick-wendel-contributions-get_videos"
      ]
    },
    "Weather MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available functions in the Weather MCP Server are stateless read operations that retrieve weather or datetime information based on explicit input parameters. None of the functions perform create, update, delete, or configuration-setting actions that would modify persistent state. Each function operates independently:  \n- `get_current_weather` fetches current weather for a city using only the provided city name.  \n- `get_weather_by_datetime_range` retrieves historical/future weather data based on city and date range inputs.  \n- `get_current_datetime` returns the current time in a specified timezone, with no side effects.  \n\nThere is no evidence of shared context, sessions, configurations, or cached state that persists across calls. All outputs depend solely on input parameters and external API responses (from Open-Meteo), not on prior function invocations. Therefore, no function modifies state that another function depends on.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 969,
        "completion_tokens": 199,
        "total_tokens": 1168
      },
      "function_count": 5,
      "functions": [
        "weather-mcp-server-get_current_datetime",
        "weather-mcp-server-get-alerts",
        "weather-mcp-server-get_current_weather",
        "weather-mcp-server-get_weather_by_datetime_range",
        "weather-mcp-server-get-forecast"
      ]
    },
    "Think Tool": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The MCP server \"Think Tool\" maintains a session-based state that persists across function calls. Specifically, the `think` function appends thoughts to a log, which modifies the internal state of the system by recording reasoning processes. Subsequent calls to `get_thoughts` retrieve the list of thoughts that were previously recorded, meaning their output depends on prior invocations of `think`. Similarly, `get_thought_stats` returns statistics about the recorded thoughts (e.g., count, patterns), which also relies on the accumulated state from previous `think` operations. Furthermore, `clear_thoughts` explicitly modifies the shared state by removing all recorded thoughts, thereby affecting the outcome of future calls to `get_thoughts` and `get_thought_stats`. These interdependencies confirm that the server is stateful.",
      "state_dependencies": [
        {
          "function_a": "think",
          "function_b": "get_thoughts",
          "state_description": "The 'think' function appends a thought to the session's thought log; 'get_thoughts' retrieves this accumulated log."
        },
        {
          "function_a": "think",
          "function_b": "get_thought_stats",
          "state_description": "The 'think' function adds thoughts that contribute to the metrics returned by 'get_thought_stats', such as thought count or frequency."
        },
        {
          "function_a": "clear_thoughts",
          "function_b": "get_thoughts",
          "state_description": "The 'clear_thoughts' function empties the thought log, causing 'get_thoughts' to return an empty list afterward."
        },
        {
          "function_a": "clear_thoughts",
          "function_b": "get_thought_stats",
          "state_description": "Clearing thoughts resets the internal statistics, so 'get_thought_stats' will reflect zero or default values after 'clear_thoughts' is called."
        }
      ],
      "token_usage": {
        "prompt_tokens": 738,
        "completion_tokens": 424,
        "total_tokens": 1162
      },
      "function_count": 4,
      "functions": [
        "think-tool-clear_thoughts",
        "think-tool-think",
        "think-tool-get_thought_stats",
        "think-tool-get_thoughts"
      ]
    },
    "Exa Search": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the Exa Search MCP server are read-only, stateless operations that perform independent queries against external data sources (e.g., web, academic databases, LinkedIn, GitHub, Wikipedia). None of the functions have parameters or documented behaviors indicating they create, modify, or delete persistent state (such as sessions, configurations, stored data, or caches). Each function takes fully self-contained input (e.g., a query, URL, or company name) and returns results without relying on prior interactions. There is no evidence of shared context, session tokens, configuration settings, or side effects that would affect subsequent calls. For example, calling `web_search_exa` does not alter the behavior of `crawling_exa`, even if used on a resulting URL—each call to `crawling_exa` depends only on the provided URL, not on any search history. Similarly, no tool outputs include identifiers or handles meant to be reused across calls (like session IDs or temporary state references), which further supports statelessness.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1873,
        "completion_tokens": 234,
        "total_tokens": 2107
      },
      "function_count": 8,
      "functions": [
        "exa-search-research_paper_search_exa",
        "exa-search-web_search_exa",
        "exa-search-linkedin_search_exa",
        "exa-search-github_search_exa",
        "exa-search-crawling_exa",
        "exa-search-company_research_exa",
        "exa-search-competitor_finder_exa",
        "exa-search-wikipedia_search_exa"
      ]
    },
    "MCP Fetch": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "mcp-fetch-fetch"
      ]
    },
    "ScrAPI MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The ScrAPI MCP Server provides two functions, `scrape_url_html` and `scrape_url_markdown`, both of which are designed to scrape web content from a given URL. Neither function has parameters or documented behaviors that suggest they modify persistent state on the server (e.g., no session creation, configuration updates, or data storage). Each function appears to be a self-contained operation that initiates a scrape request and returns the result independently. There is no indication that calling one function affects the behavior or output of the other. Both tools accept only a URL and return transformed content without relying on prior interactions. No shared context, sessions, or configurations are exposed or implied in the tool definitions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 776,
        "completion_tokens": 165,
        "total_tokens": 941
      },
      "function_count": 2,
      "functions": [
        "scrapi-mcp-server-scrape_url_html",
        "scrapi-mcp-server-scrape_url_markdown"
      ]
    },
    "Clear Thought": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server \"Clear Thought\" exhibits strong indicators of stateful behavior through multiple tools that explicitly manage session state, maintain iterative context, and depend on shared identifiers across function calls. Several tools include parameters such as `sessionId`, `iteration`, `branchId`, `decisionId`, `monitoringId`, and `inquiryId`, which are used to track ongoing processes across multiple invocations. These IDs imply the existence of persistent internal state tied to specific analytical threads (e.g., reasoning sequences, decision-making processes, debugging sessions).  \n\nCrucially, functions like `collaborativereasoning`, `socraticmethod`, `scientificmethod`, `sequentialthinking`, and others require these session or process-specific IDs and also include flags such as `nextContributionNeeded`, `nextArgumentNeeded`, `nextStageNeeded`, or `nextThoughtNeeded`. This suggests that each call builds upon or continues a prior state, and the server must retain information about previous calls to ensure continuity. Furthermore, the presence of `session_export` and `session_import` tools confirms that the system supports saving and restoring full session states, which is only meaningful in a stateful architecture.\n\nAdditionally, tools like `sequentialthinking` support revisions (`isRevision`, `revisesThought`) and branching (`branchFromThought`, `branchId`), implying that earlier thoughts are stored and referenced later—this requires internal memory of past operations. Similarly, `scientificmethod` progresses through stages (`observation`, `hypothesis`, `experiment`, etc.), with each stage depending on data from prior ones, indicating sequential state dependency.\n\nThe combination of unique identifiers, continuation flags, cross-call references, and explicit import/export functionality provides compelling evidence that this MCP server maintains and relies on persistent state across function calls.",
      "state_dependencies": [
        {
          "function_a": "sequentialthinking",
          "function_b": "sequentialthinking",
          "state_description": "A call to sequentialthinking with a thoughtNumber and totalThoughts establishes a sequence context; subsequent calls with isRevision or branchFromThought depend on previously stored thoughts within the same logical sequence."
        },
        {
          "function_a": "collaborativereasoning",
          "function_b": "collaborativereasoning",
          "state_description": "Initial call creates a collaborative session with personas and contributions; subsequent calls with nextContributionNeeded=true depend on existing session state identified by sessionId to continue the reasoning process."
        },
        {
          "function_a": "socraticmethod",
          "function_b": "socraticmethod",
          "state_description": "The first invocation sets up a claim and premises under a sessionId; later calls advance through stages (e.g., from clarification to implications) relying on retained argument state from prior calls."
        },
        {
          "function_a": "scientificmethod",
          "function_b": "scientificmethod",
          "state_description": "An initial hypothesis stage stores hypothesisId and inquiryId; subsequent experiment and analysis stages use those IDs to reference and build upon the original hypothesis, requiring preserved state."
        },
        {
          "function_a": "session_export",
          "function_b": "session_import",
          "state_description": "session_export captures current server state (including all active sessions and iterations); session_import restores that exact state, demonstrating that the server maintains modifiable, persistent context across time."
        },
        {
          "function_a": "decisionframework",
          "function_b": "decisionframework",
          "state_description": "Early invocation defines options and analysisType with decisionId; later iterations depend on this stored decision context to progress through stages like evaluation or finalization."
        },
        {
          "function_a": "metacognitivemonitoring",
          "function_b": "metacognitivemonitoring",
          "state_description": "Monitoring state (e.g., uncertaintyAreas, recommendedApproach) is established in one call with monitoringId; future assessments use the same ID to update or refine understanding, indicating state retention."
        }
      ],
      "token_usage": {
        "prompt_tokens": 5841,
        "completion_tokens": 841,
        "total_tokens": 6682
      },
      "function_count": 15,
      "functions": [
        "clear-thought-visualreasoning",
        "clear-thought-session_import",
        "clear-thought-mentalmodel",
        "clear-thought-debuggingapproach",
        "clear-thought-scientificmethod",
        "clear-thought-structuredargumentation",
        "clear-thought-systemsthinking",
        "clear-thought-collaborativereasoning",
        "clear-thought-socraticmethod",
        "clear-thought-session_export",
        "clear-thought-decisionframework",
        "clear-thought-creativethinking",
        "clear-thought-metacognitivemonitoring",
        "clear-thought-sequentialthinking",
        "clear-thought-session_info"
      ]
    },
    "AKShare One MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the AKShare One MCP Server are read-only data retrieval operations. There is no evidence of any function that creates, modifies, or deletes persistent state on the server. Each function (e.g., `get_hist_data`, `get_realtime_data`, `get_balance_sheet`, etc.) takes input parameters—primarily a stock symbol and optional filters—and returns data without indicating side effects or reliance on prior interactions. None of the tools expose configuration-setting, session initialization, caching control, or authentication flows that would imply shared mutable state across calls. Furthermore, all required parameters for each function are explicitly provided in the request (such as `symbol`, `recent_n`, `interval`), meaning outputs depend solely on inputs rather than implicit context established by previous calls. The presence of `get_time_info`, which returns current time and last trading day, also appears to be a pure function with no indication it affects other endpoints. Given the absence of write operations or inter-function dependencies, this MCP server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2133,
        "completion_tokens": 231,
        "total_tokens": 2364
      },
      "function_count": 8,
      "functions": [
        "akshare-one-mcp-server-get_balance_sheet",
        "akshare-one-mcp-server-get_income_statement",
        "akshare-one-mcp-server-get_time_info",
        "akshare-one-mcp-server-get_realtime_data",
        "akshare-one-mcp-server-get_inner_trade_data",
        "akshare-one-mcp-server-get_news_data",
        "akshare-one-mcp-server-get_cash_flow",
        "akshare-one-mcp-server-get_hist_data"
      ]
    },
    "MindBridge": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The available tools in the MindBridge MCP server—`getSecondOpinion`, `listProviders`, and `listReasoningModels`—appear to be purely functional and do not indicate any modification or reliance on persistent state.  \n\n1. **State Modification**: None of the functions perform operations that clearly create, update, or delete system-wide or session-level state.  \n   - `getSecondOpinion` sends a prompt to an LLM provider and returns a response. It is a request-response operation with no indication of storing data beyond the immediate call.\n   - `listProviders` and `listReasoningModels` are read-only operations that retrieve static configuration information about available providers and models.\n\n2. **State Dependence**: There is no evidence that any function depends on prior function calls. Each can be invoked independently:\n   - `getSecondOpinion` requires only explicit input parameters (prompt, provider, model) and does not reference prior configurations or outputs.\n   - The listing functions return metadata that is likely preconfigured or fetched from external systems but not altered by other tool calls.\n\n3. **Function Pairs & Shared Context**: No function pair exhibits a setup-and-use relationship. For example, calling `listProviders` before `getSecondOpinion` may be helpful for selecting valid inputs, but it is not required—the user could provide valid values directly. This is client-side convenience, not server-enforced state dependency.\n\n4. **Sessions, Configurations, or Context**: While `getSecondOpinion` allows setting parameters like `systemPrompt`, `temperature`, etc., these are transient per-request settings and do not persist across calls or affect future behavior unless explicitly re-provided. There is no indication of session affinity, context caching, or global configuration mutation.\n\nTherefore, all interactions are stateless: each function operates based solely on its input parameters and predefined configurations, without side effects or inter-call dependencies.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1144,
        "completion_tokens": 412,
        "total_tokens": 1556
      },
      "function_count": 3,
      "functions": [
        "mindbridge-getSecondOpinion",
        "mindbridge-listReasoningModels",
        "mindbridge-listProviders"
      ]
    },
    "attAck MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The attAck MCP Server provides read-only access to a static knowledge base about ATT&CK tactics, techniques, mitigations, and detections. All available functions are query operations that retrieve information based on input parameters (e.g., technique ID or name) without modifying any system state. None of the tools perform create, update, delete, or configuration-setting actions. Each function call is independent and does not rely on prior calls to function correctly. For example, calling `query_technique` with a valid technique ID will succeed regardless of whether other functions have been called first. Similarly, `query_mitigations` and `query_detections` only require a technique ID as input and do not depend on any session, context, or configuration established by previous calls. There is no evidence of shared mutable state, persistent sessions, or contextual dependencies between function invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 946,
        "completion_tokens": 200,
        "total_tokens": 1146
      },
      "function_count": 4,
      "functions": [
        "attack-mcp-server-query_technique",
        "attack-mcp-server-list_tactics",
        "attack-mcp-server-query_mitigations",
        "attack-mcp-server-query_detections"
      ]
    },
    "Excel MCP Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The `token_authentication` function explicitly performs user authentication using an ID, password, and user type, and the description states that \"the token is stored internally and not exposed externally.\" This indicates that upon successful authentication, a session or security token is stored in the server's internal state. Subsequent operations (not listed here but implied by the server’s purpose of manipulating Excel files) would likely depend on this authenticated session state to authorize actions such as reading or modifying workbooks. Since the authentication state persists across function calls and affects the behavior of other (presumably protected) functions, this establishes stateful behavior. Even though no other tools show explicit dependencies, the presence of internal token storage after `token_authentication` strongly implies shared context across calls.",
      "state_dependencies": [
        {
          "function_a": "token_authentication",
          "function_b": "validate_test_sc",
          "state_description": "Authentication token generated and stored by token_authentication may be required for validate_test_sc to authorize execution."
        }
      ],
      "token_usage": {
        "prompt_tokens": 671,
        "completion_tokens": 224,
        "total_tokens": 895
      },
      "function_count": 2,
      "functions": [
        "excel-mcp-server-validate_test_sc",
        "excel-mcp-server-token_authentication"
      ]
    },
    "iOS Code Migration Optimization Tool": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior through multiple function pairs where one function modifies persistent state and others depend on that state. Specifically:\n\n- `ios_update_progress` modifies the project's transformation progress by recording completed files and notes, which implies writing to a persistent or shared state associated with the project path.\n- `ios_get_progress_statistics` retrieves detailed statistics about the project’s migration progress, which logically depends on data previously recorded via `ios_update_progress`. Without prior calls to update progress, the statistics would be incomplete or empty.\n- `ios_setup_cursor_rules` injects Cursor rules configuration into a project, modifying the file system or internal configuration state of the Cursor project at the specified path. Subsequent tools (e.g., analysis or instruction generation) may rely on these injected rules for correct behavior, especially since the tool integrates with Cursor AI to enforce code standards.\n- While not directly visible in return values, the combination of `ios_scan_project`, `ios_analyze_file`, and `ios_generate_cursor_instructions` suggests a workflow where scanning and analysis build up contextual knowledge that could influence later instructions—however, this dependency is weaker unless explicitly stored.\n\nThe strongest evidence is the **update-progress → get-statistics** flow, which is a classic pattern of write-then-read stateful interaction based on project-level mutable state.",
      "state_dependencies": [
        {
          "function_a": "ios_update_progress",
          "function_b": "ios_get_progress_statistics",
          "state_description": "Project migration progress (completed files and notes) updated by ios_update_progress is read and aggregated by ios_get_progress_statistics"
        },
        {
          "function_a": "ios_setup_cursor_rules",
          "function_b": "ios_generate_cursor_instructions",
          "state_description": "Cursor rules configuration set by ios_setup_cursor_rules may influence the content or constraints of generated instructions in ios_generate_cursor_instructions"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1556,
        "completion_tokens": 403,
        "total_tokens": 1959
      },
      "function_count": 7,
      "functions": [
        "ios-code-migration-optimization-tool-ios_evaluate_project_quality",
        "ios-code-migration-optimization-tool-ios_get_progress_statistics",
        "ios-code-migration-optimization-tool-ios_scan_project",
        "ios-code-migration-optimization-tool-ios_setup_cursor_rules",
        "ios-code-migration-optimization-tool-ios_analyze_file",
        "ios-code-migration-optimization-tool-ios_update_progress",
        "ios-code-migration-optimization-tool-ios_generate_cursor_instructions"
      ]
    },
    "PyPI MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available functions in the PyPI MCP Server are read-only operations that retrieve public metadata from PyPI (Python Package Index). None of the tools perform create, update, or delete actions that would modify persistent state on the server. Specifically:  \n- `get_package_info` retrieves metadata about a specific package and version.  \n- `search_packages` returns search results based on a query string.  \n- `get_package_releases` fetches release history for a given package.  \n- `get_package_stats` returns download or usage statistics for a package.  \n\nThere is no indication that any function modifies system state such as configurations, sessions, caches, or stored data that would affect subsequent calls. Each function operates independently using only its input parameters and external PyPI data sources. No function depends on state established by another, and there are no shared contexts, sessions, or configurations that persist across calls. The behavior is purely stateless and idempotent.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 829,
        "completion_tokens": 217,
        "total_tokens": 1046
      },
      "function_count": 4,
      "functions": [
        "pypi-mcp-server-get_package_stats",
        "pypi-mcp-server-get_package_releases",
        "pypi-mcp-server-search_packages",
        "pypi-mcp-server-get_package_info"
      ]
    },
    "Claude Server": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The MCP server explicitly supports persistent context management across function calls, with clear write and read operations that modify and depend on shared state. Functions like `save_project_context` and `save_conversation_context` create or update stored context entries, which can later be retrieved using `get_context`. Additionally, `list_contexts` can return results filtered by prior saved attributes such as `projectId`, `tags`, or `type`, indicating that the system maintains a mutable, queryable state over time. The presence of hierarchical relationships (e.g., `parentContextId`, `continuationOf`) further implies that saved contexts are not isolated but influence future interactions. This combination of state-modifying writes and state-dependent reads confirms stateful behavior.",
      "state_dependencies": [
        {
          "function_a": "save_project_context",
          "function_b": "get_context",
          "state_description": "Context data saved under a specific ID by save_project_context can be retrieved using get_context with that ID"
        },
        {
          "function_a": "save_conversation_context",
          "function_b": "get_context",
          "state_description": "Conversation context saved with an ID via save_conversation_context is accessible later through get_context using the same ID"
        },
        {
          "function_a": "save_project_context",
          "function_b": "list_contexts",
          "state_description": "Project contexts tagged with specific tags or belonging to a projectId affect the output of list_contexts when filtering by those criteria"
        },
        {
          "function_a": "save_conversation_context",
          "function_b": "list_contexts",
          "state_description": "Saved conversation contexts contribute to the list of contexts returned by list_contexts, especially when filtered by type or tag"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1179,
        "completion_tokens": 381,
        "total_tokens": 1560
      },
      "function_count": 4,
      "functions": [
        "claude-server-list_contexts",
        "claude-server-save_project_context",
        "claude-server-get_context",
        "claude-server-save_conversation_context"
      ]
    },
    "AAAAAA MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "aaaaaa-mcp-server-get_forecast"
      ]
    },
    "MCP Server Test": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The MCP server \"MCP Server Test\" provides two tools: `get_alerts` and `get_forecast`. Both are read-only operations that retrieve weather data based on explicit input parameters. Neither function performs any create, update, delete, or configuration-setting operation. The `get_alerts` function requires a state code and returns alerts for that state, while `get_forecast` requires latitude and longitude to return a forecast—both functions operate independently and do not rely on or modify any shared or persistent state. There is no indication of session management, configuration storage, or context propagation between calls. All inputs are provided explicitly in each function call, and no side effects are described that would alter system behavior across invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 678,
        "completion_tokens": 171,
        "total_tokens": 849
      },
      "function_count": 3,
      "functions": [
        "mcp-server-test-get_alerts",
        "mcp-server-test-format_markdown",
        "mcp-server-test-get_forecast"
      ]
    },
    "Expression Evaluation Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "expression-evaluation-server-eval"
      ]
    },
    "Compass": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "compass-recommend-mcp-servers"
      ]
    },
    "yt-dlp Video and Audio Downloader": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available tools in the yt-dlp Video and Audio Downloader MCP server, there is no evidence of persistent state being created, modified, or relied upon across function calls. Each tool operates independently and requires only the video URL (and optionally parameters like resolution or language) to perform its task. None of the functions explicitly create sessions, store configurations, maintain caches, or modify global settings that would affect subsequent operations. For example:\n- `list_subtitle_languages` retrieves available subtitle languages for a given URL but does not store this information.\n- `download_video_subtitles`, `download_transcript`, and other functions accept all necessary context (URL, language) directly as input and do not depend on prior calls.\n- Download functions (`download_video`, `download_audio`) act solely on provided parameters and do not require pre-initialization steps.\n\nAll functions appear to be idempotent and stateless—each call is self-contained and could be executed in any order or isolation without affecting outcomes. There is no shared session, configuration, or intermediate state implied by the tool definitions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1129,
        "completion_tokens": 241,
        "total_tokens": 1370
      },
      "function_count": 5,
      "functions": [
        "yt-dlp-video-and-audio-downloader-list_subtitle_languages",
        "yt-dlp-video-and-audio-downloader-download_video",
        "yt-dlp-video-and-audio-downloader-download_video_subtitles",
        "yt-dlp-video-and-audio-downloader-download_transcript",
        "yt-dlp-video-and-audio-downloader-download_audio"
      ]
    },
    "Tesouro Direto MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "All available functions in the Tesouro Direto MCP Server are read-only operations that retrieve data without modifying any persistent state. The `market_data` function returns general market status, `bond_data` fetches details for a specific bond by code, and `search_bonds` allows filtering bonds by type or maturity date range. None of these functions have parameters or behaviors indicating they create, update, or delete data on the server. There is no indication of session creation, configuration changes, or storage of client-specific state between calls. The mention of \"smart caching\" in the overview likely refers to performance optimization (e.g., reducing redundant API calls internally), but this does not imply user-visible statefulness since caching does not alter functional behavior based on prior function calls from the client. No function requires or depends on state established by another function.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 783,
        "completion_tokens": 194,
        "total_tokens": 977
      },
      "function_count": 3,
      "functions": [
        "tesouro-direto-mcp-server-search_bonds",
        "tesouro-direto-mcp-server-market_data",
        "tesouro-direto-mcp-server-bond_data"
      ]
    },
    "IPMA Weather Data Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available functions in the IPMA Weather Data Server, there is no evidence of state-modifying operations (e.g., create, update, delete) or any mechanism that establishes persistent context such as sessions, configurations, or stored data across function calls. All provided tools are read-only and retrieve publicly available meteorological information without requiring prior setup or altering system state. For example:\n\n- `get_weather_forecast` retrieves forecast data for a specified city but does not store or modify any configuration.\n- `get_weather_warnings`, `get_seismic_data`, `get_uv_forecast`, `get_weather_stations`, and `get_locations` all return static observational or forecasted data based on current conditions, with no indication of dependency on prior interactions.\n\nNone of the functions accept or require parameters that suggest reliance on previously established state (such as tokens, session IDs, or configuration flags), nor do any have side effects that would influence subsequent calls. The absence of any write-capable or state-initializing endpoints strongly indicates a stateless design, typical of RESTful APIs serving open environmental data.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 863,
        "completion_tokens": 244,
        "total_tokens": 1107
      },
      "function_count": 6,
      "functions": [
        "ipma-weather-data-server-get_uv_forecast",
        "ipma-weather-data-server-get_seismic_data",
        "ipma-weather-data-server-get_weather_stations",
        "ipma-weather-data-server-get_locations",
        "ipma-weather-data-server-get_weather_warnings",
        "ipma-weather-data-server-get_weather_forecast"
      ]
    },
    "AWS EC2 Pricing": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "aws-ec2-pricing-find_instances"
      ]
    },
    "Fruityvice Nutrition Info Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "fruityvice-nutrition-info-server-get_fruit_nutrition"
      ]
    },
    "NLTK Model Context Protocol Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "nltk-model-context-protocol-server-get_longest_word"
      ]
    },
    "Model Context Protocol Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The two available functions, `calculate_bmi` and `fetch_weather`, are both pure and independent operations that do not modify or rely on any shared persistent state. The `calculate_bmi` function computes a value based solely on its input parameters (weight and height) and has no side effects. The `fetch_weather` function retrieves weather data for a given city, which is an idempotent read operation that does not alter server state and does not depend on prior function calls. There are no indications of configuration settings, session management, data storage, or contextual dependencies between function invocations. Both functions appear to be stateless, with outputs determined exclusively by their inputs.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 668,
        "completion_tokens": 161,
        "total_tokens": 829
      },
      "function_count": 4,
      "functions": [
        "model-context-protocol-server-fetch_weather",
        "model-context-protocol-server-get_live_temp",
        "model-context-protocol-server-sequentialthinking",
        "model-context-protocol-server-calculate_bmi"
      ]
    },
    "Add Test": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "add-test-add_a_and_b"
      ]
    },
    "Books Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "All available functions in the Books Server—`get_definitions`, `get_word_details`, and `search_word`—are read-only operations that retrieve information based on input parameters without modifying any system state. None of the functions perform create, update, or delete actions. Each function operates independently, accepting a word or query as input and returning data without relying on or altering shared context, sessions, configurations, or persistent storage. There is no evidence that the output or behavior of one function depends on a prior call to another function. The server appears to provide stateless access to dictionary and word-related data, where each request contains all necessary information to be processed independently.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 789,
        "completion_tokens": 158,
        "total_tokens": 947
      },
      "function_count": 3,
      "functions": [
        "books-server-get_word_details",
        "books-server-search_word",
        "books-server-get_definitions"
      ]
    },
    "Weather Forecast": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "weather-forecast-get_live_temp"
      ]
    },
    "Internet Speed Test": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available functions in the \"Internet Speed Test\" MCP server, there is no evidence of persistent state being created, modified, or relied upon across function calls. Each tool operates independently and performs a measurement task using only transient network operations:\n\n- `measure_download_speed`, `measure_upload_speed`, `measure_latency`, and `measure_jitter` all perform isolated network measurements with no indication of modifying configurations, sessions, or stored data.\n- `get_server_info` retrieves information about a given URL without altering any system state.\n- `run_complete_test` appears to be a composite function that likely internally orchestrates multiple measurements but does not expose or depend on externally persisted state. It does not require prior calls nor affect subsequent ones.\n\nNone of the functions have side effects such as setting global variables, initializing sessions, caching results, or configuring the server in a way that would influence other function behaviors. All parameters are explicitly passed per call (e.g., URLs, size limits), and there is no shared mutable context between invocations.\n\nAdditionally, none of the function signatures suggest state creation (like returning session tokens or configuration handles) that must be used in later calls. The absence of create-update-delete patterns further supports the conclusion that this server is stateless.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1321,
        "completion_tokens": 277,
        "total_tokens": 1598
      },
      "function_count": 6,
      "functions": [
        "internet-speed-test-run_complete_test",
        "internet-speed-test-measure_jitter",
        "internet-speed-test-measure_latency",
        "internet-speed-test-measure_download_speed",
        "internet-speed-test-get_server_info",
        "internet-speed-test-measure_upload_speed"
      ]
    },
    "Scientific Method Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "scientific-method-server-scientificMethod"
      ]
    },
    "Analogical Reasoning Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "analogical-reasoning-server-analogicalReasoning"
      ]
    },
    "PubChem MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The PubChem MCP Server provides functions that are purely retrieval-based and do not appear to modify any persistent state on the server. All available tools—`search_pubchem_by_name`, `search_pubchem_by_smiles`, `get_pubchem_compound_by_cid`, and `search_pubchem_advanced`—are read-only operations that query chemical data from PubChem based on input parameters. None of these functions perform create, update, or delete actions that would alter server-side state. Furthermore, each function operates independently, relying solely on its input arguments (e.g., compound name, SMILES string, CID) rather than any context established by prior function calls. There is no indication of shared sessions, stored configurations, or cached states that persist across requests. The absence of state-modifying operations and inter-function state dependencies strongly indicates a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1057,
        "completion_tokens": 196,
        "total_tokens": 1253
      },
      "function_count": 4,
      "functions": [
        "pubchem-mcp-server-search_pubchem_by_name",
        "pubchem-mcp-server-search_pubchem_advanced",
        "pubchem-mcp-server-search_pubchem_by_smiles",
        "pubchem-mcp-server-get_pubchem_compound_by_cid"
      ]
    },
    "Deneme MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The provided tools in the Deneme MCP Server appear to be purely stateless, read-only operations focused on retrieving weather data or providing static responses. None of the functions perform create, update, delete, or configuration-setting operations that would modify persistent state. All functions accept explicit input parameters (e.g., coordinates, city name, message) and return results based solely on those inputs without indication of shared mutable state, session storage, or configuration dependencies across calls. For example, `chat_weather_assistant` may process user messages and extract context internally, but there is no evidence it stores this context between invocations or that other tools depend on it. Similarly, `weather_greeting` returns a fixed greeting message with no setup required. There are no indications of authentication tokens, sessions, cached locations, or unit preferences being carried over from one function call to another.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1336,
        "completion_tokens": 198,
        "total_tokens": 1534
      },
      "function_count": 5,
      "functions": [
        "deneme-mcp-server-get_weather_by_city",
        "deneme-mcp-server-get_weather_by_coordinates",
        "deneme-mcp-server-chat_weather_assistant",
        "deneme-mcp-server-get_weather",
        "deneme-mcp-server-weather_greeting"
      ]
    },
    "Hotel Booking Server": {
      "is_stateful": true,
      "confidence": 0.98,
      "reasoning": "The Hotel Booking Server exhibits clear stateful behavior through the use of session identifiers (`session_id`) that are generated by certain functions and must be reused in subsequent function calls to maintain context across interactions. Specifically, the `search-hotels` tool returns a `session_id` that is required for pagination via `load-more-hotels`, retrieving detailed hotel information via `get-hotel-details`, and initiating a booking via `book-hotel`. This means the server maintains internal state tied to this session, which persists across multiple requests and affects the behavior and validity of later operations. Without the initial call to `search-hotels`, subsequent tools like `load-more-hotels` or `get-hotel-details` cannot function correctly, as they depend on the existence and continuity of this session state. Additionally, the requirement to carry forward the same `session_id` across multiple steps confirms that the server does not treat each request independently, but instead relies on shared, persistent context — a hallmark of stateful systems.",
      "state_dependencies": [
        {
          "function_a": "search-hotels",
          "function_b": "load-more-hotels",
          "state_description": "The session_id returned by search-hotels is required to fetch additional paginated results using load-more-hotels."
        },
        {
          "function_a": "search-hotels",
          "function_b": "get-hotel-details",
          "state_description": "The session_id from search-hotels must be provided to get-hotel-details to retrieve comprehensive information about a specific hotel within the context of the original search."
        },
        {
          "function_a": "search-hotels",
          "function_b": "book-hotel",
          "state_description": "The session_id from search-hotels is required when calling book-hotel, indicating that the booking operation is bound to the context of the original search session."
        }
      ],
      "token_usage": {
        "prompt_tokens": 2104,
        "completion_tokens": 402,
        "total_tokens": 2506
      },
      "function_count": 6,
      "functions": [
        "hotel-booking-server-find-place",
        "hotel-booking-server-search-hotels",
        "hotel-booking-server-get-hotel-details",
        "hotel-booking-server-get-facilities",
        "hotel-booking-server-load-more-hotels",
        "hotel-booking-server-book-hotel"
      ]
    },
    "Weather Forecast Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The Weather Forecast Server provides read-only access to weather data through its tools. None of the available functions perform operations that modify persistent state (e.g., no creation, update, or deletion of server-side resources). All functions—`get_weather_by_coordinates`, `get_weather_by_city`, `get_weather`, `chat_weather_assistant`, and `weather_greeting`—are designed to retrieve or format weather information based on input parameters without storing or altering any shared context, session, or configuration between calls.  \n\nWhile `chat_weather_assistant` may appear to maintain conversational context (e.g., remembering prior user messages), there is no evidence in the provided schema that it stores state across invocations. Each call appears to be self-contained, processing a single message input and returning a response without relying on or modifying external state. Similarly, `weather_greeting` returns a static greeting and does not initialize any session or configuration used by other functions.  \n\nThere are no indications of shared sessions, cached configurations, or stateful dependencies between function calls. All data is fetched directly from an external source (OpenWeatherMap) based on explicit inputs like coordinates or city names. Therefore, the server behaves as a stateless service where each function call is independent.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1335,
        "completion_tokens": 277,
        "total_tokens": 1612
      },
      "function_count": 6,
      "functions": [
        "weather-forecast-server-get_weather_by_coordinates",
        "weather-forecast-server-chat_weather_assistant",
        "weather-forecast-server-get_live_temp",
        "weather-forecast-server-get_weather_by_city",
        "weather-forecast-server-weather_greeting",
        "weather-forecast-server-get_weather"
      ]
    },
    "The Verge News Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Verge News Server provides three read-only functions: `get-daily-news`, `get-weekly-news`, and `search-news`. All of these functions retrieve news data from The Verge's RSS feed based on time ranges or keyword queries. None of the available tools perform any create, update, delete, or configuration-setting operations that would modify persistent state. Each function operates independently, fetching data directly from an external source without relying on or altering any internal server state such as sessions, configurations, or stored data. There is no indication that the output or behavior of one function call affects another. Therefore, there are no stateful dependencies between function calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 713,
        "completion_tokens": 158,
        "total_tokens": 871
      },
      "function_count": 3,
      "functions": [
        "the-verge-news-server-get-daily-news",
        "the-verge-news-server-search-news",
        "the-verge-news-server-get-weekly-news"
      ]
    },
    "Game Trends": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the \"Game Trends\" MCP server are read-only functions that retrieve real-time or live data from external sources (e.g., Steam, Epic Games Store, SteamCharts). None of the functions perform create, update, delete, or configuration-setting operations that would modify persistent internal state. Each function operates independently and does not require prior setup (such as authentication, session initialization, or data storage) to function correctly. There is no indication that calling one function affects the behavior or output of another. The presence of `get_api_health` further suggests operational monitoring rather than state manipulation. Since all functions appear to be idempotent and state-independent, the server behaves in a stateless manner.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 789,
        "completion_tokens": 167,
        "total_tokens": 956
      },
      "function_count": 7,
      "functions": [
        "game-trends-get_api_health",
        "game-trends-get_epic_free_games",
        "game-trends-get_epic_trending_games",
        "game-trends-get_steam_top_sellers",
        "game-trends-get_all_trending_games",
        "game-trends-get_steam_trending_games",
        "game-trends-get_steam_most_played"
      ]
    },
    "Japanese Text Analyzer": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the \"Japanese Text Analyzer\" MCP server are stateless operations that process input (either a file path or direct text) and return analytical results without modifying any persistent system state. Each function operates independently:  \n- `count_chars`, `count_words`, `analyze_file` take a file path and read from it, but do not modify the file or store any runtime state.  \n- `count_clipboard_chars`, `count_clipboard_words`, `analyze_text` operate solely on the provided text input, with no side effects or stored context.  \n- There is no indication of configuration settings, session management, cached data, or shared mutable state being created or accessed across function calls.  \n- All parameters are explicitly passed in each call (e.g., language), and no function output appears to influence the behavior of another unless the user manually reuses the result.  \n\nThere are no create-update-delete patterns, no initialization requirements, and no evidence that calling one function alters the environment in a way that affects another. The server behaves as a collection of pure functions—same input always yields same output, regardless of call order or prior usage.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1500,
        "completion_tokens": 257,
        "total_tokens": 1757
      },
      "function_count": 6,
      "functions": [
        "japanese-text-analyzer-count_words",
        "japanese-text-analyzer-analyze_file",
        "japanese-text-analyzer-count_chars",
        "japanese-text-analyzer-count_clipboard_words",
        "japanese-text-analyzer-count_clipboard_chars",
        "japanese-text-analyzer-analyze_text"
      ]
    },
    "Bilibili API Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the Bilibili API Server are read-only operations that retrieve data based on input parameters without modifying any persistent state. None of the functions perform create, update, or delete operations. Each function operates independently and does not rely on side effects or state changes induced by prior function calls. For example:\n\n- `general_search`, `search_user`, and `get_precise_results` all take search terms and optional filters as inputs and return search results without indicating any session setup, configuration change, or stored context.\n- `get_video_danmaku` retrieves danmaku for a given BV ID, which is a purely idempotent operation—calling it multiple times with the same BV ID will yield the same result (assuming video danmaku content hasn't changed externally).\n- There is no evidence of shared sessions, authentication tokens, cached configurations, or user-specific contexts being established or used across function calls.\n\nFurthermore, none of the function descriptions or parameters suggest dependency on prior state (e.g., no requirement to call `search_user` before `get_precise_results`, or needing a session initialized via another tool). The absence of any state-modifying (write) operations strongly indicates a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1045,
        "completion_tokens": 271,
        "total_tokens": 1316
      },
      "function_count": 4,
      "functions": [
        "bilibili-api-server-get_precise_results",
        "bilibili-api-server-general_search",
        "bilibili-api-server-search_user",
        "bilibili-api-server-get_video_danmaku"
      ]
    },
    "Calculator Service": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "calculator-service-multiply"
      ]
    },
    "Semantic Scholar Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The Semantic Scholar Server provides read-only access to academic paper data, author information, and citation/reference relationships. All available functions—search_semantic_scholar, get_semantic_scholar_paper_details, get_semantic_scholar_author_details, and get_semantic_scholar_citations_and_references—are retrieval operations that do not create, modify, or delete any system state. There is no indication of configuration settings, session creation, authentication tokens, or cached data being stored server-side between calls. Each function operates independently based solely on its input parameters (e.g., query string, paper ID, author ID), with no evidence that the result of one function affects the behavior or output of another. The absence of write operations or shared mutable context strongly suggests a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 838,
        "completion_tokens": 183,
        "total_tokens": 1021
      },
      "function_count": 4,
      "functions": [
        "semantic-scholar-server-get_semantic_scholar_paper_details",
        "semantic-scholar-server-search_semantic_scholar",
        "semantic-scholar-server-get_semantic_scholar_author_details",
        "semantic-scholar-server-get_semantic_scholar_citations_and_references"
      ]
    },
    "Steam Statistics": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the Steam Statistics MCP server are read-only operations that retrieve data without modifying any persistent state. The functions `get_top_games`, `get_game_genres`, `get_popular_genres`, and `get_player_stats` all fetch public statistics or metadata based on either no parameters or externally provided identifiers (like `app_id` or `steam_id`). None of these functions create, update, or delete system state such as configurations, sessions, or stored data. There is no indication that calling one function alters the behavior or output of another. Each function call appears to be independent and idempotent, relying solely on external inputs or real-time data sources rather than internal mutable state. Therefore, there are no stateful dependencies between function calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 807,
        "completion_tokens": 178,
        "total_tokens": 985
      },
      "function_count": 4,
      "functions": [
        "steam-statistics-get_top_games",
        "steam-statistics-get_player_stats",
        "steam-statistics-get_popular_genres",
        "steam-statistics-get_game_genres"
      ]
    },
    "Google Workshop MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "After analyzing the provided tools in the Google Workshop MCP Server, there is no evidence that any function modifies persistent state or that any function depends on the side effects of another. All available functions—`simple_test`, `search_news`, `search_news_with_content`, and `compare_news_perspectives`—appear to be pure query operations that retrieve data based solely on input parameters (e.g., a keyword) without modifying any system state. None of the descriptions indicate creation, update, or deletion of resources, nor do they reference shared sessions, configurations, or stored context between calls. Each function operates independently and idempotently, returning results derived directly from external sources (e.g., news APIs) rather than internal mutable state. Therefore, there are no observable state dependencies between function calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 953,
        "completion_tokens": 185,
        "total_tokens": 1138
      },
      "function_count": 4,
      "functions": [
        "google-workshop-mcp-server-search_news_with_content",
        "google-workshop-mcp-server-compare_news_perspectives",
        "google-workshop-mcp-server-search_news",
        "google-workshop-mcp-server-simple_test"
      ]
    },
    "Fruit Data Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "fruit-data-server-get_fruit_info"
      ]
    },
    "Time Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "Both functions provided by the Time Server—`get_current_time` and `convert_time`—are stateless operations. Neither function modifies any persistent system state such as configurations, sessions, stored data, or global variables. Each function computes its result solely based on the input parameters provided in the individual call. There is no indication that calling one function affects the behavior or output of the other. Specifically:\n\n- `get_current_time` retrieves the current time in a specified timezone; it does not store or alter any context.\n- `convert_time` converts a given time from one timezone to another based purely on the source timezone, target timezone, and input time—all provided explicitly in the request.\n\nThere are no shared contexts, sessions, or configurations established or modified by these functions. No function depends on prior calls to set up required state. All operations are idempotent and self-contained.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 768,
        "completion_tokens": 201,
        "total_tokens": 969
      },
      "function_count": 4,
      "functions": [
        "time-server-get_current_time",
        "time-server-convert_time",
        "time-server-readableTime",
        "time-server-getTime"
      ]
    },
    "Deep Dive MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The provided tools, `get-alerts` and `get-forecast`, are both read-only operations that retrieve weather data based on explicit input parameters. Neither function modifies any system state—there are no indications of create, update, or delete operations. Each function operates independently using only the parameters provided in the request: `get-alerts` requires a two-letter state code, and `get-forecast` requires latitude and longitude coordinates. There is no shared context, session, configuration, or persistent data store implied by the tool definitions that would carry state across calls. Furthermore, there is no evidence that the output or execution of one function affects the behavior or result of the other. Without any state-modifying or state-dependent operations, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 760,
        "completion_tokens": 178,
        "total_tokens": 938
      },
      "function_count": 2,
      "functions": [
        "deep-dive-mcp-server-get-alerts",
        "deep-dive-mcp-server-get-forecast"
      ]
    },
    "Airbnb Search and Listing Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Airbnb Search and Listing Server provides two functions—`airbnb_search` and `airbnb_listing_details`—both of which are read-only operations that retrieve data based on explicit input parameters. Neither function performs any create, update, or delete operation that would modify persistent server-side state. All parameters required for each function (such as dates, guest counts, pricing, and listing ID) are passed directly in the request, with no indication that prior calls influence subsequent ones. There is no shared session, configuration, or context established across calls—for example, calling `airbnb_search` does not set a default location or date range that affects future `airbnb_listing_details` calls. Pagination via the `cursor` parameter in `airbnb_search` is stateless, as the cursor itself encodes all necessary context rather than relying on server-stored state. Similarly, both functions can accept overlapping parameters like `checkin`, `checkout`, and guest numbers, but these must be re-provided per call and are not retained between invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1106,
        "completion_tokens": 235,
        "total_tokens": 1341
      },
      "function_count": 2,
      "functions": [
        "airbnb-search-and-listing-server-airbnb_listing_details",
        "airbnb-search-and-listing-server-airbnb_search"
      ]
    },
    "Text Editor MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "text-editor-mcp-server-text_editor"
      ]
    },
    "Cal Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Cal Server provides mathematical and timestamp-related utilities that are purely functional in nature. Each tool operates independently and does not modify or rely on any shared, persistent state across invocations. Specifically:  \n- The `cal` tool evaluates a mathematical expression using built-in constants (PI, E, true, false) but does not allow mutation of these constants or introduce new ones. All evaluations are self-contained and deterministic based solely on the input expression.  \n- The `getDateByTimestamp` and `batchGetDateByTimestamp` tools convert timestamps to date strings without altering any internal configuration or storing data.  \n- The `getNow` tool returns the current timestamp with no side effects.  \n\nThere is no evidence of functions creating, updating, or deleting system state (e.g., variables, configurations, sessions). Furthermore, none of the functions require prior execution of another function to operate correctly. For example, calling `getNow` does not need to be preceded by any setup, and its result is independent of previous calls. Similarly, `cal` does not retain memory of past expressions or results.  \n\nAll operations are stateless: given the same inputs, they will always produce the same outputs, regardless of the order or history of previous calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 863,
        "completion_tokens": 275,
        "total_tokens": 1138
      },
      "function_count": 4,
      "functions": [
        "cal-server-getNow",
        "cal-server-getDateByTimestamp",
        "cal-server-batchGetDateByTimestamp",
        "cal-server-cal"
      ]
    },
    "Game Engine Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Game Engine Server exhibits clear stateful behavior based on the interaction between its tools and the design process it supports. The `gamedesignthinking` tool is designed to be called multiple times in sequence as part of a structured, iterative game design workflow. Each call contributes to or modifies an evolving internal game design state—such as defining mechanics, UI components, shaders, and player experience—which persists across calls. This state is not merely transient input but represents accumulated design decisions that build upon prior steps (e.g., setting `gameTitle` in the first thought, branching from previous thoughts, revising earlier decisions).\n\nCrucially, the `getGameSummary` tool likely reads and aggregates this accumulated design state to produce a coherent summary of the current game. Similarly, `exportGameDesign` must depend on the full set of previously provided design inputs to generate complete HTML documentation. These functions do not operate on isolated inputs; instead, they rely on the cumulative context established by prior invocations of `gamedesignthinking`. This creates a dependency where:\n\n- `gamedesignthinking` modifies persistent internal state (e.g., stores game title, mechanics, UI, shaders)\n- `getGameSummary` and `exportGameDesign` depend on that stored state to function meaningfully\n\nAdditionally, parameters like `branchFromThought`, `revisesThought`, and `thoughtNumber` imply temporal ordering and reference to prior steps, reinforcing that the server maintains a session-like memory of the design process. Without retaining state across calls, features like revisions, branching systems, and final export would be impossible.\n\nTherefore, the server maintains shared context across function calls, with later functions depending on earlier modifications—defining it as stateful.",
      "state_dependencies": [
        {
          "function_a": "gamedesignthinking",
          "function_b": "getGameSummary",
          "state_description": "Game design state (e.g., mechanics, UI, shaders, player experience) built incrementally by gamedesignthinking is read by getGameSummary to generate a summary"
        },
        {
          "function_a": "gamedesignthinking",
          "function_b": "exportGameDesign",
          "state_description": "Complete game design state accumulated through multiple gamedesignthinking calls is used by exportGameDesign to produce HTML documentation"
        }
      ],
      "token_usage": {
        "prompt_tokens": 2125,
        "completion_tokens": 493,
        "total_tokens": 2618
      },
      "function_count": 3,
      "functions": [
        "game-engine-server-getGameSummary",
        "game-engine-server-exportGameDesign",
        "game-engine-server-gamedesignthinking"
      ]
    },
    "Open Library MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "open-library-mcp-server-get_book_by_title"
      ]
    },
    "Aurora Documentation": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The available tools in the Aurora Documentation MCP server are purely read-only operations that do not modify any persistent state. Specifically:  \n- `search_docs` performs a query over documentation content but does not alter any data or configuration.  \n- `list_docs` returns a static listing of available documentation files without creating, updating, or deleting any resources.  \n- `get_doc_summary` retrieves a summary for a specified document based on its path, with no indication that it modifies state or relies on mutable context.  \n\nNone of the functions accept parameters that suggest side effects (e.g., no create, update, delete flags), and all appear designed for information retrieval only. There is no evidence of shared sessions, configurations set across calls, or dependencies where one function’s invocation alters the behavior of another. The system behaves like a static knowledge base API, typical of stateless services.  \n\nFurthermore, the descriptions emphasize searchability, access, and structured documentation—consistent with immutable or periodically updated content rather than interactive state manipulation. While it's theoretically possible that internal caching or session tracking exists outside the scope of the tool definitions, there is no observable interface-level state mutation or dependency.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 807,
        "completion_tokens": 260,
        "total_tokens": 1067
      },
      "function_count": 3,
      "functions": [
        "aurora-documentation-get_doc_summary",
        "aurora-documentation-list_docs",
        "aurora-documentation-search_docs"
      ]
    },
    "Calculate Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "calculate-server-calculate_expression"
      ]
    },
    "Add Numbers Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "add-numbers-server-add_numbers"
      ]
    },
    "Hugging Face MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available tools in the Hugging Face MCP Server are read-only operations that retrieve information from the Hugging Face Hub (e.g., models, datasets, papers, spaces, collections). None of the functions perform create, update, delete, or any other state-modifying actions. Each function operates independently and does not rely on prior function calls to succeed. For example, calling `search-models` does not alter any configuration, session, or context that would affect a subsequent call to `get-model-info`. There is no evidence of shared mutable state, persistent sessions, or configuration settings that carry over between requests. All functions are idempotent and require only their input parameters to function correctly. Therefore, there is no stateful behavior present.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1624,
        "completion_tokens": 174,
        "total_tokens": 1798
      },
      "function_count": 10,
      "functions": [
        "hugging-face-mcp-server-get-collection-info",
        "hugging-face-mcp-server-get-paper-info",
        "hugging-face-mcp-server-search-models",
        "hugging-face-mcp-server-search-spaces",
        "hugging-face-mcp-server-search-datasets",
        "hugging-face-mcp-server-get-dataset-info",
        "hugging-face-mcp-server-search-collections",
        "hugging-face-mcp-server-get-model-info",
        "hugging-face-mcp-server-get-space-info",
        "hugging-face-mcp-server-get-daily-papers"
      ]
    },
    "Domain Search - No API key required.": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "domain-search---no-api-key-required.-check_domain_availability"
      ]
    },
    "Cooking Units Converter": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available functions in the Cooking Units Converter MCP server—`convert_temperature`, `convert_volume`, and `convert_weight`—are pure conversion operations. Each function takes input parameters (value, source unit, target unit) and returns a converted value without modifying any persistent state. There is no indication that any function creates, updates, or deletes system state such as configurations, sessions, or stored data. Furthermore, none of the functions depend on prior calls or require setup from another function to operate correctly. Each conversion is self-contained and idempotent, meaning repeated calls with the same inputs yield the same outputs regardless of previous interactions. Therefore, there are no stateful dependencies between functions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1073,
        "completion_tokens": 162,
        "total_tokens": 1235
      },
      "function_count": 3,
      "functions": [
        "cooking-units-converter-convert_weight",
        "cooking-units-converter-convert_volume",
        "cooking-units-converter-convert_temperature"
      ]
    },
    "Time MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All functions in the Time MCP Server are stateless and purely computational or time-conversion operations. None of the tools modify persistent state (e.g., there are no create, update, or delete operations), and none of the functions depend on prior function calls to operate correctly. Each function takes explicit input parameters and returns results based solely on those inputs. For example:\n- `current_time` returns the current time based on optional formatting and timezone, with no side effects.\n- `relative_time`, `get_timestamp`, `convert_time`, `days_in_month`, and `get_week_year` all compute results from provided time strings or use the current system time independently, without relying on any stored context.\nThere is no shared session, configuration, or mutable state that persists across function calls. Every function call is independent and idempotent.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1181,
        "completion_tokens": 191,
        "total_tokens": 1372
      },
      "function_count": 6,
      "functions": [
        "time-mcp-server-days_in_month",
        "time-mcp-server-convert_time",
        "time-mcp-server-get_week_year",
        "time-mcp-server-get_timestamp",
        "time-mcp-server-relative_time",
        "time-mcp-server-current_time"
      ]
    },
    "Fetch Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available functions in the Fetch Server—`fetch_html`, `fetch_markdown`, `fetch_txt`, and `fetch_json`—are read-only operations that retrieve content from a given URL using HTTP GET semantics. None of these functions perform mutations such as creating, updating, or deleting resources on the server side. Each function operates independently, taking only a URL and optional headers as input, with no indication of shared mutable state, persistent sessions, cached configurations, or side effects that influence subsequent calls. There is no evidence that one function call alters the behavior or output of another. The tools appear to be stateless wrappers around HTTP fetching logic with format-specific parsing (e.g., converting HTML to Markdown or extracting text), which does not require maintaining context across requests.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 889,
        "completion_tokens": 179,
        "total_tokens": 1068
      },
      "function_count": 6,
      "functions": [
        "fetch-server-fetch_json",
        "fetch-server-fetch_markdown",
        "fetch-server-fetch",
        "fetch-server-fetch",
        "fetch-server-fetch_html",
        "fetch-server-fetch_txt"
      ]
    },
    "OSINT Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the OSINT Server are information retrieval functions that perform independent queries against external systems (e.g., WHOIS, DNS, network scanning). None of the functions have parameters or documented behaviors indicating they create, modify, or depend on persistent internal state. Each tool takes a target or domain as input and returns data based solely on that input, with no indication of side effects or shared context across calls. For example, calling `whois_lookup` does not alter the behavior of `nmap_scan`, and `dnstwist_lookup` does not rely on prior invocations of `dnsrecon_lookup`. The absence of any write, update, session management, or configuration-setting operations strongly suggests stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 962,
        "completion_tokens": 172,
        "total_tokens": 1134
      },
      "function_count": 7,
      "functions": [
        "osint-server-dnstwist_lookup",
        "osint-server-dig_lookup",
        "osint-server-nmap_scan",
        "osint-server-osint_overview",
        "osint-server-whois_lookup",
        "osint-server-dnsrecon_lookup",
        "osint-server-host_lookup"
      ]
    },
    "PubMed MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The PubMed MCP Server provides functions for searching and retrieving biomedical literature from PubMed, including keyword/advanced search, metadata retrieval, and PDF download. All available tools are read-only operations that query external data (PubMed articles) based on explicit input parameters such as keywords, PMIDs, or author names. None of the functions perform create, update, delete, or set operations that would alter server-side state. Each function operates independently, with no indication of shared sessions, persistent configurations, or cached states modified by prior calls. For example, calling `search_pubmed_key_words` does not affect the behavior of `get_pubmed_article_metadata` or `download_pubmed_pdf`; these latter functions rely solely on the provided `pmid`, not on any context established by previous calls. There is no evidence of internal state being modified or relied upon across function invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1168,
        "completion_tokens": 198,
        "total_tokens": 1366
      },
      "function_count": 4,
      "functions": [
        "pubmed-mcp-server-search_pubmed_key_words",
        "pubmed-mcp-server-get_pubmed_article_metadata",
        "pubmed-mcp-server-download_pubmed_pdf",
        "pubmed-mcp-server-search_pubmed_advanced"
      ]
    },
    "Remote Shell Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "remote-shell-server-shell-exec"
      ]
    },
    "Hugeicons MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The provided tools for the Hugeicons MCP Server—`list_icons`, `search_icons`, and `get_platform_usage`—are all read-only operations that do not modify any persistent state. There is no indication that any of these functions create, update, or delete data on the server side. Each function operates independently and does not rely on prior configuration, session setup, or stored context. For example:\n- `list_icons` retrieves a complete list of icons with no input parameters, suggesting it returns a static or globally available resource.\n- `search_icons` takes a query parameter but performs a search based solely on that input without implying any mutation or storage of state.\n- `get_platform_usage` returns platform-specific instructions based only on the provided platform name, again with no side effects indicated.\n\nThere are no function pairs where one sets up state (like a session, configuration, or stored value) that another depends on. All interactions appear to be stateless API calls typical of a content delivery or documentation service.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 719,
        "completion_tokens": 228,
        "total_tokens": 947
      },
      "function_count": 3,
      "functions": [
        "hugeicons-mcp-server-get_platform_usage",
        "hugeicons-mcp-server-search_icons",
        "hugeicons-mcp-server-list_icons"
      ]
    },
    "Multi LLM Cross-Check Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "multi-llm-cross-check-server-cross_check"
      ]
    },
    "TabNews Integration": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available tools in the TabNews Integration MCP server are read-only operations that retrieve data from the TabNews API. None of the functions perform create, update, delete, or any other state-modifying actions. Each function operates independently and does not rely on prior function calls to influence its behavior or output. There is no indication of shared mutable state, session management, configuration changes, or context propagation between function invocations. All parameters are explicitly provided in each call, and no side effects are evident from the function signatures or descriptions. Therefore, the server exhibits purely stateless behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1419,
        "completion_tokens": 141,
        "total_tokens": 1560
      },
      "function_count": 9,
      "functions": [
        "tabnews-integration-get comments",
        "tabnews-integration-get analytics root content published",
        "tabnews-integration-get contents",
        "tabnews-integration-get content",
        "tabnews-integration-get analytics user created",
        "tabnews-integration-get contents by user",
        "tabnews-integration-get rss feed",
        "tabnews-integration-get analytics child content published",
        "tabnews-integration-get status"
      ]
    },
    "GitHub Trending": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "Both available functions, `get_github_trending_repositories` and `get_github_trending_developers`, are read-only operations that retrieve publicly available trending data from GitHub based on input filters (language, time period, spoken language). Neither function performs any create, update, or delete operation that would modify server-side state. There is no indication that calling one function affects the behavior or output of the other. The functions do not rely on any shared mutable context, session, or configuration that persists across calls. Each function call is independent and idempotent, depending only on the provided parameters and external GitHub data, not on prior interactions with the MCP server.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 739,
        "completion_tokens": 159,
        "total_tokens": 898
      },
      "function_count": 2,
      "functions": [
        "github-trending-get_github_trending_developers",
        "github-trending-get_github_trending_repositories"
      ]
    },
    "Think Tool Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 6,
      "functions": [
        "think-tool-server-think",
        "think-mcp-server-think",
        "think-tool-server-think",
        "think-tool-server-get_thoughts",
        "think-tool-server-get_thought_stats",
        "think-tool-server-clear_thoughts"
      ]
    },
    "Earthdata MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The Earthdata MCP Server provides two tools—`search_earth_datasets` and `search_earth_datagranules`—both of which are read-only operations. Neither function modifies any system state, creates sessions, stores data, or alters configurations. Each function operates independently based on its input parameters (e.g., keywords, temporal range, bounding box) and does not rely on prior calls to function correctly. There is no indication that calling one function affects the behavior or output of the other. Both functions retrieve data from external sources using self-contained queries without establishing or depending on shared context, sessions, or persistent configurations. Therefore, there is strong evidence that this MCP server is stateless.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1109,
        "completion_tokens": 165,
        "total_tokens": 1274
      },
      "function_count": 2,
      "functions": [
        "earthdata-mcp-server-search_earth_datagranules",
        "earthdata-mcp-server-search_earth_datasets"
      ]
    },
    "Subway MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "subway-mcp-server-subway"
      ]
    },
    "Math Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The Math Server provides two functions, `add` and `multiply`, both of which are pure mathematical operations. Each function takes two integer inputs and returns a deterministic result based solely on those inputs, with no indication of internal state modification or persistence. There are no create, update, or delete operations that affect shared state, and no function depends on the outcome or side effects of another. Both functions operate independently and statelessly, requiring no session, configuration, or context to be maintained between calls. The tool descriptions and parameter schemas further confirm that these are isolated computations without side effects.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 674,
        "completion_tokens": 141,
        "total_tokens": 815
      },
      "function_count": 2,
      "functions": [
        "math-server-multiply",
        "math-server-add"
      ]
    },
    "Bitrefill MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The available tools in the Bitrefill MCP Server—`search`, `detail`, `categories`, and `ping`—are all read-only operations that do not appear to modify any persistent server-side state. There are no evident functions for creating, updating, or deleting resources (e.g., no `create_cart`, `add_to_cart`, or `set_preference` functions). While the `search` tool accepts a `cart` parameter, merely passing a cart ID does not imply state modification unless there is an associated side effect (e.g., updating cart contents), but no such function exists in the toolset to perform that update. Similarly, there is no indication of session creation, authentication, or configuration-setting functions that would alter global or user-specific context. All functions can be invoked independently without relying on prior calls. For example, `categories` can be called before `search` as a suggestion for better filtering, but `search` does not require it to function—it only improves query precision. This represents a best-practice usage pattern, not a true state dependency. The `ping` tool is purely diagnostic and state-independent. Therefore, there is no evidence of stateful behavior across function calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1200,
        "completion_tokens": 268,
        "total_tokens": 1468
      },
      "function_count": 4,
      "functions": [
        "bitrefill-mcp-server-ping",
        "bitrefill-mcp-server-search",
        "bitrefill-mcp-server-categories",
        "bitrefill-mcp-server-detail"
      ]
    },
    "Skincare": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "skincare-get-selfie-analysis"
      ]
    },
    "Model Context Protocol Reference Servers": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing all available tools in the MCP server, there is no evidence of functions that modify persistent state or depend on prior function calls. Each tool operates independently and does not create, update, or rely on shared context, sessions, configurations, or data across invocations:\n\n- **echo**: Simply returns the input message without modifying any system state.\n- **add**: Performs a pure mathematical operation with no side effects.\n- **printEnv**: Reads environment variables but does not alter them or depend on prior function calls (environment variables are assumed to be fixed at server startup unless externally modified, which is outside the scope of this analysis).\n- **longRunningOperation**: Simulates a long-running task with progress updates but does not store state between calls or affect other functions.\n- **sampleLLM**: Queries an LLM based on a prompt; while LLM sampling could theoretically involve state (e.g., conversation history), the tool interface here provides no mechanism for maintaining such state, and each call appears isolated.\n- **getTinyImage**: Returns a static image constant (MCP_TINY_IMAGE) without altering or depending on mutable state.\n\nNo function pair exhibits a producer-consumer relationship where one sets up state for another. All functions are idempotent and stateless in their defined interfaces.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1104,
        "completion_tokens": 283,
        "total_tokens": 1387
      },
      "function_count": 6,
      "functions": [
        "model-context-protocol-reference-servers-printEnv",
        "model-context-protocol-reference-servers-echo",
        "model-context-protocol-reference-servers-add",
        "model-context-protocol-reference-servers-sampleLLM",
        "model-context-protocol-reference-servers-getTinyImage",
        "model-context-protocol-reference-servers-longRunningOperation"
      ]
    },
    "UNHCR Population Data Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The UNHCR Population Data Server provides read-only access to refugee statistics through three functions: `get_population_data`, `get_rsd_applications`, and `get_rsd_decisions`. All of these tools are query operations that retrieve data based on input parameters (such as country codes, years, and breakdown flags) without any indication of modifying server state. There are no functions for creating, updating, or deleting data; no session management, authentication, or configuration-setting operations; and no shared context or persistent variables implied in the tool descriptions. Each function call is self-contained and idempotent—calling one does not alter the behavior or output of another. The absence of any write-side operations or references to shared mutable state strongly indicates a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 2340,
        "completion_tokens": 178,
        "total_tokens": 2518
      },
      "function_count": 3,
      "functions": [
        "unhcr-population-data-server-get_population_data",
        "unhcr-population-data-server-get_rsd_applications",
        "unhcr-population-data-server-get_rsd_decisions"
      ]
    },
    "Movie Recommender": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "movie-recommender-get_movies"
      ]
    },
    "Coin MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Coin MCP Server provides three read-only functions—`getTokenPrice`, `getAnnoucements`, and `getCoinInfo`—all of which retrieve data from external sources (e.g., Bitget API) based solely on input parameters. None of the functions perform create, update, or delete operations that would modify persistent state on the server. Each function call is independent and does not rely on prior interactions. There is no indication of shared context, session management, configuration changes, or stored data between calls. All responses are derived directly from real-time external APIs using provided parameters, with no evidence of internal state being altered or depended upon across function invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1017,
        "completion_tokens": 160,
        "total_tokens": 1177
      },
      "function_count": 3,
      "functions": [
        "coin-mcp-server-getCoinInfo",
        "coin-mcp-server-getTokenPrice",
        "coin-mcp-server-getAnnoucements"
      ]
    },
    "Flux ImageGen Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The Flux ImageGen Server provides three tools—`generateImageUrl`, `generateImage`, and `listImageModels`—all of which appear to be stateless operations. Each function generates an image or lists models based solely on the input parameters provided in the request, with no indication that any persistent state is modified or relied upon across calls.  \n\n- `generateImageUrl` and `generateImage` both generate images from a prompt and optional parameters (model, size, seed, etc.), but these are self-contained operations typical of stateless AI image generation APIs. The inclusion of parameters like `seed`, `model`, and `enhance` allows for configurability per request but does not imply persistence of those settings beyond the scope of a single call.  \n- `outputPath`, `fileName`, and similar parameters in `generateImage` specify where to save the output, but this is a one-time file system operation per request and does not establish shared state affecting future calls.  \n- `listImageModels` returns a static list of available models and has no dependency on prior function calls or mutable state.  \n\nThere is no evidence of functions creating sessions, setting global configurations, storing data for later retrieval, or requiring context established by previous calls. All inputs are explicitly passed as parameters, and outputs do not rely on hidden or persistent server-side state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1213,
        "completion_tokens": 296,
        "total_tokens": 1509
      },
      "function_count": 3,
      "functions": [
        "flux-imagegen-server-generateImageUrl",
        "flux-imagegen-server-generateImage",
        "flux-imagegen-server-listImageModels"
      ]
    },
    "Hang-InThere MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The two available tools, `get_weather_tool` and `get_restaurant_tool`, are both read-only functions that retrieve external data based on explicit input parameters (city name and address, respectively). Neither function performs any create, update, or delete operation that would modify persistent state on the server. Each function operates independently, relying solely on the input provided at call time, with no indication of shared context, session state, configuration, or side effects that affect future calls. There is no evidence that calling one function alters the behavior or output of the other. Both appear to be stateless queries to external services using transient inputs.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 711,
        "completion_tokens": 151,
        "total_tokens": 862
      },
      "function_count": 2,
      "functions": [
        "hang-inthere-mcp-server-get_restaurant_tool",
        "hang-inthere-mcp-server-get_weather_tool"
      ]
    },
    "Weather API Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "weather-api-server-getLiveTemperature"
      ]
    },
    "Databutton": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "databutton-submit_app_requirements"
      ]
    },
    "Pokémon Information Server": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Pokémon Information Server exhibits clear stateful behavior due to the presence of battle-related functions that depend on shared, persistent context across multiple calls. Specifically, the `start_battle` function initiates a battle session between two Pokémon, which implies the creation of transient server-side state (e.g., current health, turn order, active moves, items). Subsequent functions like `make_move` and `use_item` do not include parameters to identify a battle or specify participant Pokémon, indicating they operate on an implicit, currently active battle context established by `start_battle`. This means calling `make_move` without an ongoing battle would likely fail or be invalid, demonstrating dependency on prior state modification. There is no corresponding `end_battle` or explicit context parameter, further supporting that state is maintained server-side between calls.",
      "state_dependencies": [
        {
          "function_a": "start_battle",
          "function_b": "make_move",
          "state_description": "Battle context (e.g., player and opponent Pokémon, health, turn state) created by start_battle is required for make_move to execute a move in the ongoing battle"
        },
        {
          "function_a": "start_battle",
          "function_b": "use_item",
          "state_description": "Battle context including available items and participant states set by start_battle is required for use_item to function"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1239,
        "completion_tokens": 304,
        "total_tokens": 1543
      },
      "function_count": 7,
      "functions": [
        "pokémon-information-server-start_battle",
        "pokémon-information-server-random_pokemon_by_type",
        "pokémon-information-server-random_pokemon",
        "pokémon-information-server-random_pokemon_from_region",
        "pokémon-information-server-use_item",
        "pokémon-information-server-pokemon_query",
        "pokémon-information-server-make_move"
      ]
    },
    "arXiv Research Assistant": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "All available functions in the \"arXiv Research Assistant\" MCP server are read-only operations that retrieve data from arXiv.org based on provided parameters. None of the functions perform create, update, or delete actions that would modify persistent state. Specifically:  \n- `scrape_recent_category_papers` retrieves a list of recent papers in a given category.  \n- `search_papers` performs a keyword-based search over arXiv metadata.  \n- `get_paper_info` fetches detailed information for a specific paper by ID.  \n- `analyze_trends` analyzes trends in a category over a time window, likely using underlying search or scrape functionality.  \n\nThere is no indication that any function sets configuration, stores data, creates sessions, or alters system state that would affect subsequent calls. Each function operates independently with fully specified inputs and does not rely on side effects from prior invocations. Furthermore, there are no shared contexts, sessions, or configurations implied by the tool descriptions or parameters.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 950,
        "completion_tokens": 226,
        "total_tokens": 1176
      },
      "function_count": 4,
      "functions": [
        "arxiv-research-assistant-get_paper_info",
        "arxiv-research-assistant-analyze_trends",
        "arxiv-research-assistant-scrape_recent_category_papers",
        "arxiv-research-assistant-search_papers"
      ]
    },
    "text2image": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "text2image-image_generation"
      ]
    },
    "Airbnb Search and Listing Details Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Both available functions, `airbnb_search` and `airbnb_listing_details`, are read-only operations that retrieve data based on explicit input parameters. There is no indication that either function performs a create, update, or delete operation that would modify persistent server-side state. The `airbnb_search` function returns listings based on search criteria, while `airbnb_listing_details` fetches details for a specific listing by ID—both operate independently and do not rely on any prior function call to set up context such as sessions, authentication tokens, or configuration settings. No shared mutable state (e.g., cached filters, active sessions, or user context) is evident from the tool definitions. All necessary parameters for each function are provided directly in the request, and there are no side effects that would influence subsequent calls. While both tools support overlapping parameters like dates and guest counts, these are passed explicitly and do not imply state persistence across calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1118,
        "completion_tokens": 212,
        "total_tokens": 1330
      },
      "function_count": 2,
      "functions": [
        "airbnb-search-and-listing-details-server-airbnb_search",
        "airbnb-search-and-listing-details-server-airbnb_listing_details"
      ]
    },
    "MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 6,
      "functions": [
        "mcp-server-get_bmi",
        "mcp-server-get_definitions",
        "mcp-server-validatePhoneNumber",
        "mcp-server-add",
        "mcp-server-checkBalance",
        "mcp-server-multiply"
      ]
    },
    "计算器(Calc MCP)": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "All provided functions in the 计算器(Calc MCP) server are pure mathematical operations that take input parameters and return results without modifying or relying on any shared, persistent state. Each function (e.g., add, subtract, multiply, divide, power, sqrt, evaluate_expression) computes its output solely based on the current input arguments and does not create, update, or depend on external state such as configurations, sessions, caches, or stored data. There is no indication of side effects like writing to a history log, updating a context variable, or maintaining state between calls—even though the overview mentions \"history record management,\" none of the exposed tools provide access to history retrieval or mutation operations (e.g., get_history, clear_history), nor does any tool description suggest that calling one function affects the behavior of another. Therefore, no functional dependency on shared state exists among the available tools.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1617,
        "completion_tokens": 204,
        "total_tokens": 1821
      },
      "function_count": 7,
      "functions": [
        "计算器(calc-mcp)-power",
        "计算器(calc-mcp)-evaluate_expression",
        "计算器(calc-mcp)-divide",
        "计算器(calc-mcp)-sqrt",
        "计算器(calc-mcp)-subtract",
        "计算器(calc-mcp)-multiply",
        "计算器(calc-mcp)-add"
      ]
    },
    "Disney App MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "disney-app-mcp-server-get_character_info"
      ]
    },
    "Weather Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The available tools in the Weather Server—`ping`, `health_check`, `get_weather`, and `compare_weather`—are all read-only operations that retrieve weather data or perform connectivity checks. None of these functions have parameters or descriptions indicating they create, modify, or delete persistent state (e.g., no configuration updates, session creation, stored preferences, or cached data modifications). Each function call appears to be independent and self-contained, relying only on input parameters (like city name or units) rather than any shared context established by prior calls. There is no evidence of inter-function state dependencies such as one function setting a unit preference that another inherits, or establishing a session used across requests. All outputs are derived directly from external weather data sources based on explicit inputs, not internal server state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 808,
        "completion_tokens": 184,
        "total_tokens": 992
      },
      "function_count": 6,
      "functions": [
        "weather-server-get_weather",
        "weather-server-get-alerts",
        "weather-server-get-forecast",
        "weather-server-health_check",
        "weather-server-compare_weather",
        "weather-server-ping"
      ]
    },
    "Lotus Wisdom": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Lotus Wisdom MCP server exhibits clear stateful behavior based on its core design and tool functionality. The primary tool, `lotuswisdom`, maintains a dynamic internal journey state that evolves across multiple function calls. This state includes the current position in the contemplative path (e.g., tag sequence), movement between wisdom domains, step tracking (`stepNumber`, `totalSteps`), and whether further steps are needed (`nextStepNeeded`). Each invocation of the `lotuswisdom` tool builds upon and modifies this shared context—subsequent calls depend on the prior state to determine the next appropriate tag or domain. Additionally, the use of meditative pauses (`meditate` tag) introduces time-dependent reflection points that influence later stages of insight formation, implying temporal state progression.\n\nCrucially, the server uses a **journey** and **domainJourney** mechanism that records the full path of tags and domain transitions (e.g., \"open → examine → direct → transform\"), which persists and evolves across calls. This accumulated path directly affects how future steps are interpreted and what insights emerge. Furthermore, the `lotuswisdom_summary` tool likely reads from this same ongoing journey state, depending on the history established by prior `lotuswisdom` calls, indicating inter-function state dependency.\n\nThe workflow explicitly states that the tool “tracks both your tag path and wisdom domain movements,” confirming persistent state maintenance. Since the output and progression logic depend on this evolving context, and because one call can alter the trajectory for subsequent ones, the system is inherently stateful.",
      "state_dependencies": [
        {
          "function_a": "lotuswisdom",
          "function_b": "lotuswisdom",
          "state_description": "The lotuswisdom tool maintains an evolving tag journey (e.g., 'open → examine → direct') and domain journey (e.g., 'process_flow → meta_cognitive'), which influences the behavior and recommended next steps in subsequent calls."
        },
        {
          "function_a": "lotuswisdom",
          "function_b": "lotuswisdom_summary",
          "state_description": "The lotuswisdom_summary tool retrieves and displays the current state of the contemplative journey, which is built incrementally by prior invocations of the lotuswisdom tool."
        },
        {
          "function_a": "lotuswisdom",
          "function_b": "lotuswisdom",
          "state_description": "Use of the 'meditate' tag with a specified duration alters the flow by introducing a reflective pause; the resulting insights affect later steps, indicating state persistence through time-aware processing."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1637,
        "completion_tokens": 558,
        "total_tokens": 2195
      },
      "function_count": 2,
      "functions": [
        "lotus-wisdom-lotuswisdom",
        "lotus-wisdom-lotuswisdom_summary"
      ]
    },
    "Two Truths and a Twist": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server exhibits clear stateful behavior, as multiple functions interact with shared, persistent game state that evolves across calls. Specifically, the `create_round` function initializes a new round of the game and returns a `round_id`, which is then required by several other functions (`submit_guess`, `reveal_twist`, `get_round`) to operate correctly. This indicates that the server maintains internal state associated with each round (e.g., the question, statements, and game progress), and subsequent operations depend on this previously established context.\n\nFurthermore, `get_last_round` implies that the server tracks the most recently created round, reinforcing that state is preserved and ordered over time. Similarly, `get_stats` likely aggregates data accumulated over multiple rounds (e.g., correct guesses, rounds played), suggesting that the server maintains cumulative state across interactions.\n\nThe dependency on `round_id` across multiple tool calls confirms that the outcome and validity of certain functions are contingent upon prior invocations—specifically, a round must first be created before it can be guessed on or revealed. This inter-function reliance on shared, mutable state is a hallmark of stateful systems.",
      "state_dependencies": [
        {
          "function_a": "create_round",
          "function_b": "submit_guess",
          "state_description": "Round ID and associated statements created by create_round are required for submit_guess to process a player's guess"
        },
        {
          "function_a": "create_round",
          "function_b": "reveal_twist",
          "state_description": "Round ID and the twist configuration from create_round are necessary for reveal_twist to disclose the correct answer"
        },
        {
          "function_a": "create_round",
          "function_b": "get_round",
          "state_description": "The round details (question, statements) stored after calling create_round are retrieved via get_round using the round ID"
        },
        {
          "function_a": "create_round",
          "function_b": "get_last_round",
          "state_description": "The most recent round created via create_round is tracked internally and returned by get_last_round"
        }
      ],
      "token_usage": {
        "prompt_tokens": 1235,
        "completion_tokens": 452,
        "total_tokens": 1687
      },
      "function_count": 6,
      "functions": [
        "two-truths-and-a-twist-submit_guess",
        "two-truths-and-a-twist-get_stats",
        "two-truths-and-a-twist-get_round",
        "two-truths-and-a-twist-reveal_twist",
        "two-truths-and-a-twist-get_last_round",
        "two-truths-and-a-twist-create_round"
      ]
    },
    "AIDaily": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "aidaily-spider_ai_daily"
      ]
    },
    "Weather App Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "weather-app-server-get_live_temp"
      ]
    },
    "Prolog Execution and Querying": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The Prolog Execution and Querying MCP server maintains a shared knowledge base or program state across function calls. The `exec` function is used to load and execute Prolog code, which can define predicates, facts, and rules in the Prolog engine's database. Once defined, these predicates persist and can be queried later using the `query` function. Additionally, the `discover` function reveals the currently available predicates, which directly reflects the state modified by prior `exec` calls. This indicates that the outcome of `query` and `discover` depends on the side effects of previous `exec` calls—clear evidence of stateful behavior. For example, executing a program that defines a fact like `parent(john, mary).` and then querying `parent(john, X)` would only succeed if the prior `exec` call had loaded that fact. Without persistent state, such cross-call dependencies would not be possible.",
      "state_dependencies": [
        {
          "function_a": "exec",
          "function_b": "query",
          "state_description": "Prolog facts and rules defined via exec are required for successful queries in subsequent query calls"
        },
        {
          "function_a": "exec",
          "function_b": "discover",
          "state_description": "The set of available predicates returned by discover is modified by Prolog code executed through exec"
        }
      ],
      "token_usage": {
        "prompt_tokens": 646,
        "completion_tokens": 301,
        "total_tokens": 947
      },
      "function_count": 3,
      "functions": [
        "prolog-execution-and-querying-query",
        "prolog-execution-and-querying-discover",
        "prolog-execution-and-querying-exec"
      ]
    },
    "Medicine MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "medicine-mcp-server-get_medicine_info"
      ]
    },
    "MyFirstMCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The MCP server \"MyFirstMCP\" provides only two functions: `add` and `subtract`. Both functions are pure mathematical operations that take input parameters and return results without modifying or depending on any external or shared state. There is no indication that either function creates, updates, or relies on persistent data, configurations, sessions, or context between calls. The functions do not perform any side effects such as storing values, initializing resources, or altering system state. Since all outputs depend solely on the provided inputs and there are no inter-function dependencies involving shared state, the server is stateless.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 735,
        "completion_tokens": 143,
        "total_tokens": 878
      },
      "function_count": 2,
      "functions": [
        "myfirstmcp-subtract",
        "myfirstmcp-add"
      ]
    },
    "Sequential Thinking": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 2,
      "functions": [
        "sequential-thinking-sequentialthinking",
        "reference-servers-sequentialthinking"
      ]
    },
    "Lilith Shell": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "lilith-shell-execute_command"
      ]
    },
    "Call For Papers": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "call-for-papers-get_events"
      ]
    },
    "Yanyue Cigarette Data": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "yanyue-cigarette-data-searchCigarettes"
      ]
    },
    "Sequential Thinking Tools": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "sequential-thinking-tools-sequentialthinking_tools"
      ]
    },
    "PentestThinking": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "pentestthinking-pentestthinkingMCP"
      ]
    },
    "mcp服务": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The provided MCP server exposes two functions: `query_weather` and `add`. Neither of these functions indicates a modification of persistent state across calls. The `query_weather` function retrieves weather data for a specified city, which is a read-only operation that does not alter any internal state. Similarly, the `add` function performs a pure arithmetic operation (summing two integers), which is deterministic and independent of any external or shared state. There is no indication that either function creates, updates, or depends on configurations, sessions, cached data, or contextual information from prior calls. Furthermore, there are no observable side effects or shared resources between function invocations. Without evidence of state mutation or inter-function state dependency, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 664,
        "completion_tokens": 174,
        "total_tokens": 838
      },
      "function_count": 2,
      "functions": [
        "mcp服务-query_weather",
        "mcp服务-add"
      ]
    },
    "Pinterest MCP Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The provided tools in the Pinterest MCP Server—`pinterest_search`, `pinterest_get_image_info`, and `pinterest_search_and_download`—are all self-contained operations that do not appear to modify or depend on persistent server-side state.  \n\n- `pinterest_search` performs a stateless search based on a keyword and returns results without indicating any side effects (e.g., no session creation, configuration change, or data persistence).  \n- `pinterest_get_image_info` retrieves information about a specific image using its URL, which is an idempotent read operation that does not rely on prior function calls unless the caller provides the URL.  \n- `pinterest_search_and_download` combines searching and downloading but appears to be a convenience wrapper that likely internally performs both actions without storing state accessible by other functions.  \n\nThere is no evidence of shared mutable state such as user sessions, cached configurations, stored authentication tokens, or persisted search contexts across function calls. All inputs are explicitly passed (e.g., keyword, image_url), and outputs are deterministic based on those inputs. No function creates or updates a resource that another function later reads or modifies in a dependent way.\n\nAdditionally, none of the parameters suggest maintaining a session context (e.g., session_id, context_token), and the optional `headless` parameter is local to each call and does not imply global state mutation.\n\nTherefore, the server behaves statelessly: each function call stands alone and does not affect the behavior of others.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 812,
        "completion_tokens": 324,
        "total_tokens": 1136
      },
      "function_count": 3,
      "functions": [
        "pinterest-mcp-server-pinterest_search_and_download",
        "pinterest-mcp-server-pinterest_get_image_info",
        "pinterest-mcp-server-pinterest_search"
      ]
    },
    "Film Information Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "film-information-server-get_films"
      ]
    },
    "Pote": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "The provided tools for the Pote MCP server are all read-only operations. None of the functions perform create, update, or delete actions that would modify persistent state on the server. Specifically:  \n- `get-all-breeds` retrieves a list of dog breeds (read operation).  \n- `get-breed-info` fetches detailed information about a breed by ID (read operation).  \n- `get-breed-posts` returns a list of posts for a given breed (read operation).  \n- `get-post-by-id` provides detailed information about a specific post using an ID obtained from `get-breed-posts` (read operation).  \n\nWhile `get-post-by-id` depends on an ID returned by `get-breed-posts`, this is not stateful behavior in the context of MCP statefulness. This dependency is merely data flow between functions — it does not imply that one function modifies internal server state that alters the behavior of another. There is no evidence of shared mutable context, session state, configuration changes, or side effects that persist across calls. All functions are idempotent and independent in terms of system state.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 993,
        "completion_tokens": 251,
        "total_tokens": 1244
      },
      "function_count": 4,
      "functions": [
        "pote-get-all-breeds",
        "pote-get-breed-info",
        "pote-get-post-by-id",
        "pote-get-breed-posts"
      ]
    },
    "Project Ingest MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Project Ingest MCP Server provides read-only access to project metadata and file contents. All available tools—`project_summary`, `project_tree`, and `file_content`—are idempotent retrieval functions that do not modify any system state. There is no indication of any function creating, updating, or deleting data on the server side. Each function operates independently based solely on input parameters (e.g., project path, file path) and does not rely on or alter shared context, sessions, or configurations. No function sets up state that another function depends on. The server appears designed for passive data exposure rather than maintaining interactive or mutable state across calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 797,
        "completion_tokens": 157,
        "total_tokens": 954
      },
      "function_count": 3,
      "functions": [
        "project-ingest-mcp-server-project_tree",
        "project-ingest-mcp-server-file_content",
        "project-ingest-mcp-server-project_summary"
      ]
    },
    "Docfork": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "docfork-get-library-docs"
      ]
    },
    "RapidAPI": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "rapidapi-get_user_recent_tweets"
      ]
    },
    "CiteAssist MCP": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "Both available functions, `get_citeas_data` and `get_scholar_data`, are purely retrieval operations that fetch citation data from external sources (CiteAs and Google Scholar, respectively). Neither function modifies any system state, creates sessions, stores data, or alters configurations. Each function operates independently, taking input parameters (`resource`, `query`, `results`) and returning formatted results without side effects. There is no indication that the output or behavior of one function depends on a prior call to the other. Both tools appear to be stateless read operations with no shared context, session, or persistent configuration established across calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 703,
        "completion_tokens": 152,
        "total_tokens": 855
      },
      "function_count": 2,
      "functions": [
        "citeassist-mcp-get_citeas_data",
        "citeassist-mcp-get_scholar_data"
      ]
    },
    "Multi-Agent Debate": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "multi-agent-debate-multiagentdebate"
      ]
    },
    "Book Search Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "book-search-server-search_books_tool"
      ]
    },
    "Soz MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "soz-mcp-server-get_advice"
      ]
    },
    "Nationality Detection Service": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "nationality-detection-service-get_nationality"
      ]
    },
    "XPath Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Both available functions, `xpath` and `xpathwithurl`, are purely functional and do not modify or rely on any persistent state. The `xpath` function takes XML content and a query as input and returns results based solely on those inputs. Similarly, `xpathwithurl` fetches content from a given URL, applies an XPath query to it, and returns the result—without storing or altering any server-side state. There are no indications of configuration settings, session management, cached data, or side effects that persist across calls. Each function operates independently and idempotently, with outputs determined entirely by their inputs.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 775,
        "completion_tokens": 151,
        "total_tokens": 926
      },
      "function_count": 2,
      "functions": [
        "xpath-server-xpath",
        "xpath-server-xpathwithurl"
      ]
    },
    "byted fe resources": {
      "is_stateful": false,
      "confidence": 0.3,
      "reasoning": "The provided MCP server \"byted fe resources\" lacks an overview or functional description, and no concrete functions are listed for analysis. The available tools—`search_component`, `search_components_multi`, and `list_library_components`—are read-only operations focused on discovering or listing components within a library. These tools do not inherently modify system state, create sessions, store data, or establish configurations that affect future calls. Without evidence of functions that mutate state or depend on prior execution context, there is insufficient basis to conclude stateful behavior. However, due to the absence of detailed function specifications or documentation, the confidence level remains low.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 728,
        "completion_tokens": 151,
        "total_tokens": 879
      },
      "function_count": 3,
      "functions": [
        "byted-fe-resources-search_components_multi",
        "byted-fe-resources-search_component",
        "byted-fe-resources-list_library_components"
      ]
    },
    "DateTime Context Provider": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "datetime-context-provider-get_current_datetime"
      ]
    },
    "Finance MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Finance MCP Server provides two read-only functions: `get_price` and `get_news`. Both functions retrieve real-time financial data based on input parameters (ticker, period, count) without any indication of modifying server-side state. There are no operations for creating, updating, or deleting data, and no shared context such as sessions, authentication tokens, or configurations is exposed in the tool definitions. Each function call is self-contained and idempotent—calling `get_price` or `get_news` with the same arguments will consistently return the same type of result based on current market data, not on prior interactions. Since neither function alters persistent state nor depends on state established by the other, there is no evidence of stateful behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 692,
        "completion_tokens": 173,
        "total_tokens": 865
      },
      "function_count": 2,
      "functions": [
        "finance-mcp-server-get_news",
        "finance-mcp-server-get_price"
      ]
    },
    "PubMedSearch": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The PubMedSearch MCP server provides two functions—`search_pubmed` and `format_paper_details`—neither of which explicitly modifies or maintains persistent state on the server side. The `search_pubmed` function performs a query against the PubMed database based on input parameters (keywords, authors, number of results) and returns metadata including PubMed IDs. It does not create, update, or delete any system state; it is a pure read operation. The `format_paper_details` function takes a list of PubMed IDs as input and retrieves detailed information for those articles. While it is common to use the output of `search_pubmed` (i.e., the PubMed IDs) as input to `format_paper_details`, this represents a data flow between client-side operations rather than server-side state persistence. There is no indication that calling one function alters internal server state (e.g., caching, session storage, configuration changes) that subsequently affects the behavior of another function. Both functions are idempotent and stateless: given the same inputs, they will produce the same outputs regardless of prior calls. No shared sessions, configurations, or contexts are established or maintained across function invocations.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 971,
        "completion_tokens": 261,
        "total_tokens": 1232
      },
      "function_count": 2,
      "functions": [
        "pubmedsearch-format_paper_details",
        "pubmedsearch-search_pubmed"
      ]
    },
    "Weibo Hot Search Service - 获取微博热搜": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "weibo-hot-search-service---获取微博热搜-get_hot_search"
      ]
    },
    "Markdown Downloader": {
      "is_stateful": true,
      "confidence": 0.95,
      "reasoning": "The MCP server maintains and modifies persistent state across function calls, particularly around the configuration and organization of the download directory and its contents. Specifically, the `set_download_directory` function modifies the global download directory used by the system, which affects subsequent operations such as `download_markdown`, `list_downloaded_files`, and `create_subdirectory`. These functions implicitly depend on the configured download directory to determine where files are saved or listed from. Additionally, calling `create_subdirectory` changes the filesystem state within the download root, which can later be accessed by `download_markdown` (via the `subdirectory` parameter) and `list_downloaded_files`. This interdependence between functions that set state and those that rely on it confirms stateful behavior.",
      "state_dependencies": [
        {
          "function_a": "set_download_directory",
          "function_b": "download_markdown",
          "state_description": "The download directory set by set_download_directory determines where markdown files are saved when download_markdown is called."
        },
        {
          "function_a": "set_download_directory",
          "function_b": "list_downloaded_files",
          "state_description": "The download directory set by set_download_directory determines the root location from which list_downloaded_files retrieves files."
        },
        {
          "function_a": "set_download_directory",
          "function_b": "create_subdirectory",
          "state_description": "The download directory set by set_download_directory determines the parent folder in which create_subdirectory creates new subdirectories."
        },
        {
          "function_a": "create_subdirectory",
          "function_b": "download_markdown",
          "state_description": "Subdirectories created by create_subdirectory can be used in download_markdown's subdirectory parameter to organize downloaded files."
        },
        {
          "function_a": "create_subdirectory",
          "function_b": "list_downloaded_files",
          "state_description": "Subdirectories created by create_subdirectory affect the listing output of list_downloaded_files when a specific subdirectory is queried."
        }
      ],
      "token_usage": {
        "prompt_tokens": 834,
        "completion_tokens": 439,
        "total_tokens": 1273
      },
      "function_count": 5,
      "functions": [
        "markdown-downloader-set_download_directory",
        "markdown-downloader-download_markdown",
        "markdown-downloader-list_downloaded_files",
        "markdown-downloader-create_subdirectory",
        "markdown-downloader-get_download_directory"
      ]
    },
    "weatherr": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "weatherr-get_live_temp"
      ]
    },
    "Human Messages Prompt Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "human-messages-prompt-server-human-messages-prompts"
      ]
    },
    "Korea Tour": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "After analyzing the provided tools in the \"Korea Tour\" MCP server, there is no evidence of stateful behavior. All available functions are read-only operations that retrieve tourism-related data based on input parameters without modifying any persistent state. Specifically:  \n\n1. **No function modifies persistent state**:  \n   - `get_area_code` retrieves area codes based on optional parent codes — it does not create, update, or delete any data.  \n   - `search_tour_info` performs a search query using criteria like area code, content type, or keyword — this is purely a retrieval operation.  \n   - `get_detail_common` fetches detailed information for a given `contentId` — again, this is a read-only lookup.  \n\n2. **No dependency on prior state changes**:  \n   Each function operates independently and relies solely on the parameters passed during the call. For example, calling `get_detail_common` does not depend on whether `get_area_code` was previously called; it only requires a valid `contentId`, which can be obtained through external means (e.g., from a previous search result).  \n\n3. **No setup-use function pairs indicating shared state**:  \n   While one might logically call `get_area_code` before `search_tour_info` to obtain valid area codes, this represents a logical workflow rather than a state dependency. The server does not store or remember the result of `get_area_code`. Similarly, results from `search_tour_info` may include `contentId`s used in `get_detail_common`, but this is data flow via client-side chaining, not server-side state persistence.  \n\n4. **No shared context, session, or configuration**:  \n   None of the functions accept or require tokens, session IDs, or configuration handles. There is no indication of authentication, caching, or mutable server-side context that persists across calls.  \n\nTherefore, all interactions with this MCP server are stateless: each function call is self-contained and produces the same result for the same inputs, regardless of prior calls.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1289,
        "completion_tokens": 437,
        "total_tokens": 1726
      },
      "function_count": 3,
      "functions": [
        "korea-tour-get_area_code",
        "korea-tour-search_tour_info",
        "korea-tour-get_detail_common"
      ]
    },
    "Decision Framework Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "decision-framework-server-decisionFramework"
      ]
    },
    "Car Price Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "All available functions in the Car Price Server are read-only operations that retrieve data from external sources (FIPE API) without modifying any internal or persistent state. The functions `get_car_brands`, `search_car_price`, and `get_vehicles_by_type` do not create, update, or delete any server-side resources. Each function operates independently, with no indication of shared mutable context, session dependencies, or configuration changes that persist across calls. Inputs to each function are self-contained, and outputs depend solely on input parameters and the external API's current state—not on prior function invocations. Therefore, there is no stateful interaction between functions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 831,
        "completion_tokens": 154,
        "total_tokens": 985
      },
      "function_count": 3,
      "functions": [
        "car-price-server-get_vehicles_by_type",
        "car-price-server-search_car_price",
        "car-price-server-get_car_brands"
      ]
    },
    "Kroki Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Kroki Server provides two tools—`generate_diagram_url` and `download_diagram`—both of which are stateless conversion operations. Each function takes diagram source code (e.g., Mermaid or PlantUML) and rendering parameters as input and produces a URL or file output without modifying any persistent server-side state. There is no indication that either function creates, updates, or relies on shared context, sessions, configurations, or stored data across calls. Both functions operate independently: generating a diagram URL does not affect the behavior of downloading a diagram, and vice versa. All necessary information for each operation is provided explicitly in the function parameters (type, content, format, etc.), with no reliance on prior interactions. Furthermore, Kroki.io is known to be a stateless diagram rendering service that does not maintain user sessions or persist diagram data beyond request processing.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1126,
        "completion_tokens": 200,
        "total_tokens": 1326
      },
      "function_count": 2,
      "functions": [
        "kroki-server-download_diagram",
        "kroki-server-generate_diagram_url"
      ]
    },
    "Simple MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 2,
      "functions": [
        "simple-mcp-server-say_hello",
        "simple-mcp-server-reverse_text_tool"
      ]
    },
    "Crossref MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The Crossref MCP Server provides read-only access to academic metadata through four tools: `search_works_by_query`, `get_work_metadata`, `search_journals`, and `search_funders`. All of these tools are query-based and do not perform any create, update, or delete operations. Each function operates independently and retrieves data directly from the Crossref API based on input parameters without modifying any system state. There is no indication that calling one function affects the behavior or output of another. Parameters such as `mailto` are optional and used for identification or rate-limiting purposes but do not establish persistent state across function calls. No session management, configuration changes, or data storage mechanisms are exposed or implied in the tool definitions. Therefore, there is no evidence of stateful behavior.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 970,
        "completion_tokens": 182,
        "total_tokens": 1152
      },
      "function_count": 4,
      "functions": [
        "crossref-mcp-server-search_works_by_query",
        "crossref-mcp-server-get_work_metadata",
        "crossref-mcp-server-search_funders",
        "crossref-mcp-server-search_journals"
      ]
    },
    "SchoolFoods": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "schoolfoods-get_school_meal"
      ]
    },
    "Server Time": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Both functions provided by the \"Server Time\" MCP server—`get_current_time` and `convert_time`—are stateless in nature. The `get_current_time` function retrieves the current time in a specified timezone, which is a read-only operation based on external system time and does not modify any internal persistent state. The `convert_time` function performs a deterministic transformation of a given time from one timezone to another, based solely on its input parameters and public timezone rules, with no reliance on prior function calls or stored context. There is no indication that either function creates, updates, or depends on any shared session, configuration, or stored data across invocations. All outputs depend exclusively on the inputs provided during each individual call.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 685,
        "completion_tokens": 173,
        "total_tokens": 858
      },
      "function_count": 2,
      "functions": [
        "server-time-convert_time",
        "server-time-get_current_time"
      ]
    },
    "Python Safe Sandbox Execution Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "python-safe-sandbox-execution-server-python_exec"
      ]
    },
    "CoinGecko MCP Server": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "All available tools in the CoinGecko MCP Server are read-only functions that retrieve cryptocurrency data from external APIs. None of the functions perform create, update, or delete operations that would modify persistent state on the server. Each function operates independently and does not rely on any prior function call to set up context, configuration, session, or stored data. For example:\n\n- `coingecko_price` retrieves price data based on input parameters without altering any system state.\n- `coingecko_list` returns a static list of supported coins; it does not depend on prior calls.\n- `coingecko_coin_data` fetches detailed coin information using only its input arguments.\n- `coingecko_trending` returns publicly available trending data with no required setup.\n\nThere is no evidence of shared mutable state, session management, configuration flags, or caching mechanisms that affect behavior across calls. All outputs are determined solely by the inputs and real-time API responses, indicating a stateless design.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1021,
        "completion_tokens": 221,
        "total_tokens": 1242
      },
      "function_count": 4,
      "functions": [
        "coingecko-mcp-server-coingecko_list",
        "coingecko-mcp-server-coingecko_trending",
        "coingecko-mcp-server-coingecko_price",
        "coingecko-mcp-server-coingecko_coin_data"
      ]
    },
    "Coin Price Fetcher": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The three available functions — `getTokenPrice`, `getAnnoucements`, and `getCoinInfo` — are all read-only operations that retrieve data from external sources (e.g., cryptocurrency prices, announcements, and token metadata). None of the functions perform any create, update, or delete actions that would modify persistent server-side state. Each function operates independently, taking input parameters (like token name or announcement type) and returning corresponding data without relying on or altering shared context, sessions, configurations, or internal state. There is no indication of session management, authentication setup, caching dependencies, or configuration changes that would couple the behavior of one function call to another. All responses appear to be derived solely from the provided inputs and real-time external data via Bitget integration, with no side effects.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1029,
        "completion_tokens": 184,
        "total_tokens": 1213
      },
      "function_count": 3,
      "functions": [
        "coin-price-fetcher-getAnnoucements",
        "coin-price-fetcher-getTokenPrice",
        "coin-price-fetcher-getCoinInfo"
      ]
    },
    "MCP Directory Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "mcp-directory-server-get_definitions"
      ]
    },
    "Quick Chart Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "quick-chart-server-GetChartImgLink"
      ]
    },
    "Endless": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Both available functions, `get-alerts` and `get-forecast`, are read-only operations that retrieve weather data based on explicit input parameters (state code or geographic coordinates). Neither function has parameters or documented behavior suggesting they modify server-side state (e.g., no create, update, or delete semantics). There is no indication that calling one function affects the outcome of the other. The tools operate independently, with no shared context such as sessions, configurations, or stored data that persist across calls. Without any write operations or dependencies on prior execution state, the server behaves statelessly.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 728,
        "completion_tokens": 142,
        "total_tokens": 870
      },
      "function_count": 2,
      "functions": [
        "endless-get-forecast",
        "endless-get-alerts"
      ]
    },
    "Pump.fun Data Fetch Tool": {
      "is_stateful": false,
      "confidence": 0.98,
      "reasoning": "The provided tools in the Pump.fun Data Fetch Tool MCP server are all read-only operations that retrieve data without any indication of modifying persistent state. Specifically:  \n- `get_featured_coins` retrieves a list of featured coins with optional filtering and pagination.  \n- `get_coins` retrieves a list of coins with sorting, ordering, and filtering options.  \n- `get_coin_info` fetches detailed information about a specific coin using its mint ID.  \n\nNone of the functions have parameters or descriptions suggesting they perform create, update, or delete operations. There is no evidence of configuration settings being altered, sessions being established, or data being stored across calls. All functions appear to be independent, stateless queries to a backend data source. Furthermore, there are no shared contexts, session tokens, or configurations implied in the function signatures or descriptions that would persist across requests.  \n\nSince no function modifies state and no function depends on prior side effects from another, the server behaves in a purely stateless manner.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 940,
        "completion_tokens": 227,
        "total_tokens": 1167
      },
      "function_count": 3,
      "functions": [
        "pump.fun-data-fetch-tool-get_coin_info",
        "pump.fun-data-fetch-tool-get_featured_coins",
        "pump.fun-data-fetch-tool-get_coins"
      ]
    },
    "Lulu Print": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Both available functions in the Lulu Print MCP server—`calculate-print-job-cost` and `get-product-details`—are read-only operations that do not modify any persistent state. The `get-product-details` function retrieves static product information based on a provided product ID, while `calculate-print-job-cost` computes a cost estimate using input parameters (product ID and quantity) without creating or altering any job state. Neither function creates, updates, or deletes resources on the server. There is no indication that calling one function affects the behavior or output of the other, nor is there evidence of shared mutable context, sessions, or configurations between calls. All inputs are explicitly passed as parameters, and no side effects or persistent state modifications are implied by the tool descriptions.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 722,
        "completion_tokens": 177,
        "total_tokens": 899
      },
      "function_count": 2,
      "functions": [
        "lulu-print-get-product-details",
        "lulu-print-calculate-print-job-cost"
      ]
    },
    "Open Book": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "open-book-search_books_tool"
      ]
    },
    "Chromium Latest Commit": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "chromium-latest-commit-get_chromium_latest_commit"
      ]
    },
    "Drawing Tool for AI Assistants": {
      "is_stateful": true,
      "confidence": 1.0,
      "reasoning": "The Drawing Tool for AI Assistants MCP server exhibits clear stateful behavior. The tool functions operate on a shared drawing canvas that persists across function calls. Specifically, `drawing_generateCanvas` creates and initializes a canvas (i.e., width and height), which establishes the foundational state required for subsequent drawing operations. Without this initial canvas, drawing operations like `drawing_fillRectangle` would have no target surface to modify. Furthermore, `drawing_fillRectangle` alters the persistent state of the canvas by filling a region with a specified color—this change is retained and affects future operations. Finally, both `drawing_getCanvasPng` and `drawing_getCanvasData` retrieve the current state of the canvas, meaning their output directly depends on prior calls to `drawing_generateCanvas` and any number of `drawing_fillRectangle` invocations. This sequence of setup → modification → retrieval based on shared, persistent state confirms the server is stateful.",
      "state_dependencies": [
        {
          "function_a": "drawing_generateCanvas",
          "function_b": "drawing_fillRectangle",
          "state_description": "The canvas dimensions and existence created by drawing_generateCanvas are required for drawing_fillRectangle to operate on a valid drawing surface."
        },
        {
          "function_a": "drawing_generateCanvas",
          "function_b": "drawing_getCanvasPng",
          "state_description": "The canvas initialized by drawing_generateCanvas must exist for drawing_getCanvasPng to encode it into a PNG image."
        },
        {
          "function_a": "drawing_generateCanvas",
          "function_b": "drawing_getCanvasData",
          "state_description": "The canvas initialized by drawing_generateCanvas must exist for drawing_getCanvasData to retrieve its pixel data."
        },
        {
          "function_a": "drawing_fillRectangle",
          "function_b": "drawing_getCanvasPng",
          "state_description": "The modifications made by drawing_fillRectangle (filled rectangles) affect the image content returned by drawing_getCanvasPng."
        },
        {
          "function_a": "drawing_fillRectangle",
          "function_b": "drawing_getCanvasData",
          "state_description": "The pixel changes applied by drawing_fillRectangle directly influence the JSON pixel data returned by drawing_getCanvasData."
        }
      ],
      "token_usage": {
        "prompt_tokens": 1030,
        "completion_tokens": 478,
        "total_tokens": 1508
      },
      "function_count": 4,
      "functions": [
        "drawing-tool-for-ai-assistants-drawing_getCanvasPng",
        "drawing-tool-for-ai-assistants-drawing_getCanvasData",
        "drawing-tool-for-ai-assistants-drawing_fillRectangle",
        "drawing-tool-for-ai-assistants-drawing_generateCanvas"
      ]
    },
    "Language Detection Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "language-detection-server-detect"
      ]
    },
    "Code Runner MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "code-runner-mcp-server-run-code"
      ]
    },
    "UseWebhook": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "usewebhook-generate_webhook"
      ]
    },
    "Visual Reasoning Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "visual-reasoning-server-visualReasoning"
      ]
    },
    "Weather Query Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The Weather Query Server provides two functions: `get_alerts` and `get_forecast`. Upon analysis, neither function modifies persistent state nor depends on prior function calls.  \n\n- `get_forecast` takes latitude and longitude as input and returns weather forecast data. It is a pure read operation with no indication of modifying server state or storing data across calls.  \n- `get_alerts` is described as retrieving content from www.baidu.com when invoked, which appears unrelated to weather functionality and more like a mislabeled or incorrectly documented tool. However, even with this anomaly, there is no evidence that it sets state used by `get_forecast` or any other function. Its parameter \"state\" may suggest configuration, but without indication that this affects other tools or persists across calls, it does not establish statefulness.  \n\nThere are no create/update/delete operations, no shared sessions, configurations, or context between function calls. Both functions appear to be independent, stateless queries based solely on their input parameters.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 676,
        "completion_tokens": 229,
        "total_tokens": 905
      },
      "function_count": 4,
      "functions": [
        "weather-query-server-get_forecast",
        "weather-mcp-server-get_forecast",
        "weather-mcp-server-get_alerts",
        "weather-query-server-get_alerts"
      ]
    },
    "Structured Argumentation Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "structured-argumentation-server-structuredArgumentation"
      ]
    },
    "Cat Facts Service": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "cat-facts-service-cat_fact"
      ]
    },
    "Book MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "book-mcp-server-search_books_tool"
      ]
    },
    "Call For Papers MCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "call-for-papers-mcp-get_events"
      ]
    },
    "OpsNow Cost MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "opsnow-cost-mcp-server-get-cost"
      ]
    },
    "Dictionary Service": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "dictionary-service-get_definitions"
      ]
    },
    "Recipe Assistant Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "recipe-assistant-server-search_meal"
      ]
    },
    "MCP Client Chatbot": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "mcp-client-chatbot-get_weather"
      ]
    },
    "Map MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "map-mcp-server-navigate_to"
      ]
    },
    "Dictionary MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "dictionary-mcp-server-get_definitions"
      ]
    },
    "Example MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "example-mcp-server-hello"
      ]
    },
    "Weather Service": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "weather-service-get_live_temp"
      ]
    },
    "smithery-hello": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "smithery-hello-hello"
      ]
    },
    "Sourcebot Code Search Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The Sourcebot Code Search Server provides read-only operations for searching code, listing repositories, and retrieving file source. None of the available tools (search_code, list_repos, get_file_source) perform mutations or modify any system state. Each function operates independently based on input parameters and does not rely on prior side effects from other function calls. For example, while filterByRepoIds in search_code requires knowledge of repository IDs that can be obtained via list_repos, this is a data dependency—not a stateful one—because the behavior of search_code does not change based on previous calls; it only requires correct input formatting. Similarly, calling get_file_source does not depend on having previously called list_repos in terms of runtime state—it only needs accurate repoId and fileName values. There is no evidence of shared mutable context, sessions, configurations, or cached state that persists across and influences function behavior. All interactions are idempotent and stateless.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 1417,
        "completion_tokens": 216,
        "total_tokens": 1633
      },
      "function_count": 3,
      "functions": [
        "sourcebot-code-search-server-list_repos",
        "sourcebot-code-search-server-get_file_source",
        "sourcebot-code-search-server-search_code"
      ]
    },
    "Movie Information Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "movie-information-server-search_movie"
      ]
    },
    "Linkd Model Context Protocol Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "linkd-model-context-protocol-server-add_two_numbers"
      ]
    },
    "Terminal MCP Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "terminal-mcp-server-execute_command"
      ]
    },
    "MCP Python Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "mcp-python-server-get_definitions"
      ]
    },
    "360 Weather MCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "360-weather-mcp-get_live_temp"
      ]
    },
    "Brazilian Postal Code Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "brazilian-postal-code-server-consultar-cep"
      ]
    },
    "Python MCP Server Template": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "python-mcp-server-template-weather_tool"
      ]
    },
    "News Feed Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "Both available functions, `getNews` and `getArticles`, are read-only operations that retrieve information (latest news flashes and in-depth articles) about the cryptocurrency domain. Neither function has parameters that suggest mutation capabilities (such as creating, updating, or deleting data), and there is no indication that calling one function alters any underlying system state that would affect the behavior of the other. Both tools appear to independently fetch publicly available, aggregated content from RSS feeds without requiring or maintaining user-specific context, sessions, configurations, or stored data across calls. There is no evidence of shared mutable state, dependency on prior invocations, or side effects that persist beyond individual requests.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 629,
        "completion_tokens": 158,
        "total_tokens": 787
      },
      "function_count": 2,
      "functions": [
        "news-feed-server-getNews",
        "news-feed-server-getArticles"
      ]
    },
    "Mobile Challenge Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "mobile-challenge-server-get_definitions"
      ]
    },
    "Calculator Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "calculator-server-calculate"
      ]
    },
    "Public Holidays Service": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "public-holidays-service-check_holiday"
      ]
    },
    "chinarailway MCP 服务端": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "chinarailway-mcp-服务端-search"
      ]
    },
    "Email Sender Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "email-sender-server-send_email"
      ]
    },
    "DuckDuckGo Search Server": {
      "is_stateful": false,
      "confidence": 0.95,
      "reasoning": "The DuckDuckGo Search Server provides two tools—`search` and `fetch_content`—neither of which appear to modify or depend on persistent state across calls. The `search` function performs a query against DuckDuckGo and returns results without indication that it stores data, sets configurations, or creates sessions. The `fetch_content` function retrieves content from a given URL independently of any prior search operation. While one might logically call `search` first and then `fetch_content` on a resulting URL, this represents a logical workflow rather than a stateful dependency. There is no evidence that the outcome of `fetch_content` depends on the prior execution of `search`, nor do these functions share mutable context, session state, or configuration that persists across invocations. Both functions are idempotent and operate as pure read operations based solely on their input parameters.",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 707,
        "completion_tokens": 201,
        "total_tokens": 908
      },
      "function_count": 2,
      "functions": [
        "duckduckgo-search-server-fetch_content",
        "duckduckgo-search-server-search"
      ]
    },
    "Dictionary": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "dictionary-get_definitions"
      ]
    },
    "SET-MCP": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "set-mcp-get_financial_statement"
      ]
    },
    "Weather Forecast Service": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "weather-forecast-service-get_live_temp"
      ]
    },
    "Metacognitive Monitoring Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "metacognitive-monitoring-server-metacognitiveMonitoring"
      ]
    },
    "mcpLatest Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "mcplatest-server-validate_address_tool"
      ]
    },
    "MCP-WORD Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "mcp-word-server-get_live_temp"
      ]
    },
    "MCP Test Server": {
      "is_stateful": false,
      "confidence": 1.0,
      "reasoning": "MCP server has only one function, so there cannot be state dependencies between functions",
      "state_dependencies": [],
      "token_usage": {
        "prompt_tokens": 0,
        "completion_tokens": 0,
        "total_tokens": 0
      },
      "function_count": 1,
      "functions": [
        "mcp-test-server-add"
      ]
    }
  },
  "failed_servers": []
}