from typing import Dict, List, Any, Optional
from datetime import datetime

import sys
import os

# State Manager Injection
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if parent_dir not in sys.path:
    sys.path.append(parent_dir)

try:
    from state_manager import sys_state
except ImportError:
    pass # Fallback handled inside call_external_api checks or mock



def _original_call_external_api(tool_name: str) -> Dict[str, Any]:
    """
    Simulates fetching data from external API for npm package quality analysis.

    Returns:
        Dict with simple fields only (str, int, float, bool):
        - query_packages_0 (str): First package name in query
        - query_packages_1 (str): Second package name in query
        - result_0_package_input (str): Original input string for first package
        - result_0_package_name (str): Resolved name of first package
        - result_0_status (str): Status of analysis for first package
        - result_0_error (str or None): Error message for first package (None if no error)
        - result_0_message (str): Human-readable summary for first package
        - result_0_data_analyzed_at (str): ISO 8601 timestamp when analysis was performed for first package
        - result_0_data_version_in_score (str): Version used to calculate quality score for first package
        - result_0_data_quality_score (float): Quality score for first package (0–1)
        - result_1_package_input (str): Original input string for second package
        - result_1_package_name (str): Resolved name of second package
        - result_1_status (str): Status of analysis for second package
        - result_1_error (str or None): Error message for second package (None if no error)
        - result_1_message (str): Human-readable summary for second package
        - result_1_data_analyzed_at (str): ISO 8601 timestamp when analysis was performed for second package
        - result_1_data_version_in_score (str): Version used to calculate quality score for second package
        - result_1_data_quality_score (float): Quality score for second package (0–1)
    """
    return {
        "query_packages_0": "lodash",
        "query_packages_1": "express",
        "result_0_package_input": "lodash",
        "result_0_package_name": "lodash",
        "result_0_status": "success",
        "result_0_error": None,
        "result_0_message": "Package analysis completed successfully.",
        "result_0_data_analyzed_at": datetime.utcnow().isoformat() + "Z",
        "result_0_data_version_in_score": "4.17.21",
        "result_0_data_quality_score": 0.95,
        "result_1_package_input": "express",
        "result_1_package_name": "express",
        "result_1_status": "success",
        "result_1_error": None,
        "result_1_message": "Package analysis completed successfully.",
        "result_1_data_analyzed_at": datetime.utcnow().isoformat() + "Z",
        "result_1_data_version_in_score": "4.18.2",
        "result_1_data_quality_score": 0.87,
    }


def npm_sentinel_mcp_npmQuality(packages: List[str]) -> Dict[str, Any]:
    """
    Analyze package quality metrics for a list of npm package names.

    Args:
        packages (List[str]): List of package names to analyze.

    Returns:
        Dict containing:
        - queryPackages (List[str]): list of package names that were included in the query
        - results (List[Dict]): list of result objects for each package with fields:
          - packageInput (str): original input string for the package
          - packageName (str): resolved name of the package analyzed
          - status (str): status of the analysis process
          - error (str or None): error message if analysis failed, otherwise None
          - message (str): human-readable summary of the result
          - data (Dict): detailed quality metrics including:
            - analyzedAt (str): ISO 8601 timestamp of analysis
            - versionInScore (str): version used for quality score
            - qualityScore (float): numerical quality score (0–1)
    """
    if not packages:
        raise ValueError("Parameter 'packages' is required and must be a non-empty list.")

    # Call external API to get simulated data
    api_data = call_external_api("npm-sentinel-mcp-npmQuality", **locals())

    # Construct queryPackages
    query_packages = [
        api_data.get("query_packages_0", ""),
        api_data.get("query_packages_1", "")
    ]
    # Filter out empty values and limit to provided packages
    query_packages = [pkg for pkg in query_packages if pkg][:len(packages)]

    # Construct results list
    results: List[Dict[str, Any]] = []

    for i in range(2):  # Process up to 2 results as generated by API
        prefix = f"result_{i}"
        package_input = api_data.get(f"{prefix}_package_input")
        if not package_input:
            continue

        # Only include packages that were in the input
        if package_input not in packages:
            continue

        result: Dict[str, Any] = {
            "packageInput": package_input,
            "packageName": api_data[f"{prefix}_package_name"],
            "status": api_data[f"{prefix}_status"],
            "error": api_data[f"{prefix}_error"],
            "message": api_data[f"{prefix}_message"],
            "data": {
                "analyzedAt": api_data[f"{prefix}_data_analyzed_at"],
                "versionInScore": api_data[f"{prefix}_data_version_in_score"],
                "qualityScore": api_data[f"{prefix}_data_quality_score"]
            }
        }
        results.append(result)

    return {
        "queryPackages": query_packages,
        "results": results
    }

# Auto-Injected Stateful Wrapper
def call_external_api(tool_name: str, **kwargs) -> Dict[str, Any]:
    # 1. Execute original mock to get schema-compliant result
    result = _original_call_external_api(tool_name)
    
    # 2. Stateful Side-Effects (Heuristic)
    try:
        cmd = kwargs.get("command", "") or tool_name

        # WRITE / CREATE
        if "write" in cmd or "create" in cmd or "save" in cmd or "update" in cmd:
            path = kwargs.get("path")
            content = kwargs.get("content") or kwargs.get("file_text") or kwargs.get("text")
            if path and content:
                sys_state.write_file(path, content)
                
        # READ / VIEW (Inject State)
        if "read" in cmd or "view" in cmd or "cat" in cmd or "search" in cmd or "list" in cmd:
            path = kwargs.get("path")
            if path:
                real_content = sys_state.read_file(path)
                if real_content is not None:
                    result["content"] = real_content
    except Exception:
        pass 
    return result
