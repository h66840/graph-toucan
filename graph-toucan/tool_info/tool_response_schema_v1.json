{
  "pokémcp-random-pokemon-by-type": {
    "tool_name": "pokémcp-random-pokemon-by-type",
    "output_schema_raw": "**output_schema**  \nname: [str, name of the random Pokémon]  \npokedex_number: [int, National Pokédex number of the Pokémon]  \ntypes: [List[str], list of the Pokémon's types (e.g., ['Psychic'], ['Grass', 'Dark'])]  \nheight: [float, height of the Pokémon in meters]  \nweight: [float, weight of the Pokémon in kilograms]  \nabilities: [List[str], list of the Pokémon's abilities]  \ndescription: [str, flavor description of the Pokémon, including behavioral or ecological traits]  \nsuccess: [bool, whether the request was successful (True if Pokémon data is returned, False if retrieval failed)]  \nerror_message: [str, message explaining failure if success is False, otherwise null or empty]\n\n**brief_explain**  \nThe schema captures all structured information from both successful and failed responses, separating semantic fields like name, stats, types, and abilities while indicating success status and including an error message when applicable. It supports variable-length lists for types and abilities and maintains clarity through atomic, well-typed fields.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "name",
          "type": "str",
          "description": "name of the random Pokémon"
        },
        {
          "name": "pokedex_number",
          "type": "int",
          "description": "National Pokédex number of the Pokémon"
        },
        {
          "name": "types",
          "type": "List[str]",
          "description": "list of the Pokémon's types (e.g., ['Psychic'], ['Grass', 'Dark'])"
        },
        {
          "name": "height",
          "type": "float",
          "description": "height of the Pokémon in meters"
        },
        {
          "name": "weight",
          "type": "float",
          "description": "weight of the Pokémon in kilograms"
        },
        {
          "name": "abilities",
          "type": "List[str]",
          "description": "list of the Pokémon's abilities"
        },
        {
          "name": "description",
          "type": "str",
          "description": "flavor description of the Pokémon, including behavioral or ecological traits"
        },
        {
          "name": "success",
          "type": "bool",
          "description": "whether the request was successful (True if Pokémon data is returned, False if retrieval failed)"
        },
        {
          "name": "error_message",
          "type": "str",
          "description": "message explaining failure if success is False, otherwise null or empty"
        }
      ],
      "brief_explain": "The schema captures all structured information from both successful and failed responses, separating semantic fields like name, stats, types, and abilities while indicating success status and including an error message when applicable. It supports variable-length lists for types and abilities and maintains clarity through atomic, well-typed fields."
    },
    "tool_schema": {
      "function": {
        "description": "Get a random Pokémon of a specific type",
        "name": "pokémcp-random-pokemon-by-type",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "type": {
              "description": "The Pokémon type (e.g., fire, water, grass, etc.)",
              "type": "string"
            }
          },
          "required": [
            "type"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-get_problem": {
    "tool_name": "leetcode-get_problem",
    "output_schema_raw": "**output_schema**  \ntitleSlug: [str, URL slug identifier of the problem]  \nproblem: [Dict, contains detailed information about the LeetCode problem, including title, content, difficulty, tags, code templates, test cases, hints, and similar questions]  \nproblem.titleSlug: [str, URL slug identifier of the problem (repeated inside problem object)]  \nproblem.questionId: [str, unique question ID assigned by LeetCode]  \nproblem.title: [str, full title of the problem]  \nproblem.content: [str, HTML-formatted problem description including examples, constraints, and follow-up questions]  \nproblem.difficulty: [str, difficulty level of the problem: \"Easy\", \"Medium\", or \"Hard\"]  \nproblem.topicTags: [List[str], list of topic tags associated with the problem such as \"array\", \"sliding-window\", \"database\", etc.]  \nproblem.codeSnippets: [List[Dict], list of code templates for different programming languages, each containing 'lang', 'langSlug', and 'code' fields]  \nproblem.codeSnippets[].lang: [str, name of the programming language (e.g., \"C++\", \"Java\", \"Python3\")]  \nproblem.codeSnippets[].langSlug: [str, URL-friendly language identifier (e.g., \"cpp\", \"java\", \"python3\")]  \nproblem.codeSnippets[].code: [str, starter code template for the problem in that language]  \nproblem.exampleTestcases: [str or Dict, example input test cases; may be plain string for non-SQL problems or structured JSON for SQL problems containing table headers and rows]  \nproblem.hints: [List[str], list of hint strings to guide problem-solving approach]  \nproblem.similarQuestions: [List[Dict], list of similar problems with 'titleSlug' and 'difficulty' fields]\n\n**brief_explain**  \nThe output schema captures all structural components of a LeetCode problem returned by the API, including metadata, problem statement, solution hints, starter code per language, test cases, and related problems. It supports both algorithmic and SQL-type problems through flexible typing of `exampleTestcases`. Each semantic unit is separated into its own field for precise access.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "titleSlug",
          "type": "str",
          "description": "URL slug identifier of the problem"
        },
        {
          "name": "problem",
          "type": "Dict",
          "description": "contains detailed information about the LeetCode problem, including title, content, difficulty, tags, code templates, test cases, hints, and similar questions"
        },
        {
          "name": "problem.titleSlug",
          "type": "str",
          "description": "URL slug identifier of the problem (repeated inside problem object)"
        },
        {
          "name": "problem.questionId",
          "type": "str",
          "description": "unique question ID assigned by LeetCode"
        },
        {
          "name": "problem.title",
          "type": "str",
          "description": "full title of the problem"
        },
        {
          "name": "problem.content",
          "type": "str",
          "description": "HTML-formatted problem description including examples, constraints, and follow-up questions"
        },
        {
          "name": "problem.difficulty",
          "type": "str",
          "description": "difficulty level of the problem: \"Easy\", \"Medium\", or \"Hard\""
        },
        {
          "name": "problem.topicTags",
          "type": "List[str]",
          "description": "list of topic tags associated with the problem such as \"array\", \"sliding-window\", \"database\", etc."
        },
        {
          "name": "problem.codeSnippets",
          "type": "List[Dict]",
          "description": "list of code templates for different programming languages, each containing 'lang', 'langSlug', and 'code' fields"
        },
        {
          "name": "problem.codeSnippets[].lang",
          "type": "str",
          "description": "name of the programming language (e.g., \"C++\", \"Java\", \"Python3\")"
        },
        {
          "name": "problem.codeSnippets[].langSlug",
          "type": "str",
          "description": "URL-friendly language identifier (e.g., \"cpp\", \"java\", \"python3\")"
        },
        {
          "name": "problem.codeSnippets[].code",
          "type": "str",
          "description": "starter code template for the problem in that language"
        },
        {
          "name": "problem.exampleTestcases",
          "type": "str or Dict",
          "description": "example input test cases; may be plain string for non-SQL problems or structured JSON for SQL problems containing table headers and rows"
        },
        {
          "name": "problem.hints",
          "type": "List[str]",
          "description": "list of hint strings to guide problem-solving approach"
        },
        {
          "name": "problem.similarQuestions",
          "type": "List[Dict]",
          "description": "list of similar problems with 'titleSlug' and 'difficulty' fields"
        }
      ],
      "brief_explain": "The output schema captures all structural components of a LeetCode problem returned by the API, including metadata, problem statement, solution hints, starter code per language, test cases, and related problems. It supports both algorithmic and SQL-type problems through flexible typing of `exampleTestcases`. Each semantic unit is separated into its own field for precise access."
    },
    "tool_schema": {
      "function": {
        "description": "Retrieves details about a specific LeetCode problem, including its description, examples, constraints, and related information",
        "name": "leetcode-get_problem",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "titleSlug": {
              "description": "The URL slug/identifier of the problem (e.g., 'two-sum', 'add-two-numbers') as it appears in the LeetCode URL",
              "type": "string"
            }
          },
          "required": [
            "titleSlug"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-list_problem_solutions": {
    "tool_name": "leetcode-list_problem_solutions",
    "output_schema_raw": "**output_schema**  \nquestionSlug: [str, URL slug of the LeetCode problem for which solutions are retrieved]  \nsolutionArticles: [Dict, contains pagination info and list of solution articles with their metadata. Keys: 'totalNum' (int), 'hasNextPage' (bool), 'articles' (List[Dict])]  \nsolutionArticles.totalNum: [int, total number of community solutions available for the problem]  \nsolutionArticles.hasNextPage: [bool, indicates if more solutions are available beyond the current batch]  \nsolutionArticles.articles: [List[Dict], list of solution article metadata entries, each containing title, topicId, slug, summary, articleUrl, canSee, hasVideoArticle]  \nsolutionArticles.articles[].title: [str, title of the solution article]  \nsolutionArticles.articles[].topicId: [int, unique identifier for the solution article; required to fetch full content via 'get_problem_solution']  \nsolutionArticles.articles[].slug: [str, URL-friendly identifier for the solution article]  \nsolutionArticles.articles[].summary: [str, brief excerpt or preview of the solution content]  \nsolutionArticles.articles[].articleUrl: [str, full URL to the solution on LeetCode]  \nsolutionArticles.articles[].canSee: [bool, whether the user has permission to view the full article]  \nsolutionArticles.articles[].hasVideoArticle: [bool, indicates if the solution includes a video explanation]\n\n**brief_explain**  \nThe output schema captures all metadata from LeetCode community solutions in a structured, hierarchical format. It includes problem context (questionSlug), pagination details, and a list of solution entries with essential fields like topicId (needed to retrieve full content), title, summary, and access information. The design ensures no data loss from API responses and supports programmatic navigation through solutions.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "questionSlug",
          "type": "str",
          "description": "URL slug of the LeetCode problem for which solutions are retrieved"
        },
        {
          "name": "solutionArticles",
          "type": "Dict",
          "description": "contains pagination info and list of solution articles with their metadata. Keys: 'totalNum' (int), 'hasNextPage' (bool), 'articles' (List[Dict])"
        },
        {
          "name": "solutionArticles.totalNum",
          "type": "int",
          "description": "total number of community solutions available for the problem"
        },
        {
          "name": "solutionArticles.hasNextPage",
          "type": "bool",
          "description": "indicates if more solutions are available beyond the current batch"
        },
        {
          "name": "solutionArticles.articles",
          "type": "List[Dict]",
          "description": "list of solution article metadata entries, each containing title, topicId, slug, summary, articleUrl, canSee, hasVideoArticle"
        },
        {
          "name": "solutionArticles.articles[].title",
          "type": "str",
          "description": "title of the solution article"
        },
        {
          "name": "solutionArticles.articles[].topicId",
          "type": "int",
          "description": "unique identifier for the solution article; required to fetch full content via 'get_problem_solution'"
        },
        {
          "name": "solutionArticles.articles[].slug",
          "type": "str",
          "description": "URL-friendly identifier for the solution article"
        },
        {
          "name": "solutionArticles.articles[].summary",
          "type": "str",
          "description": "brief excerpt or preview of the solution content"
        },
        {
          "name": "solutionArticles.articles[].articleUrl",
          "type": "str",
          "description": "full URL to the solution on LeetCode"
        },
        {
          "name": "solutionArticles.articles[].canSee",
          "type": "bool",
          "description": "whether the user has permission to view the full article"
        },
        {
          "name": "solutionArticles.articles[].hasVideoArticle",
          "type": "bool",
          "description": "indicates if the solution includes a video explanation"
        }
      ],
      "brief_explain": "The output schema captures all metadata from LeetCode community solutions in a structured, hierarchical format. It includes problem context (questionSlug), pagination details, and a list of solution entries with essential fields like topicId (needed to retrieve full content), title, summary, and access information. The design ensures no data loss from API responses and supports programmatic navigation through solutions."
    },
    "tool_schema": {
      "function": {
        "description": "Retrieves a list of community solutions for a specific LeetCode problem, including only metadata like topicId. To view the full content of a solution, use the 'get_problem_solution' tool with the topicId returned by this tool.",
        "name": "leetcode-list_problem_solutions",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "limit": {
              "default": 10,
              "description": "Maximum number of solutions to return per request. Used for pagination and controlling response size. Default is 20 if not specified. Must be a positive integer.",
              "type": "number"
            },
            "orderBy": {
              "default": "HOT",
              "description": "Sorting criteria for the returned solutions. 'DEFAULT' sorts by LeetCode's default algorithm (typically a combination of recency and popularity), 'MOST_VOTES' sorts by the number of upvotes (highest first), and 'MOST_RECENT' sorts by publication date (newest first).",
              "enum": [
                "HOT",
                " MOST_RECENT",
                "MOST_VOTES"
              ],
              "type": "string"
            },
            "questionSlug": {
              "description": "The URL slug/identifier of the problem to retrieve solutions for (e.g., 'two-sum', 'add-two-numbers'). This is the same string that appears in the LeetCode problem URL after '/problems/'",
              "type": "string"
            },
            "skip": {
              "description": "Number of solutions to skip before starting to collect results. Used in conjunction with 'limit' for implementing pagination. Default is 0 if not specified. Must be a non-negative integer.",
              "type": "number"
            },
            "tagSlugs": {
              "default": [],
              "description": "Array of tag identifiers to filter solutions by programming languages (e.g., 'python', 'java') or problem algorithm/data-structure tags (e.g., 'dynamic-programming', 'recursion'). Only solutions tagged with at least one of the specified tags will be returned.",
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "userInput": {
              "description": "Search term to filter solutions by title, content, or author name. Case insensitive. Useful for finding specific approaches or algorithms mentioned in solutions.",
              "type": "string"
            }
          },
          "required": [
            "questionSlug"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "united-states-weather-get_current_weather": {
    "tool_name": "united-states-weather-get_current_weather",
    "output_schema_raw": "**output_schema**  \nlocation: [str, geographic coordinates in \"lat,lng\" format for the observed location]  \nstation: [str, identifier of the weather observation station (e.g., KOKC, KSLC)]  \nobserved_at_local: [str, date and time of observation in local time, formatted as \"M/D/YYYY, H:MM AM/PM\"]  \nobservation_age_minutes: [int, number of minutes ago the observation was recorded, derived from timestamp difference]  \ntemperature_fahrenheit: [float, current air temperature in degrees Fahrenheit]  \ntemperature_celsius: [float, current air temperature in degrees Celsius]  \nconditions: [str, current weather conditions description (e.g., Clear, Rainy, Cloudy))]  \nfeels_like_fahrenheit: [float, apparent temperature in degrees Fahrenheit considering humidity or wind]  \nfeels_like_celsius: [float, apparent temperature in degrees Celsius]  \nfeels_like_type: [str, type of feels-like index used (e.g., heat index, wind chill))]  \nhumidity_percent: [float, relative humidity as a percentage]  \nwind_speed_mph: [float, wind speed in miles per hour]  \nwind_direction_degrees: [int, wind direction in degrees from true north (0° = north, 90° = east))]  \npressure_inhg: [float, atmospheric pressure in inches of mercury]  \nvisibility_miles: [float, visibility distance in statute miles]  \n\n**brief_explain**  \nStructured schema capturing all observable weather data points from current US weather responses, including precise temperature, conditions, wind, pressure, visibility, and metadata like station, location, and observation timing. Supports variation in presence of \"feels like\" and humidity while maintaining atomic fields for easy access and programmatic use.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "str",
          "description": "geographic coordinates in \"lat,lng\" format for the observed location"
        },
        {
          "name": "station",
          "type": "str",
          "description": "identifier of the weather observation station (e.g., KOKC, KSLC)"
        },
        {
          "name": "observed_at_local",
          "type": "str",
          "description": "date and time of observation in local time, formatted as \"M/D/YYYY, H:MM AM/PM\""
        },
        {
          "name": "observation_age_minutes",
          "type": "int",
          "description": "number of minutes ago the observation was recorded, derived from timestamp difference"
        },
        {
          "name": "temperature_fahrenheit",
          "type": "float",
          "description": "current air temperature in degrees Fahrenheit"
        },
        {
          "name": "temperature_celsius",
          "type": "float",
          "description": "current air temperature in degrees Celsius"
        },
        {
          "name": "conditions",
          "type": "str",
          "description": "current weather conditions description (e.g., Clear, Rainy, Cloudy))"
        },
        {
          "name": "feels_like_fahrenheit",
          "type": "float",
          "description": "apparent temperature in degrees Fahrenheit considering humidity or wind"
        },
        {
          "name": "feels_like_celsius",
          "type": "float",
          "description": "apparent temperature in degrees Celsius"
        },
        {
          "name": "feels_like_type",
          "type": "str",
          "description": "type of feels-like index used (e.g., heat index, wind chill))"
        },
        {
          "name": "humidity_percent",
          "type": "float",
          "description": "relative humidity as a percentage"
        },
        {
          "name": "wind_speed_mph",
          "type": "float",
          "description": "wind speed in miles per hour"
        },
        {
          "name": "wind_direction_degrees",
          "type": "int",
          "description": "wind direction in degrees from true north (0° = north, 90° = east))"
        },
        {
          "name": "pressure_inhg",
          "type": "float",
          "description": "atmospheric pressure in inches of mercury"
        },
        {
          "name": "visibility_miles",
          "type": "float",
          "description": "visibility distance in statute miles"
        }
      ],
      "brief_explain": "Structured schema capturing all observable weather data points from current US weather responses, including precise temperature, conditions, wind, pressure, visibility, and metadata like station, location, and observation timing. Supports variation in presence of \"feels like\" and humidity while maintaining atomic fields for easy access and programmatic use."
    },
    "tool_schema": {
      "function": {
        "description": "Get current weather conditions for a location in the United States. Perfect for 'What's the weather like in [US location]?' questions. Covers all US states, territories, and coastal waters.",
        "name": "united-states-weather-get_current_weather",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "location": {
              "description": "US location as coordinates (lat,lng) in decimal degrees. Example: '40.7128,-74.0060' for New York City. Must be within US boundaries including states, territories (PR, VI, AS, GU, MP), and coastal waters.",
              "type": "string"
            }
          },
          "required": [
            "location"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mytime-get_current_time": {
    "tool_name": "mytime-get_current_time",
    "output_schema_raw": "**output_schema**  \ncurrent_time: [str, the current date and time in \"YYYY-MM-DD HH:MM:SS\" format]\n\n**brief_explain**  \nThe tool returns a single unstructured string representing the current timestamp in a standard format. This value is captured as a string in the schema to preserve exact formatting and semantics. No additional parsing or decomposition is needed, as the response consistently provides only the timestamp.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "current_time",
          "type": "str",
          "description": "the current date and time in \"YYYY-MM-DD HH:MM:SS\" format"
        }
      ],
      "brief_explain": "The tool returns a single unstructured string representing the current timestamp in a standard format. This value is captured as a string in the schema to preserve exact formatting and semantics. No additional parsing or decomposition is needed, as the response consistently provides only the timestamp."
    },
    "tool_schema": {
      "function": {
        "description": "Get the current time.",
        "name": "mytime-get_current_time",
        "parameters": {
          "properties": {},
          "title": "get_current_timeArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-bbc-news": {
    "tool_name": "trends-hub-get-bbc-news",
    "output_schema_raw": "**output_schema**  \narticles: [List[Dict], list of news articles, each with 'title', 'description', 'publish_time', and 'link' fields]  \n\n**brief_explain**  \nThe tool returns a list of news articles in an unstructured text format using XML-like tags. Each article contains a title, description, publication timestamp, and URL link. The response varies by category (e.g., world, UK) but consistently follows this structure. All information is captured losslessly in a structured list of dictionaries.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "articles",
          "type": "List[Dict]",
          "description": "list of news articles, each with 'title', 'description', 'publish_time', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns a list of news articles in an unstructured text format using XML-like tags. Each article contains a title, description, publication timestamp, and URL link. The response varies by category (e.g., world, UK) but consistently follows this structure. All information is captured losslessly in a structured list of dictionaries."
    },
    "tool_schema": {
      "function": {
        "description": "获取 BBC 新闻，提供全球新闻、英国新闻、商业、政治、健康、教育、科技、娱乐等资讯",
        "name": "trends-hub-get-bbc-news",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "category": {
              "anyOf": [
                {
                  "const": "",
                  "description": "热门新闻",
                  "type": "string"
                },
                {
                  "const": "world",
                  "description": "国际",
                  "type": "string"
                },
                {
                  "const": "uk",
                  "description": "英国",
                  "type": "string"
                },
                {
                  "const": "business",
                  "description": "商业",
                  "type": "string"
                },
                {
                  "const": "politics",
                  "description": "政治",
                  "type": "string"
                },
                {
                  "const": "health",
                  "description": "健康",
                  "type": "string"
                },
                {
                  "const": "education",
                  "description": "教育",
                  "type": "string"
                },
                {
                  "const": "science_and_environment",
                  "description": "科学与环境",
                  "type": "string"
                },
                {
                  "const": "technology",
                  "description": "科技",
                  "type": "string"
                },
                {
                  "const": "entertainment_and_arts",
                  "description": "娱乐与艺术",
                  "type": "string"
                }
              ],
              "default": ""
            },
            "edition": {
              "anyOf": [
                {
                  "const": "",
                  "type": "string"
                },
                {
                  "const": "uk",
                  "description": "UK",
                  "type": "string"
                },
                {
                  "const": "us",
                  "description": "US & Canada",
                  "type": "string"
                },
                {
                  "const": "int",
                  "description": "Rest of the world",
                  "type": "string"
                }
              ],
              "default": "",
              "description": "版本，仅对 `category` 为空有效"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-weread-rank": {
    "tool_name": "trends-hub-get-weread-rank",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取微信读书排行榜，包含热门小说、畅销书籍、新书推荐及各类文学作品的阅读数据和排名信息",
        "name": "trends-hub-get-weread-rank",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "category": {
              "anyOf": [
                {
                  "const": "rising",
                  "description": "飙升榜",
                  "type": "string"
                },
                {
                  "const": "hot_search",
                  "description": "热搜榜",
                  "type": "string"
                },
                {
                  "const": "newbook",
                  "description": "新书榜",
                  "type": "string"
                },
                {
                  "const": "general_novel_rising",
                  "description": "小说榜",
                  "type": "string"
                },
                {
                  "const": "all",
                  "description": "总榜",
                  "type": "string"
                }
              ],
              "default": "rising",
              "description": "排行榜分区"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "geeknews-server-get_articles": {
    "tool_name": "geeknews-server-get_articles",
    "output_schema_raw": "**output_schema**  \narticles: [List[Dict], list of article items, each containing 'title', 'url', 'points', 'author', 'time', 'rank', and 'commentCount' fields]\n\n**brief_explain**  \nThe tool returns a list of articles from GeekNews with structured attributes such as title, URL, points, author, relative time, rank, and comment count. Each article is represented as a dictionary, and multiple articles are returned in a list. The response is consistently structured across calls, so the schema captures all semantic fields in a lossless, granular way.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "articles",
          "type": "List[Dict]",
          "description": "list of article items, each containing 'title', 'url', 'points', 'author', 'time', 'rank', and 'commentCount' fields"
        }
      ],
      "brief_explain": "The tool returns a list of articles from GeekNews with structured attributes such as title, URL, points, author, relative time, rank, and comment count. Each article is represented as a dictionary, and multiple articles are returned in a list. The response is consistently structured across calls, so the schema captures all semantic fields in a lossless, granular way."
    },
    "tool_schema": {
      "function": {
        "description": "\n            GeekNews에서 아티클을 가져오는 도구\n            \n            Args:\n                type: 아티클 유형 (top, new, ask, show)\n                limit: 반환할 아티클 수 (최대 30)\n            \n            Returns:\n                List[Dict[str, Any]]: 아티클 목록\n                \n            Raises:\n                ValueError: 유효하지 않은 아티클 유형이 지정된 경우\n            ",
        "name": "geeknews-server-get_articles",
        "parameters": {
          "properties": {
            "limit": {
              "default": 10,
              "title": "Limit",
              "type": "integer"
            },
            "type": {
              "default": "top",
              "title": "Type",
              "type": "string"
            }
          },
          "title": "get_articlesArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-weibo-trending": {
    "tool_name": "trends-hub-get-weibo-trending",
    "output_schema_raw": "**output_schema**  \nstatus_code: [int, HTTP status code of the response]  \nerror_message: [str, description of the error if the request failed, e.g., \"Request failed with status code 403\"]  \n\n**brief_explain**  \nThe tool currently returns only error responses with HTTP status codes and associated messages. The schema captures these two key pieces of information to represent the outcome of the API call accurately. Since all observed responses are failures (e.g., 403), and no successful structured data was returned, the schema reflects the actual observed output format without assuming unverified fields.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "status_code",
          "type": "int",
          "description": "HTTP status code of the response"
        },
        {
          "name": "error_message",
          "type": "str",
          "description": "description of the error if the request failed, e.g., \"Request failed with status code 403\""
        }
      ],
      "brief_explain": "The tool currently returns only error responses with HTTP status codes and associated messages. The schema captures these two key pieces of information to represent the outcome of the API call accurately. Since all observed responses are failures (e.g., 403), and no successful structured data was returned, the schema reflects the actual observed output format without assuming unverified fields."
    },
    "tool_schema": {
      "function": {
        "description": "获取微博热搜榜，包含时事热点、社会现象、娱乐新闻、明星动态及网络热议话题的实时热门中文资讯",
        "name": "trends-hub-get-weibo-trending",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mapas-mentais-server-intermediario": {
    "tool_name": "mapas-mentais-server-intermediario",
    "output_schema_raw": "**output_schema**  \ntopic: [str, the main subject or theme for which intermediate knowledge is being described]  \nfocus_areas: [List[Dict], list of focus areas, each containing 'level' (e.g., Analisar, Avaliar, Criar) and 'actions' (list of related tasks or skills under that level)]  \n\n**brief_explain**  \nThe tool returns a textual response describing intermediate-level knowledge for a given topic, structured around cognitive levels (Analisar, Avaliar, Criar), each with specific actions. The schema captures the central topic and organizes the hierarchical knowledge structure into discrete, semantically separated fields to preserve all information in structured form.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "topic",
          "type": "str",
          "description": "the main subject or theme for which intermediate knowledge is being described"
        },
        {
          "name": "focus_areas",
          "type": "List[Dict]",
          "description": "list of focus areas, each containing 'level' (e.g., Analisar, Avaliar, Criar) and 'actions' (list of related tasks or skills under that level)"
        }
      ],
      "brief_explain": "The tool returns a textual response describing intermediate-level knowledge for a given topic, structured around cognitive levels (Analisar, Avaliar, Criar), each with specific actions. The schema captures the central topic and organizes the hierarchical knowledge structure into discrete, semantically separated fields to preserve all information in structured form."
    },
    "tool_schema": {
      "function": {
        "description": "Gera um mapa mental de conhecimentos intermediários sobre o tema.",
        "name": "mapas-mentais-server-intermediario",
        "parameters": {
          "properties": {
            "tema": {
              "title": "Tema",
              "type": "string"
            }
          },
          "required": [
            "tema"
          ],
          "title": "intermediarioArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-calculator-get_weather": {
    "tool_name": "weather-calculator-get_weather",
    "output_schema_raw": "**output_schema**  \nlocation: [str, full location name including city and country, e.g., \"Tokyo, Japan\"]  \ncity: [str, name of the city for which weather is provided]  \ncountry: [str, name of the country corresponding to the city]  \ntemperature_celsius: [float, current temperature in degrees Celsius]  \ntemperature_fahrenheit: [float, current temperature in degrees Fahrenheit]  \ncondition: [str, textual description of current weather condition, e.g., \"Sunny\", \"Partly cloudy\"]  \nhumidity: [int, relative humidity percentage]  \nwind_speed_kmh: [float, wind speed in kilometers per hour]  \nfeels_like_celsius: [float, apparent temperature in degrees Celsius]  \nfeels_like_fahrenheit: [float, apparent temperature in degrees Fahrenheit]\n\n**brief_explain**  \nThe schema extracts all key weather metrics from unstructured text responses into structured, semantically distinct fields. It separates temperature units, normalizes location into city and country, and preserves descriptive and quantitative weather attributes with appropriate types for programmatic use.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "str",
          "description": "full location name including city and country, e.g., \"Tokyo, Japan\""
        },
        {
          "name": "city",
          "type": "str",
          "description": "name of the city for which weather is provided"
        },
        {
          "name": "country",
          "type": "str",
          "description": "name of the country corresponding to the city"
        },
        {
          "name": "temperature_celsius",
          "type": "float",
          "description": "current temperature in degrees Celsius"
        },
        {
          "name": "temperature_fahrenheit",
          "type": "float",
          "description": "current temperature in degrees Fahrenheit"
        },
        {
          "name": "condition",
          "type": "str",
          "description": "textual description of current weather condition, e.g., \"Sunny\", \"Partly cloudy\""
        },
        {
          "name": "humidity",
          "type": "int",
          "description": "relative humidity percentage"
        },
        {
          "name": "wind_speed_kmh",
          "type": "float",
          "description": "wind speed in kilometers per hour"
        },
        {
          "name": "feels_like_celsius",
          "type": "float",
          "description": "apparent temperature in degrees Celsius"
        },
        {
          "name": "feels_like_fahrenheit",
          "type": "float",
          "description": "apparent temperature in degrees Fahrenheit"
        }
      ],
      "brief_explain": "The schema extracts all key weather metrics from unstructured text responses into structured, semantically distinct fields. It separates temperature units, normalizes location into city and country, and preserves descriptive and quantitative weather attributes with appropriate types for programmatic use."
    },
    "tool_schema": {
      "function": {
        "description": "Get current weather information for a city",
        "name": "weather-calculator-get_weather",
        "parameters": {
          "properties": {
            "city": {
              "description": "City name (e.g., \"Istanbul\", \"London\", \"New York\")",
              "type": "string"
            }
          },
          "required": [
            "city"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-calculator-calculate": {
    "tool_name": "weather-calculator-calculate",
    "output_schema_raw": "**output_schema**  \nresult_expression: [str, the original mathematical expression that was evaluated]  \nresult_value: [float, the numeric result of evaluating the expression]  \nraw_output: [str, the full plain text response from the tool as returned]\n\n**brief_explain**  \nThe tool returns a plain text result containing a computed value from a mathematical expression. The schema captures the parsed components: the input expression, the numeric result, and the raw output string for fidelity. This ensures lossless, structured access to all available information.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "result_expression",
          "type": "str",
          "description": "the original mathematical expression that was evaluated"
        },
        {
          "name": "result_value",
          "type": "float",
          "description": "the numeric result of evaluating the expression"
        },
        {
          "name": "raw_output",
          "type": "str",
          "description": "the full plain text response from the tool as returned"
        }
      ],
      "brief_explain": "The tool returns a plain text result containing a computed value from a mathematical expression. The schema captures the parsed components: the input expression, the numeric result, and the raw output string for fidelity. This ensures lossless, structured access to all available information."
    },
    "tool_schema": {
      "function": {
        "description": "Perform basic arithmetic calculations",
        "name": "weather-calculator-calculate",
        "parameters": {
          "properties": {
            "expression": {
              "description": "Mathematical expression to evaluate (e.g., \"2 + 2\", \"10 * 5\")",
              "type": "string"
            }
          },
          "required": [
            "expression"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-douyin-trending": {
    "tool_name": "trends-hub-get-douyin-trending",
    "output_schema_raw": "**output_schema**  \ntrending_items: [List[Dict], list of trending topics, each with 'title', 'event_time', 'cover_url', 'popularity', and 'link' fields]\n\n**brief_explain**  \nThe tool returns a list of currently trending topics on Douyin, where each item contains a title, timestamp of when it became trending, an image cover URL, popularity score, and a direct link to the topic. The response is unstructured text but consistently formatted with repeating XML-like tags, allowing structured parsing into a list of dictionaries. Each field captures one semantic unit of information without loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "trending_items",
          "type": "List[Dict]",
          "description": "list of trending topics, each with 'title', 'event_time', 'cover_url', 'popularity', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns a list of currently trending topics on Douyin, where each item contains a title, timestamp of when it became trending, an image cover URL, popularity score, and a direct link to the topic. The response is unstructured text but consistently formatted with repeating XML-like tags, allowing structured parsing into a list of dictionaries. Each field captures one semantic unit of information without loss."
    },
    "tool_schema": {
      "function": {
        "description": "获取抖音热搜榜单，展示当下最热门的社会话题、娱乐事件、网络热点和流行趋势",
        "name": "trends-hub-get-douyin-trending",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-get_recent_ac_submissions": {
    "tool_name": "leetcode-get_recent_ac_submissions",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "Retrieves a user's recent accepted (AC) submissions on LeetCode Global, focusing only on successfully completed problems",
        "name": "leetcode-get_recent_ac_submissions",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "limit": {
              "default": 10,
              "description": "Maximum number of accepted submissions to return (optional, defaults to server-defined limit)",
              "type": "number"
            },
            "username": {
              "description": "LeetCode username to retrieve recent accepted submissions for",
              "type": "string"
            }
          },
          "required": [
            "username"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "okx-server-get_candlesticks": {
    "tool_name": "okx-server-get_candlesticks",
    "output_schema_raw": "**output_schema**  \ncandlesticks: [List[Dict], list of candlestick data, each with 'timestamp' (str), 'open' (str), 'high' (str), 'low' (str), 'close' (str), 'volume' (str), and 'volumeCurrency' (str) fields]\n\n**brief_explain**  \nThe tool returns a list of OHLC (Open, High, Low, Close) candlestick data points for a given instrument, time interval, and limit. Each candlestick is a structured dictionary containing price and volume metrics at a specific timestamp. The schema captures all fields returned in the response with precise typing and structure to ensure no information loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "candlesticks",
          "type": "List[Dict]",
          "description": "list of candlestick data, each with 'timestamp' (str), 'open' (str), 'high' (str), 'low' (str), 'close' (str), 'volume' (str), and 'volumeCurrency' (str) fields"
        }
      ],
      "brief_explain": "The tool returns a list of OHLC (Open, High, Low, Close) candlestick data points for a given instrument, time interval, and limit. Each candlestick is a structured dictionary containing price and volume metrics at a specific timestamp. The schema captures all fields returned in the response with precise typing and structure to ensure no information loss."
    },
    "tool_schema": {
      "function": {
        "description": "Get candlestick data for an OKX instrument",
        "name": "okx-server-get_candlesticks",
        "parameters": {
          "properties": {
            "bar": {
              "default": "1m",
              "description": "Time interval (e.g. 1m, 5m, 1H, 1D)",
              "type": "string"
            },
            "instrument": {
              "description": "Instrument ID (e.g. BTC-USDT)",
              "type": "string"
            },
            "limit": {
              "default": 100,
              "description": "Number of candlesticks (max 100)",
              "type": "number"
            }
          },
          "required": [
            "instrument"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mytime-add_num": {
    "tool_name": "mytime-add_num",
    "output_schema_raw": "**output_schema**  \nresult: [int, the sum of all numbers provided in the input list]\n\n**brief_explain**  \nThe tool returns a single integer representing the total sum of the input numbers. All observed responses are unstructured raw integers, so the schema captures this as a single structured field containing the numerical result.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "result",
          "type": "int",
          "description": "the sum of all numbers provided in the input list"
        }
      ],
      "brief_explain": "The tool returns a single integer representing the total sum of the input numbers. All observed responses are unstructured raw integers, so the schema captures this as a single structured field containing the numerical result."
    },
    "tool_schema": {
      "function": {
        "description": "Add a list of numbers.",
        "name": "mytime-add_num",
        "parameters": {
          "properties": {
            "nums": {
              "items": {
                "type": "integer"
              },
              "title": "Nums",
              "type": "array"
            }
          },
          "required": [
            "nums"
          ],
          "title": "add_numArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-douban-rank": {
    "tool_name": "trends-hub-get-douban-rank",
    "output_schema_raw": "**output_schema**  \nitems: [List[Dict], list of ranked items, each containing 'type_name', 'title', 'info', 'cover', 'year', 'release_date', 'link', 'popularity', 'rating_count', 'rating_value', and 'hashtags' fields]  \n\n**brief_explain**  \nThe tool returns a list of trending media items (e.g., movies) from Douban, with each item structured as a dictionary containing detailed metadata such as title, cover image, release date, popularity score, rating, and associated hashtags. All items are grouped in a top-level `items` list to support multiple entries.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "items",
          "type": "List[Dict]",
          "description": "list of ranked items, each containing 'type_name', 'title', 'info', 'cover', 'year', 'release_date', 'link', 'popularity', 'rating_count', 'rating_value', and 'hashtags' fields"
        }
      ],
      "brief_explain": "The tool returns a list of trending media items (e.g., movies) from Douban, with each item structured as a dictionary containing detailed metadata such as title, cover image, release date, popularity score, rating, and associated hashtags. All items are grouped in a top-level `items` list to support multiple entries."
    },
    "tool_schema": {
      "function": {
        "description": "获取豆瓣实时热门榜单，提供当前热门的图书、电影、电视剧、综艺等作品信息，包含评分和热度数据",
        "name": "trends-hub-get-douban-rank",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "count": {
              "default": 10,
              "type": "integer"
            },
            "start": {
              "default": 0,
              "type": "integer"
            },
            "type": {
              "anyOf": [
                {
                  "const": "subject",
                  "description": "图书、电影、电视剧、综艺等",
                  "type": "string"
                },
                {
                  "const": "movie",
                  "description": "电影",
                  "type": "string"
                },
                {
                  "const": "tv",
                  "description": "电视剧",
                  "type": "string"
                }
              ],
              "default": "subject"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mcp-server-test-get_alerts": {
    "tool_name": "mcp-server-test-get_alerts",
    "output_schema_raw": "**output_schema**  \nalerts: [List[Dict], list of weather alerts, each containing 'event', 'area', 'severity', 'description', and 'instructions' fields]  \n\n**brief_explain**  \nThe tool returns a list of structured weather alerts with consistent semantic fields; each alert includes event type, affected area, severity level, detailed description (with subfields like WHAT, WHERE, WHEN, IMPACTS), and safety instructions. All information is normalized into a structured list of dictionaries to preserve granularity and avoid data loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "alerts",
          "type": "List[Dict]",
          "description": "list of weather alerts, each containing 'event', 'area', 'severity', 'description', and 'instructions' fields"
        }
      ],
      "brief_explain": "The tool returns a list of structured weather alerts with consistent semantic fields; each alert includes event type, affected area, severity level, detailed description (with subfields like WHAT, WHERE, WHEN, IMPACTS), and safety instructions. All information is normalized into a structured list of dictionaries to preserve granularity and avoid data loss."
    },
    "tool_schema": {
      "function": {
        "description": "Get weather alerts for a US state.\n\n    Args:\n        state: Two-letter US state code (e.g. CA, NY)\n    ",
        "name": "mcp-server-test-get_alerts",
        "parameters": {
          "properties": {
            "state": {
              "title": "State",
              "type": "string"
            }
          },
          "required": [
            "state"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-get_user_profile": {
    "tool_name": "leetcode-get_user_profile",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "Retrieves profile information about a LeetCode user, including user stats, solved problems, and profile details",
        "name": "leetcode-get_user_profile",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "username": {
              "description": "LeetCode username to retrieve profile information for",
              "type": "string"
            }
          },
          "required": [
            "username"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "ipma-weather-data-server-get_uv_forecast": {
    "tool_name": "ipma-weather-data-server-get_uv_forecast",
    "output_schema_raw": "**output_schema**  \nforecast_date: [str, date of the UV forecast in YYYY-MM-DD format]  \nlocations: [List[Dict], list of locations with UV index details, each containing 'name', 'uv_index', 'intensity_level', and 'time_period' fields]\n\n**brief_explain**  \nThe tool returns a daily UV index forecast for multiple locations in Portugal. Each entry includes the location name, UV index value, intensity category (e.g., \"Muito Alto\"), and the time period when the peak UV occurs. The response is structured per day, with multiple locations listed under each date.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "forecast_date",
          "type": "str",
          "description": "date of the UV forecast in YYYY-MM-DD format"
        },
        {
          "name": "locations",
          "type": "List[Dict]",
          "description": "list of locations with UV index details, each containing 'name', 'uv_index', 'intensity_level', and 'time_period' fields"
        }
      ],
      "brief_explain": "The tool returns a daily UV index forecast for multiple locations in Portugal. Each entry includes the location name, UV index value, intensity category (e.g., \"Muito Alto\"), and the time period when the peak UV occurs. The response is structured per day, with multiple locations listed under each date."
    },
    "tool_schema": {
      "function": {
        "description": "Obter previsão do índice UV",
        "name": "ipma-weather-data-server-get_uv_forecast",
        "parameters": {
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "fruityvice-nutrition-info-server-get_fruit_nutrition": {
    "tool_name": "fruityvice-nutrition-info-server-get_fruit_nutrition",
    "output_schema_raw": "**output_schema**  \nname: [str, the name of the fruit]  \nfamily: [str, the botanical family of the fruit]  \ngenus: [str, the botanical genus of the fruit]  \norder: [str, the botanical order of the fruit]  \nnutritions: [Dict, contains nutritional values with keys 'calories', 'fat', 'sugar', 'carbohydrates', 'protein'; all values are numeric (float or int)]  \nid: [int, unique identifier for the fruit in the database]\n\n**brief_explain**  \nThe output schema captures both botanical classification and detailed nutritional content of a fruit. All responses consistently include the fruit's name, family, genus, order, nutrition data (structured as a dictionary), and an ID. The schema is fully structured, preserving hierarchy and ensuring no information loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "name",
          "type": "str",
          "description": "the name of the fruit"
        },
        {
          "name": "family",
          "type": "str",
          "description": "the botanical family of the fruit"
        },
        {
          "name": "genus",
          "type": "str",
          "description": "the botanical genus of the fruit"
        },
        {
          "name": "order",
          "type": "str",
          "description": "the botanical order of the fruit"
        },
        {
          "name": "nutritions",
          "type": "Dict",
          "description": "contains nutritional values with keys 'calories', 'fat', 'sugar', 'carbohydrates', 'protein'; all values are numeric (float or int)"
        },
        {
          "name": "id",
          "type": "int",
          "description": "unique identifier for the fruit in the database"
        }
      ],
      "brief_explain": "The output schema captures both botanical classification and detailed nutritional content of a fruit. All responses consistently include the fruit's name, family, genus, order, nutrition data (structured as a dictionary), and an ID. The schema is fully structured, preserving hierarchy and ensuring no information loss."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get nutritional information and details for a given fruit name.\n\n    Args:\n        fruit_name: The name of the fruit to get information about (e.g., \"apple\", \"banana\", \"orange\")\n\n    Returns:\n        Dictionary containing fruit information including name, family, genus, order, and nutritional data\n    ",
        "name": "fruityvice-nutrition-info-server-get_fruit_nutrition",
        "parameters": {
          "properties": {
            "fruit_name": {
              "title": "Fruit Name",
              "type": "string"
            }
          },
          "required": [
            "fruit_name"
          ],
          "title": "get_fruit_nutritionArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "books-server-get_word_details": {
    "tool_name": "books-server-get_word_details",
    "output_schema_raw": "**output_schema**  \nword: [str, the word being defined]  \npronunciation: [str, phonetic pronunciation in slashes, e.g., /ˈnəʊnɪdʒ/]  \npart_of_speech: [str, the grammatical category of the word, e.g., Noun, Adjective]  \ndefinitions: [List[Dict], list of definition entries, each with 'definition' (str), optional 'example' (str), and optional 'synonyms' (List[str]) and 'antonyms' (List[str]) if present at definition level]  \nsynonyms: [List[str], general synonyms for the word, if provided at top level]  \nantonyms: [List[str], general antonyms for the word, if provided at top level]\n\n**brief_explain**  \nThe schema captures all semantic elements from unstructured responses: the target word, its pronunciation, part of speech, multiple definitions (each potentially with examples and context-specific synonyms/antonyms), and any global synonyms or antonyms. Definitions are structured as a list of objects to support rich, hierarchical data per sense. Top-level synonyms and antonyms are preserved separately when they apply to the word as a whole.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "word",
          "type": "str",
          "description": "the word being defined"
        },
        {
          "name": "pronunciation",
          "type": "str",
          "description": "phonetic pronunciation in slashes, e.g., /ˈnəʊnɪdʒ/"
        },
        {
          "name": "part_of_speech",
          "type": "str",
          "description": "the grammatical category of the word, e.g., Noun, Adjective"
        },
        {
          "name": "definitions",
          "type": "List[Dict]",
          "description": "list of definition entries, each with 'definition' (str), optional 'example' (str), and optional 'synonyms' (List[str]) and 'antonyms' (List[str]) if present at definition level"
        },
        {
          "name": "synonyms",
          "type": "List[str]",
          "description": "general synonyms for the word, if provided at top level"
        },
        {
          "name": "antonyms",
          "type": "List[str]",
          "description": "general antonyms for the word, if provided at top level"
        }
      ],
      "brief_explain": "The schema captures all semantic elements from unstructured responses: the target word, its pronunciation, part of speech, multiple definitions (each potentially with examples and context-specific synonyms/antonyms), and any global synonyms or antonyms. Definitions are structured as a list of objects to support rich, hierarchical data per sense. Top-level synonyms and antonyms are preserved separately when they apply to the word as a whole."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get detailed word information including pronunciation, synonyms, and examples.\n    \n    Args:\n        word: The word to get detailed information for\n    \n    Returns:\n        Detailed word information or error message\n    ",
        "name": "books-server-get_word_details",
        "parameters": {
          "properties": {
            "word": {
              "title": "Word",
              "type": "string"
            }
          },
          "required": [
            "word"
          ],
          "title": "get_word_detailsArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "united-states-weather-get_hourly_forecast": {
    "tool_name": "united-states-weather-get_hourly_forecast",
    "output_schema_raw": "**output_schema**  \nlocation: [str, geographic coordinates in \"lat,lng\" format for the forecast location]  \nupdated: [str, timestamp of when the forecast was last updated, in local time and date format]  \nforecast_hours: [int, number of hours covered in the forecast]  \nhourly: [List[Dict], list of hourly weather conditions with fields 'datetime', 'temperature_f', 'temperature_c', 'condition', 'precipitation_chance_pct']]\n\n**brief_explain**  \nThe output schema captures the core metadata (location, update time, duration) and structures the hour-by-hour forecast as a list of dictionaries, each representing one hour with standardized fields for temperature (F and C), weather condition, and precipitation chance. This design ensures full information retention from the unstructured text responses while enabling programmatic access to individual forecast points.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "str",
          "description": "geographic coordinates in \"lat,lng\" format for the forecast location"
        },
        {
          "name": "updated",
          "type": "str",
          "description": "timestamp of when the forecast was last updated, in local time and date format"
        },
        {
          "name": "forecast_hours",
          "type": "int",
          "description": "number of hours covered in the forecast"
        },
        {
          "name": "hourly",
          "type": "List[Dict]",
          "description": "list of hourly weather conditions with fields 'datetime', 'temperature_f', 'temperature_c', 'condition', 'precipitation_chance_pct']"
        }
      ],
      "brief_explain": "The output schema captures the core metadata (location, update time, duration) and structures the hour-by-hour forecast as a list of dictionaries, each representing one hour with standardized fields for temperature (F and C), weather condition, and precipitation chance. This design ensures full information retention from the unstructured text responses while enabling programmatic access to individual forecast points."
    },
    "tool_schema": {
      "function": {
        "description": "Get hour-by-hour weather forecast for a location in the United States. Perfect for 'What's the hourly forecast?' or 'Will it rain this afternoon in [US location]?' questions. Provides detailed hourly conditions for up to 48 hours.",
        "name": "united-states-weather-get_hourly_forecast",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "hours": {
              "default": 24,
              "description": "Number of hours to forecast (1-48, default 24). Provides temperature, conditions, and precipitation probability for each hour.",
              "type": "number"
            },
            "location": {
              "description": "US location as coordinates (lat,lng) in decimal degrees. Example: '40.7128,-74.0060' for New York City. Must be within US boundaries including states, territories (PR, VI, AS, GU, MP), and coastal waters.",
              "type": "string"
            }
          },
          "required": [
            "location"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mapas-mentais-server-problemas": {
    "tool_name": "mapas-mentais-server-problemas",
    "output_schema_raw": "**output_schema**  \nanalysis_topic: [str, topic of the problem analysis as provided in the input theme]  \nfocus_areas: [List[str], list of key focus areas or aspects that the problem analysis will cover]  \n\n**brief_explain**  \nThe tool generates a structured problem analysis for a given theme, consistently returning a fixed set of focus areas (e.g., problem definition, causes, solutions). The response is always centered on the input theme and lists exactly five standardized analytical dimensions. These are extracted into two fields: the original topic and the uniform list of analytical focus areas.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "analysis_topic",
          "type": "str",
          "description": "topic of the problem analysis as provided in the input theme"
        },
        {
          "name": "focus_areas",
          "type": "List[str]",
          "description": "list of key focus areas or aspects that the problem analysis will cover"
        }
      ],
      "brief_explain": "The tool generates a structured problem analysis for a given theme, consistently returning a fixed set of focus areas (e.g., problem definition, causes, solutions). The response is always centered on the input theme and lists exactly five standardized analytical dimensions. These are extracted into two fields: the original topic and the uniform list of analytical focus areas."
    },
    "tool_schema": {
      "function": {
        "description": "Gera um mapa mental de análise de problemas relacionados ao tema.",
        "name": "mapas-mentais-server-problemas",
        "parameters": {
          "properties": {
            "tema": {
              "title": "Tema",
              "type": "string"
            }
          },
          "required": [
            "tema"
          ],
          "title": "problemasArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-forecast-server-get_weather_by_coordinates": {
    "tool_name": "weather-forecast-server-get_weather_by_coordinates",
    "output_schema_raw": "**output_schema**  \nlocation: [Dict, contains 'latitude', 'longitude', 'city', 'country' fields]  \nweather: [Dict, contains 'main_condition', 'description', 'icon' fields]  \ntemperature: [Dict, contains 'current', 'feels_like', 'min', 'max', 'unit' fields]  \natmosphere: [Dict, contains 'pressure', 'humidity', 'visibility' fields]  \nwind: [Dict, contains 'speed', 'direction', 'unit' fields]  \ncloudiness: [Dict, contains 'percentage' field]  \nsun: [Dict, contains 'sunrise', 'sunset' as Unix timestamps]  \ntime: [Dict, contains 'data_time' as Unix timestamp and 'timezone_offset' in seconds]  \nrain: [Dict, optional; contains 'last_1h' rainfall amount and 'unit' if precipitation data is available]\n\n**brief_explain**  \nThe schema captures all weather-related data returned by the tool in a structured, hierarchical format. It supports variable presence of optional fields like rain, while preserving precise units and timestamps across responses. Each semantic concept (e.g., temperature, wind) has its own dedicated nested field to ensure clarity and access.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "Dict",
          "description": "contains 'latitude', 'longitude', 'city', 'country' fields"
        },
        {
          "name": "weather",
          "type": "Dict",
          "description": "contains 'main_condition', 'description', 'icon' fields"
        },
        {
          "name": "temperature",
          "type": "Dict",
          "description": "contains 'current', 'feels_like', 'min', 'max', 'unit' fields"
        },
        {
          "name": "atmosphere",
          "type": "Dict",
          "description": "contains 'pressure', 'humidity', 'visibility' fields"
        },
        {
          "name": "wind",
          "type": "Dict",
          "description": "contains 'speed', 'direction', 'unit' fields"
        },
        {
          "name": "cloudiness",
          "type": "Dict",
          "description": "contains 'percentage' field"
        },
        {
          "name": "sun",
          "type": "Dict",
          "description": "contains 'sunrise', 'sunset' as Unix timestamps"
        },
        {
          "name": "time",
          "type": "Dict",
          "description": "contains 'data_time' as Unix timestamp and 'timezone_offset' in seconds"
        },
        {
          "name": "rain",
          "type": "Dict",
          "description": "optional; contains 'last_1h' rainfall amount and 'unit' if precipitation data is available"
        }
      ],
      "brief_explain": "The schema captures all weather-related data returned by the tool in a structured, hierarchical format. It supports variable presence of optional fields like rain, while preserving precise units and timestamps across responses. Each semantic concept (e.g., temperature, wind) has its own dedicated nested field to ensure clarity and access."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Enlem ve boylam koordinatlarına göre hava durumu bilgilerini getirir.\n\n    Args:\n        latitude: Enlem (-90 ile 90 arasında)\n        longitude: Boylam (-180 ile 180 arasında)\n        units: Ölçü birimi (metric, imperial, standard)\n\n    Returns:\n        JSON formatında hava durumu bilgileri\n    ",
        "name": "weather-forecast-server-get_weather_by_coordinates",
        "parameters": {
          "properties": {
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            },
            "units": {
              "default": null,
              "title": "Units",
              "type": "string"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "title": "get_weather_by_coordinatesArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "deep-dive-mcp-server-get-alerts": {
    "tool_name": "deep-dive-mcp-server-get-alerts",
    "output_schema_raw": "**output_schema**  \nalerts: [List[Dict], list of weather alerts, each containing 'event', 'area', 'severity', 'status', and 'headline' fields]  \n\n**brief_explain**  \nThe tool returns a list of active weather alerts for a given U.S. state, with each alert containing structured information about the event type, affected area, severity level, status, and a detailed headline including issuance time and issuing authority. All responses follow a consistent pattern of multiple alerts separated by delimiters, with identical key fields per alert. Thus, the response can be fully structured into a list of dictionaries, capturing all semantic information without loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "alerts",
          "type": "List[Dict]",
          "description": "list of weather alerts, each containing 'event', 'area', 'severity', 'status', and 'headline' fields"
        }
      ],
      "brief_explain": "The tool returns a list of active weather alerts for a given U.S. state, with each alert containing structured information about the event type, affected area, severity level, status, and a detailed headline including issuance time and issuing authority. All responses follow a consistent pattern of multiple alerts separated by delimiters, with identical key fields per alert. Thus, the response can be fully structured into a list of dictionaries, capturing all semantic information without loss."
    },
    "tool_schema": {
      "function": {
        "description": "Get weather alerts for a state",
        "name": "deep-dive-mcp-server-get-alerts",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "state": {
              "description": "Two-letter state code (e.g., CA, NY",
              "maxLength": 2,
              "minLength": 2,
              "type": "string"
            }
          },
          "required": [
            "state"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-sspai-rank": {
    "tool_name": "trends-hub-get-sspai-rank",
    "output_schema_raw": "**output_schema**  \narticles: [List[Dict], list of articles, each with 'title', 'summary', 'author', 'released_time', 'comment_count', 'like_count', 'view_count', 'link' fields]  \n\n**brief_explain**  \nThe tool returns a list of ranked articles from 少数派 (sspai), each containing structured metadata. All key information is captured in a uniform list of dictionaries, preserving title, summary, author, release time, engagement metrics (comments, likes, views), and the article URL. This schema fully represents the unstructured XML-like text response in a structured, lossless format suitable for downstream processing.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "articles",
          "type": "List[Dict]",
          "description": "list of articles, each with 'title', 'summary', 'author', 'released_time', 'comment_count', 'like_count', 'view_count', 'link' fields"
        }
      ],
      "brief_explain": "The tool returns a list of ranked articles from 少数派 (sspai), each containing structured metadata. All key information is captured in a uniform list of dictionaries, preserving title, summary, author, release time, engagement metrics (comments, likes, views), and the article URL. This schema fully represents the unstructured XML-like text response in a structured, lossless format suitable for downstream processing."
    },
    "tool_schema": {
      "function": {
        "description": "获取少数派热榜，包含数码产品评测、软件应用推荐、生活方式指南及效率工作技巧的优质中文科技生活类内容",
        "name": "trends-hub-get-sspai-rank",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "limit": {
              "default": 40,
              "type": "integer"
            },
            "tag": {
              "default": "热门文章",
              "description": "分类",
              "enum": [
                "热门文章",
                "应用推荐",
                "生活方式",
                "效率技巧",
                "少数派播客"
              ],
              "type": "string"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "deep-dive-mcp-server-get-forecast": {
    "tool_name": "deep-dive-mcp-server-get-forecast",
    "output_schema_raw": "**output_schema**  \nlocation: [Dict, contains 'latitude' and 'longitude' fields specifying the forecast location]  \nforecast_periods: [List[Dict], list of time periods (e.g. nightly, daily) with weather details, each containing 'period_name', 'temperature_f', 'wind_description', and 'condition' fields]\n\n**brief_explain**  \nThe tool returns a plain-text weather forecast broken into time periods (like \"Tonight\", \"Thursday\", etc.) for a given latitude and longitude. Each period includes temperature, wind speed/direction, and a weather condition phrase. The schema captures this as a structured list of forecast periods under a specified location to preserve all semantic information without loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "Dict",
          "description": "contains 'latitude' and 'longitude' fields specifying the forecast location"
        },
        {
          "name": "forecast_periods",
          "type": "List[Dict]",
          "description": "list of time periods (e.g. nightly, daily) with weather details, each containing 'period_name', 'temperature_f', 'wind_description', and 'condition' fields"
        }
      ],
      "brief_explain": "The tool returns a plain-text weather forecast broken into time periods (like \"Tonight\", \"Thursday\", etc.) for a given latitude and longitude. Each period includes temperature, wind speed/direction, and a weather condition phrase. The schema captures this as a structured list of forecast periods under a specified location to preserve all semantic information without loss."
    },
    "tool_schema": {
      "function": {
        "description": "Get weather forecast for a location",
        "name": "deep-dive-mcp-server-get-forecast",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "latitude": {
              "description": "Latitude of the location",
              "maximum": 90,
              "minimum": -90,
              "type": "number"
            },
            "longitude": {
              "description": "Longitude of the location",
              "maximum": 180,
              "minimum": -180,
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "cooking-units-converter-convert_weight": {
    "tool_name": "cooking-units-converter-convert_weight",
    "output_schema_raw": "**output_schema**  \nvalue: [float, converted weight value]  \nfrom_unit: [str, source weight unit (one of 'g', 'kg', 'oz', 'lb')]  \nto_unit: [str, target weight unit (one of 'g', 'kg', 'oz', 'lb')]\n\n**brief_explain**  \nThe output schema captures the result of a weight conversion with the numeric value and both the original and target units, matching the structured JSON responses observed across all examples. Each field is atomic and semantically distinct, ensuring lossless representation of the tool's response.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "value",
          "type": "float",
          "description": "converted weight value"
        },
        {
          "name": "from_unit",
          "type": "str",
          "description": "source weight unit (one of 'g', 'kg', 'oz', 'lb')"
        },
        {
          "name": "to_unit",
          "type": "str",
          "description": "target weight unit (one of 'g', 'kg', 'oz', 'lb')"
        }
      ],
      "brief_explain": "The output schema captures the result of a weight conversion with the numeric value and both the original and target units, matching the structured JSON responses observed across all examples. Each field is atomic and semantically distinct, ensuring lossless representation of the tool's response."
    },
    "tool_schema": {
      "function": {
        "description": "Convert between weight units (g, kg, oz, lb)",
        "name": "cooking-units-converter-convert_weight",
        "parameters": {
          "properties": {
            "from_unit": {
              "description": "Source weight unit (g, kg, oz, lb)",
              "enum": [
                "g",
                "kg",
                "oz",
                "lb"
              ],
              "type": "string"
            },
            "to_unit": {
              "description": "Target weight unit (g, kg, oz, lb)",
              "enum": [
                "g",
                "kg",
                "oz",
                "lb"
              ],
              "type": "string"
            },
            "value": {
              "description": "Weight value to convert",
              "type": "number"
            }
          },
          "required": [
            "value",
            "from_unit",
            "to_unit"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "pokémcp-random-pokemon-from-region": {
    "tool_name": "pokémcp-random-pokemon-from-region",
    "output_schema_raw": "**output_schema**  \nname: [str, name of the randomly selected Pokémon]  \npokedex_number: [int, National Pokédex number of the Pokémon]  \nregion: [str, region from which the Pokémon originates (e.g., kanto, johto, galar)]  \ntypes: [List[str], list of the Pokémon's types (e.g., ['Water'], ['Normal', 'Flying'])]  \nheight: [float, height of the Pokémon in meters]  \nweight: [float, weight of the Pokémon in kilograms]  \nabilities: [List[str], list of the Pokémon's abilities]  \ndescription: [str, descriptive flavor text about the Pokémon]\n\n**brief_explain**  \nThe schema captures all key details from the unstructured tool responses in a structured, lossless way—extracting core attributes like name, Pokedex number, type(s), physical stats, abilities, and lore description, while supporting region context and consistent data types for programmatic use.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "name",
          "type": "str",
          "description": "name of the randomly selected Pokémon"
        },
        {
          "name": "pokedex_number",
          "type": "int",
          "description": "National Pokédex number of the Pokémon"
        },
        {
          "name": "region",
          "type": "str",
          "description": "region from which the Pokémon originates (e.g., kanto, johto, galar)"
        },
        {
          "name": "types",
          "type": "List[str]",
          "description": "list of the Pokémon's types (e.g., ['Water'], ['Normal', 'Flying'])"
        },
        {
          "name": "height",
          "type": "float",
          "description": "height of the Pokémon in meters"
        },
        {
          "name": "weight",
          "type": "float",
          "description": "weight of the Pokémon in kilograms"
        },
        {
          "name": "abilities",
          "type": "List[str]",
          "description": "list of the Pokémon's abilities"
        },
        {
          "name": "description",
          "type": "str",
          "description": "descriptive flavor text about the Pokémon"
        }
      ],
      "brief_explain": "The schema captures all key details from the unstructured tool responses in a structured, lossless way—extracting core attributes like name, Pokedex number, type(s), physical stats, abilities, and lore description, while supporting region context and consistent data types for programmatic use."
    },
    "tool_schema": {
      "function": {
        "description": "Get a random Pokémon from a specific region",
        "name": "pokémcp-random-pokemon-from-region",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "region": {
              "description": "The Pokémon region (e.g., kanto, johto, hoenn, etc.)",
              "type": "string"
            }
          },
          "required": [
            "region"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-forecast-server-chat_weather_assistant": {
    "tool_name": "weather-forecast-server-chat_weather_assistant",
    "output_schema_raw": "**output_schema**  \nresponse_type: [str, type of response indicating whether it's a request for input, error, or weather information (e.g., \"input_request\", \"error\", \"weather_summary\")]  \nmessage: [str, the main textual content of the assistant's reply, presented in natural language, typically in Turkish or mixed with emojis]  \nrequired_inputs: [List[str], list of inputs user must provide to proceed; possible values: \"coordinates\", \"city_name\"]  \ncoordinates_format_examples: [List[str], example formats for providing coordinates, such as \"41.0082, 28.9784\" or \"Enlem: 41.0082, Boylam: 28.9784\"]  \ncity_format_examples: [List[str], example formats for city-based queries, such as \"İstanbul için hava durumu\"]  \nerror_occurred: [bool, indicates whether an error was encountered during processing (e.g., API failure)]  \nerror_details: [str, description of the error if one occurred, e.g., \"API hatası: 404\"]  \nhas_weather_info: [bool, indicates whether any weather-related information was successfully retrieved]  \nfriendly_tone: [bool, indicates if the message is delivered in a conversational, user-friendly tone, often with emojis and Turkish language]  \nrequested_actions: [List[str], list of actions or questions the assistant is prompting the user to take, e.g., \"share location\", \"specify city\"]\n\n**brief_explain**  \nThe tool returns conversational, unstructured responses primarily in Turkish, often requesting location input or conveying errors. The schema captures intent, structure, error states, and user guidance from these responses, enabling downstream systems to interpret next steps or failures systematically.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "response_type",
          "type": "str",
          "description": "type of response indicating whether it's a request for input, error, or weather information (e.g., \"input_request\", \"error\", \"weather_summary\")"
        },
        {
          "name": "message",
          "type": "str",
          "description": "the main textual content of the assistant's reply, presented in natural language, typically in Turkish or mixed with emojis"
        },
        {
          "name": "required_inputs",
          "type": "List[str]",
          "description": "list of inputs user must provide to proceed; possible values: \"coordinates\", \"city_name\""
        },
        {
          "name": "coordinates_format_examples",
          "type": "List[str]",
          "description": "example formats for providing coordinates, such as \"41.0082, 28.9784\" or \"Enlem: 41.0082, Boylam: 28.9784\""
        },
        {
          "name": "city_format_examples",
          "type": "List[str]",
          "description": "example formats for city-based queries, such as \"İstanbul için hava durumu\""
        },
        {
          "name": "error_occurred",
          "type": "bool",
          "description": "indicates whether an error was encountered during processing (e.g., API failure)"
        },
        {
          "name": "error_details",
          "type": "str",
          "description": "description of the error if one occurred, e.g., \"API hatası: 404\""
        },
        {
          "name": "has_weather_info",
          "type": "bool",
          "description": "indicates whether any weather-related information was successfully retrieved"
        },
        {
          "name": "friendly_tone",
          "type": "bool",
          "description": "indicates if the message is delivered in a conversational, user-friendly tone, often with emojis and Turkish language"
        },
        {
          "name": "requested_actions",
          "type": "List[str]",
          "description": "list of actions or questions the assistant is prompting the user to take, e.g., \"share location\", \"specify city\""
        }
      ],
      "brief_explain": "The tool returns conversational, unstructured responses primarily in Turkish, often requesting location input or conveying errors. The schema captures intent, structure, error states, and user guidance from these responses, enabling downstream systems to interpret next steps or failures systematically."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Hava durumu asistanı ile sohbet et.\n\n    Bu araç kullanıcının mesajlarını analiz eder ve uygun yanıtlar verir.\n    Koordinat bilgilerini toplar ve hava durumu sorgular.\n\n    Args:\n        message: Kullanıcının mesajı\n\n    Returns:\n        Asistan yanıtı\n    ",
        "name": "weather-forecast-server-chat_weather_assistant",
        "parameters": {
          "properties": {
            "message": {
              "title": "Message",
              "type": "string"
            }
          },
          "required": [
            "message"
          ],
          "title": "chat_weather_assistantArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "unhcr-population-data-server-get_population_data": {
    "tool_name": "unhcr-population-data-server-get_population_data",
    "output_schema_raw": "**output_schema**  \npage: [int, current page number of the response]  \nmaxPages: [int, total number of pages available in the response]  \nshort-url: [str, short identifier for the query URL]  \ntotal: [List, summary totals (if provided); typically empty in examples]  \nitems: [List[Dict], list of population data entries, each containing detailed refugee statistics with the following fields:  \n  - year: [int, the year of the data]  \n  - coo_id: [int, country of origin numeric ID]  \n  - coa_id: [int, country of asylum numeric ID]  \n  - coo_name: [str, full name of country of origin]  \n  - coa_name: [str, full name of country of asylum]  \n  - coo: [str, legacy code for country of origin]  \n  - coa: [str, legacy code for country of asylum]  \n  - coo_iso: [str, ISO3 code for country of origin]  \n  - coa_iso: [str, ISO3 code for country of asylum]  \n  - refugees: [int, number of recognized refugees]  \n  - asylum_seekers: [int, number of asylum seekers]  \n  - returned_refugees: [int, number of returned refugees]  \n  - idps: [int or str, number of internally displaced persons; \"0\" or numeric string]  \n  - returned_idps: [int or str, number of returned internally displaced persons; \"0\" or numeric string]  \n  - stateless: [int or str, number of stateless individuals; \"0\" or numeric string]  \n  - ooc: [int or str, number of individuals out of concern; \"0\" or numeric value]  \n  - oip: [int or str, number of individuals in protracted situations; \"-\" if not applicable]  \n  - hst: [int or str, historical stock total; \"0\" or numeric string]  \n]\n\n**brief_explain**  \nThe output schema captures paginated UNHCR refugee population data with detailed breakdowns per country pair and year. Each item includes demographic categories like refugees, asylum seekers, IDPs, and stateless persons, along with metadata such as ISO codes and internal IDs. All key fields from the structured responses are preserved to ensure completeness and usability for analysis.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "page",
          "type": "int",
          "description": "current page number of the response"
        },
        {
          "name": "maxPages",
          "type": "int",
          "description": "total number of pages available in the response"
        },
        {
          "name": "short-url",
          "type": "str",
          "description": "short identifier for the query URL"
        },
        {
          "name": "total",
          "type": "List",
          "description": "summary totals (if provided); typically empty in examples"
        },
        {
          "name": "items",
          "type": "[List[Dict]",
          "description": "list of population data entries, each containing detailed refugee statistics with the following fields:"
        },
        {
          "name": "- year",
          "type": "int",
          "description": "the year of the data"
        },
        {
          "name": "- coo_id",
          "type": "int",
          "description": "country of origin numeric ID"
        },
        {
          "name": "- coa_id",
          "type": "int",
          "description": "country of asylum numeric ID"
        },
        {
          "name": "- coo_name",
          "type": "str",
          "description": "full name of country of origin"
        },
        {
          "name": "- coa_name",
          "type": "str",
          "description": "full name of country of asylum"
        },
        {
          "name": "- coo",
          "type": "str",
          "description": "legacy code for country of origin"
        },
        {
          "name": "- coa",
          "type": "str",
          "description": "legacy code for country of asylum"
        },
        {
          "name": "- coo_iso",
          "type": "str",
          "description": "ISO3 code for country of origin"
        },
        {
          "name": "- coa_iso",
          "type": "str",
          "description": "ISO3 code for country of asylum"
        },
        {
          "name": "- refugees",
          "type": "int",
          "description": "number of recognized refugees"
        },
        {
          "name": "- asylum_seekers",
          "type": "int",
          "description": "number of asylum seekers"
        },
        {
          "name": "- returned_refugees",
          "type": "int",
          "description": "number of returned refugees"
        },
        {
          "name": "- idps",
          "type": "int or str",
          "description": "number of internally displaced persons; \"0\" or numeric string"
        },
        {
          "name": "- returned_idps",
          "type": "int or str",
          "description": "number of returned internally displaced persons; \"0\" or numeric string"
        },
        {
          "name": "- stateless",
          "type": "int or str",
          "description": "number of stateless individuals; \"0\" or numeric string"
        },
        {
          "name": "- ooc",
          "type": "int or str",
          "description": "number of individuals out of concern; \"0\" or numeric value"
        },
        {
          "name": "- oip",
          "type": "int or str",
          "description": "number of individuals in protracted situations; \"-\" if not applicable"
        },
        {
          "name": "- hst",
          "type": "int or str",
          "description": "historical stock total; \"0\" or numeric string"
        }
      ],
      "brief_explain": "The output schema captures paginated UNHCR refugee population data with detailed breakdowns per country pair and year. Each item includes demographic categories like refugees, asylum seekers, IDPs, and stateless persons, along with metadata such as ISO codes and internal IDs. All key fields from the structured responses are preserved to ensure completeness and usability for analysis."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get refugee population data from UNHCR.\n    \n    Args:\n        coo: Country of origin (ISO3 code) - Use for questions about refugees FROM a specific country\n        coa: Country of asylum (ISO3 code) - Use for questions about refugees IN a specific country\n        year: Year to filter by (defaults to 2024)\n        coo_all: Set to True when breaking down results by ORIGIN country\n        coa_all: Set to True when breaking down results by ASYLUM country\n    \n    Important:\n        - For \"Where are refugees from COUNTRY living?\" use coo=\"COUNTRY\" and coa_all=True\n        - For \"How many refugees are living in COUNTRY?\" use coa=\"COUNTRY\"\n        - For \"What countries do refugees in COUNTRY come from?\" use coa=\"COUNTRY\" and coo_all=True\n        \n    Returns:\n        Population data from UNHCR\n    ",
        "name": "unhcr-population-data-server-get_population_data",
        "parameters": {
          "properties": {
            "coa": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Coa"
            },
            "coa_all": {
              "default": false,
              "title": "Coa All",
              "type": "boolean"
            },
            "coo": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Coo"
            },
            "coo_all": {
              "default": false,
              "title": "Coo All",
              "type": "boolean"
            },
            "year": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Year"
            }
          },
          "title": "get_population_dataArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "flux-imagegen-server-generateImageUrl": {
    "tool_name": "flux-imagegen-server-generateImageUrl",
    "output_schema_raw": "**output_schema**  \nimageUrl: [str, URL of the generated image,可以直接用于嵌入网页或分享]  \nprompt: [str, original text prompt used for image generation]  \nwidth: [int, width of the generated image in pixels]  \nheight: [int, height of the generated image in pixels]  \nmodel: [str, model name used for image generation (e.g., \"flux\", \"sdxl\", \"kontext\")]  \nseed: [int, random seed used for reproducible image generation]  \nenhance: [bool, whether the prompt was enhanced using an LLM before generation]  \nprivate: [bool, whether the image is marked as private]  \nnologo: [bool, whether the image is generated without a logo overlay]  \nsafe: [bool, whether content filtering was applied during generation]\n\n**brief_explain**  \nThe output schema captures all fields returned by the `flux-imagegen-server-generateImageUrl` tool, representing both the metadata of the image request and the resulting image URL. Each semantic field is separated for clarity and programmatic use, including dimensions, model, seed, and processing options like enhancement and safety filtering. The `imageUrl` provides direct access to the generated image with all parameters encoded.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "imageUrl",
          "type": "str",
          "description": "URL of the generated image,可以直接用于嵌入网页或分享"
        },
        {
          "name": "prompt",
          "type": "str",
          "description": "original text prompt used for image generation"
        },
        {
          "name": "width",
          "type": "int",
          "description": "width of the generated image in pixels"
        },
        {
          "name": "height",
          "type": "int",
          "description": "height of the generated image in pixels"
        },
        {
          "name": "model",
          "type": "str",
          "description": "model name used for image generation (e.g., \"flux\", \"sdxl\", \"kontext\")"
        },
        {
          "name": "seed",
          "type": "int",
          "description": "random seed used for reproducible image generation"
        },
        {
          "name": "enhance",
          "type": "bool",
          "description": "whether the prompt was enhanced using an LLM before generation"
        },
        {
          "name": "private",
          "type": "bool",
          "description": "whether the image is marked as private"
        },
        {
          "name": "nologo",
          "type": "bool",
          "description": "whether the image is generated without a logo overlay"
        },
        {
          "name": "safe",
          "type": "bool",
          "description": "whether content filtering was applied during generation"
        }
      ],
      "brief_explain": "The output schema captures all fields returned by the `flux-imagegen-server-generateImageUrl` tool, representing both the metadata of the image request and the resulting image URL. Each semantic field is separated for clarity and programmatic use, including dimensions, model, seed, and processing options like enhancement and safety filtering. The `imageUrl` provides direct access to the generated image with all parameters encoded."
    },
    "tool_schema": {
      "function": {
        "description": "Generate an image URL from a text prompt",
        "name": "flux-imagegen-server-generateImageUrl",
        "parameters": {
          "properties": {
            "enhance": {
              "description": "Whether to enhance the prompt using an LLM before generating (default: true)",
              "type": "boolean"
            },
            "height": {
              "description": "Height of the generated image (default: 1024)",
              "type": "number"
            },
            "model": {
              "description": "Model name to use for generation (default: \"flux\"). Available options: \"flux\", \"sdxl\", \"sd3\", \"sd15\", \"flux-schnell\", \"flux-dev\"",
              "type": "string"
            },
            "prompt": {
              "description": "The text description of the image to generate",
              "type": "string"
            },
            "safe": {
              "description": "Whether to apply content filtering (default: false)",
              "type": "boolean"
            },
            "seed": {
              "description": "Seed for reproducible results (default: random)",
              "type": "number"
            },
            "width": {
              "description": "Width of the generated image (default: 1024)",
              "type": "number"
            }
          },
          "required": [
            "prompt"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-api-server-getLiveTemperature": {
    "tool_name": "weather-api-server-getLiveTemperature",
    "output_schema_raw": "**output_schema**  \ntemperature: [float, current temperature in degrees Celsius]  \nlocation: [str, name of the city or location corresponding to the coordinates]  \ncountry: [str, full name of the country where the location is situated]  \ncondition: [str, current weather condition description (e.g., \"Sunny\", \"Partly cloudy\", \"Light rain shower\")]  \n\n**brief_explain**  \nThe tool returns structured weather data including temperature, location, country, and weather condition for given geographic coordinates. All examples show consistent JSON output with these four fields, indicating a stable and fully structured response format.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "temperature",
          "type": "float",
          "description": "current temperature in degrees Celsius"
        },
        {
          "name": "location",
          "type": "str",
          "description": "name of the city or location corresponding to the coordinates"
        },
        {
          "name": "country",
          "type": "str",
          "description": "full name of the country where the location is situated"
        },
        {
          "name": "condition",
          "type": "str",
          "description": "current weather condition description (e.g., \"Sunny\", \"Partly cloudy\", \"Light rain shower\")"
        }
      ],
      "brief_explain": "The tool returns structured weather data including temperature, location, country, and weather condition for given geographic coordinates. All examples show consistent JSON output with these four fields, indicating a stable and fully structured response format."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get live temperature for a specific location.\n\n    Args:\n        latitude: The latitude coordinate (e.g., 40.7128 for New York)\n        longitude: The longitude coordinate (e.g., -74.0060 for New York)\n\n    Returns:\n        A dictionary containing temperature information or an error message\n    ",
        "name": "weather-api-server-getLiveTemperature",
        "parameters": {
          "properties": {
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "title": "getLiveTemperatureArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "airbnb-search-and-listing-details-server-airbnb_search": {
    "tool_name": "airbnb-search-and-listing-details-server-airbnb_search",
    "output_schema_raw": "**output_schema**  \nsearchUrl: [str, URL to the Airbnb search results page for the given location and filters]  \nerror: [str, error message if the request was blocked or failed, such as due to robots.txt restrictions]  \nurl: [str, fallback or alternative URL provided when an error occurs, typically the same as searchUrl but may differ in some cases]\n\n**brief_explain**  \nThe tool returns either a successful search URL for Airbnb listings or an error with a descriptive message and fallback URL. The response is minimally structured, containing only top-level string fields for the search link and potential error details.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "searchUrl",
          "type": "str",
          "description": "URL to the Airbnb search results page for the given location and filters"
        },
        {
          "name": "error",
          "type": "str",
          "description": "error message if the request was blocked or failed, such as due to robots.txt restrictions"
        },
        {
          "name": "url",
          "type": "str",
          "description": "fallback or alternative URL provided when an error occurs, typically the same as searchUrl but may differ in some cases"
        }
      ],
      "brief_explain": "The tool returns either a successful search URL for Airbnb listings or an error with a descriptive message and fallback URL. The response is minimally structured, containing only top-level string fields for the search link and potential error details."
    },
    "tool_schema": {
      "function": {
        "description": "Search for Airbnb listings with various filters and pagination. Provide direct links to the user",
        "name": "airbnb-search-and-listing-details-server-airbnb_search",
        "parameters": {
          "properties": {
            "adults": {
              "description": "Number of adults",
              "type": "number"
            },
            "checkin": {
              "description": "Check-in date (YYYY-MM-DD)",
              "type": "string"
            },
            "checkout": {
              "description": "Check-out date (YYYY-MM-DD)",
              "type": "string"
            },
            "children": {
              "description": "Number of children",
              "type": "number"
            },
            "cursor": {
              "description": "Base64-encoded string used for Pagination",
              "type": "string"
            },
            "ignoreRobotsText": {
              "description": "Ignore robots.txt rules for this request",
              "type": "boolean"
            },
            "infants": {
              "description": "Number of infants",
              "type": "number"
            },
            "location": {
              "description": "Location to search for (city, state, etc.)",
              "type": "string"
            },
            "maxPrice": {
              "description": "Maximum price for the stay",
              "type": "number"
            },
            "minPrice": {
              "description": "Minimum price for the stay",
              "type": "number"
            },
            "pets": {
              "description": "Number of pets",
              "type": "number"
            },
            "placeId": {
              "description": "Google Maps Place ID (overrides the location parameter)",
              "type": "string"
            }
          },
          "required": [
            "location"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "united-states-weather-get_weather_forecast": {
    "tool_name": "united-states-weather-get_weather_forecast",
    "output_schema_raw": "**output_schema**  \nlocation: [str, coordinates in \"lat,lng\" format for the forecast location]  \nupdated: [str, timestamp of when the forecast was last updated, in \"M/D/YYYY, H:MM AM/PM (local time)\" format]  \nforecast_days: [List[Dict], list of daily forecast periods, each containing 'day' and 'night' entries with weather details]  \n  # Each item in forecast_days is a Dict representing a 24-hour period split into day and night:\n  # - 'period': str, either \"Day\" or \"Night\"\n  # - 'temperature': str, formatted temperature (e.g., \"89°F (31.7°C)\")\n  # - 'conditions': str, descriptive weather condition (e.g., \"Showers And Thunderstorms Likely\")\n  # - 'precipitation_chance': str, chance of precipitation as percentage (e.g., \"75% chance\")\n  # - 'wind': str, wind speed and direction (e.g., \"3 to 9 mph NE\")\n  # - 'detailed_description': str, full prose description of the period's weather\n\n**brief_explain**  \nThe output schema captures all structured weather forecast data from the tool, including location, update time, and a list of time-specific forecasts split into day and night periods. Each forecast period includes key fields like temperature, conditions, precipitation chance, wind, and detailed description to preserve all information from the original unstructured response.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "str",
          "description": "coordinates in \"lat,lng\" format for the forecast location"
        },
        {
          "name": "updated",
          "type": "str",
          "description": "timestamp of when the forecast was last updated, in \"M/D/YYYY, H:MM AM/PM (local time)\" format"
        },
        {
          "name": "forecast_days",
          "type": "List[Dict]",
          "description": "list of daily forecast periods, each containing 'day' and 'night' entries with weather details"
        },
        {
          "name": "# Each item in forecast_days is a Dict representing a 24-hour period split into day and night",
          "type": "",
          "description": ""
        },
        {
          "name": "# - 'period'",
          "type": "str",
          "description": "either \"Day\" or \"Night\""
        },
        {
          "name": "# - 'temperature'",
          "type": "str",
          "description": "formatted temperature (e.g., \"89°F (31.7°C)\")"
        },
        {
          "name": "# - 'conditions'",
          "type": "str",
          "description": "descriptive weather condition (e.g., \"Showers And Thunderstorms Likely\")"
        },
        {
          "name": "# - 'precipitation_chance'",
          "type": "str",
          "description": "chance of precipitation as percentage (e.g., \"75% chance\")"
        },
        {
          "name": "# - 'wind'",
          "type": "str",
          "description": "wind speed and direction (e.g., \"3 to 9 mph NE\")"
        },
        {
          "name": "# - 'detailed_description'",
          "type": "str",
          "description": "full prose description of the period's weather"
        }
      ],
      "brief_explain": "The output schema captures all structured weather forecast data from the tool, including location, update time, and a list of time-specific forecasts split into day and night periods. Each forecast period includes key fields like temperature, conditions, precipitation chance, wind, and detailed description to preserve all information from the original unstructured response."
    },
    "tool_schema": {
      "function": {
        "description": "Get multi-day weather forecast for a location in the United States. Perfect for 'What's the forecast for [US location]?' questions. Provides detailed day/night forecasts for up to 7 days.",
        "name": "united-states-weather-get_weather_forecast",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "days": {
              "default": 7,
              "description": "Number of days to forecast (1-7, default 7). Each day includes both day and night periods.",
              "type": "number"
            },
            "location": {
              "description": "US location as coordinates (lat,lng) in decimal degrees. Example: '40.7128,-74.0060' for New York City. Must be within US boundaries including states, territories (PR, VI, AS, GU, MP), and coastal waters.",
              "type": "string"
            }
          },
          "required": [
            "location"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-server-get_weather": {
    "tool_name": "weather-server-get_weather",
    "output_schema_raw": "**output_schema**  \ncity: [str, name of the city for which weather is provided]  \ntemperature: [str, current temperature with unit (e.g., \"22°C\")]  \ncondition: [str, current weather condition (e.g., \"Sunny\", \"Light rain\")]  \nhumidity: [str, current humidity level with percentage (e.g., \"65%\")]  \nwind: [str, wind speed with unit (e.g., \"5 km/h\")]  \nforecast: [List[Dict], list of daily forecast entries, each containing 'date' (str), 'max' (str, max temperature), 'min' (str, min temperature), and 'condition' (str)]  \n\n**brief_explain**  \nThe output schema captures current weather conditions and a 3-day forecast. All fields are derived from structured responses, with forecast as a list of dictionaries to preserve temporal detail. Each semantic element (e.g., temperature, condition) has its own field, ensuring clarity and lossless data representation.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "city",
          "type": "str",
          "description": "name of the city for which weather is provided"
        },
        {
          "name": "temperature",
          "type": "str",
          "description": "current temperature with unit (e.g., \"22°C\")"
        },
        {
          "name": "condition",
          "type": "str",
          "description": "current weather condition (e.g., \"Sunny\", \"Light rain\")"
        },
        {
          "name": "humidity",
          "type": "str",
          "description": "current humidity level with percentage (e.g., \"65%\")"
        },
        {
          "name": "wind",
          "type": "str",
          "description": "wind speed with unit (e.g., \"5 km/h\")"
        },
        {
          "name": "forecast",
          "type": "List[Dict]",
          "description": "list of daily forecast entries, each containing 'date' (str), 'max' (str, max temperature), 'min' (str, min temperature), and 'condition' (str)"
        }
      ],
      "brief_explain": "The output schema captures current weather conditions and a 3-day forecast. All fields are derived from structured responses, with forecast as a list of dictionaries to preserve temporal detail. Each semantic element (e.g., temperature, condition) has its own field, ensuring clarity and lossless data representation."
    },
    "tool_schema": {
      "function": {
        "description": "Get current weather for a city.",
        "name": "weather-server-get_weather",
        "parameters": {
          "properties": {
            "city": {
              "title": "City",
              "type": "string"
            },
            "detailed": {
              "default": false,
              "title": "Detailed",
              "type": "boolean"
            },
            "units": {
              "default": "metric",
              "title": "Units",
              "type": "string"
            }
          },
          "required": [
            "city"
          ],
          "title": "get_weatherArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-app-server-get_live_temp": {
    "tool_name": "weather-app-server-get_live_temp",
    "output_schema_raw": "**output_schema**  \ntemperature: [float, current temperature in degrees Celsius]\n\n**brief_explain**  \nThe tool returns a single numeric value representing the live temperature at the specified coordinates, structured as a float under the key \"temperature\". No other fields are present or expected in the response.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "temperature",
          "type": "float",
          "description": "current temperature in degrees Celsius"
        }
      ],
      "brief_explain": "The tool returns a single numeric value representing the live temperature at the specified coordinates, structured as a float under the key \"temperature\". No other fields are present or expected in the response."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get live temperature for a given latitude and longitude.\n    ",
        "name": "weather-app-server-get_live_temp",
        "parameters": {
          "properties": {
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "title": "get_live_tempArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-search_problems": {
    "tool_name": "leetcode-search_problems",
    "output_schema_raw": "**output_schema**  \nfilters: [Dict, contains the applied filter criteria including 'tags' (List[str]), 'difficulty' (str), and potentially other search parameters used in the query]  \npagination: [Dict, contains pagination details with 'limit' (int) indicating number of problems returned per page]  \nproblems: [Dict, contains 'total' (int) for total matching problems, and 'questions' (List[Dict]) listing each problem with 'title', 'titleSlug', 'difficulty', 'acRate', and 'topicTags' (List[str])]\n\n**brief_explain**  \nThe response includes filters applied, pagination settings, and a structured list of problems with key metadata like title, difficulty, acceptance rate, and associated tags.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "filters",
          "type": "Dict",
          "description": "contains the applied filter criteria including 'tags' (List[str]), 'difficulty' (str), and potentially other search parameters used in the query"
        },
        {
          "name": "pagination",
          "type": "Dict",
          "description": "contains pagination details with 'limit' (int) indicating number of problems returned per page"
        },
        {
          "name": "problems",
          "type": "Dict",
          "description": "contains 'total' (int) for total matching problems, and 'questions' (List[Dict]) listing each problem with 'title', 'titleSlug', 'difficulty', 'acRate', and 'topicTags' (List[str])"
        }
      ],
      "brief_explain": "The response includes filters applied, pagination settings, and a structured list of problems with key metadata like title, difficulty, acceptance rate, and associated tags."
    },
    "tool_schema": {
      "function": {
        "description": "Searches for LeetCode problems based on multiple filter criteria including categories, tags, difficulty levels, and keywords, with pagination support",
        "name": "leetcode-search_problems",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "category": {
              "default": "all-code-essentials",
              "description": "Problem category filter (e.g., 'algorithms', 'database', 'shell') to narrow down the problem domain",
              "enum": [
                "all-code-essentials",
                "algorithms",
                "database",
                "pandas",
                "javascript",
                "shell",
                "concurrency"
              ],
              "type": "string"
            },
            "difficulty": {
              "description": "Problem difficulty level filter to show only problems of a specific difficulty",
              "enum": [
                "EASY",
                "MEDIUM",
                "HARD"
              ],
              "type": "string"
            },
            "limit": {
              "default": 10,
              "description": "Maximum number of problems to return in a single request (for pagination)",
              "type": "number"
            },
            "offset": {
              "description": "Number of problems to skip (for pagination)",
              "type": "number"
            },
            "searchKeywords": {
              "description": "Keywords to search in problem titles and descriptions",
              "type": "string"
            },
            "tags": {
              "description": "List of topic tags to filter problems by (e.g., ['array', 'dynamic-programming', 'tree'])",
              "items": {
                "enum": [
                  "array",
                  "string",
                  "hash-table",
                  "dynamic-programming",
                  "math",
                  "sorting",
                  "greedy",
                  "depth-first-search",
                  "binary-search",
                  "database",
                  "tree",
                  "breadth-first-search",
                  "matrix",
                  "bit-manipulation",
                  "two-pointers",
                  "binary-tree",
                  "heap-priority-queue",
                  "prefix-sum",
                  "stack",
                  "simulation",
                  "graph",
                  "counting",
                  "sliding-window",
                  "design",
                  "backtracking",
                  "enumeration",
                  "linked-list",
                  "union-find",
                  "ordered-set",
                  "monotonic-stack",
                  "number-theory",
                  "trie",
                  "segment-tree",
                  "recursion",
                  "divide-and-conquer",
                  "queue",
                  "combinatorics",
                  "binary-search-tree",
                  "bitmask",
                  "memoization",
                  "geometry",
                  "binary-indexed-tree",
                  "hash-function",
                  "topological-sort",
                  "string-matching",
                  "shortest-path",
                  "rolling-hash",
                  "game-theory",
                  "data-stream",
                  "interactive",
                  "monotonic-queue",
                  "brainteaser",
                  "doubly-linked-list",
                  "merge-sort",
                  "randomized",
                  "quickselect",
                  "counting-sort",
                  "iterator",
                  "probability-and-statistics",
                  "concurrency",
                  "bucket-sort",
                  "suffix-array",
                  "line-sweep",
                  "minimum-spanning-tree",
                  "shell",
                  "reservoir-sampling",
                  "strongly-connected-component",
                  "eulerian-circuit",
                  "radix-sort",
                  "biconnected-component",
                  "rejection-sampling"
                ],
                "type": "string"
              },
              "type": "array"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-juejin-article-rank": {
    "tool_name": "trends-hub-get-juejin-article-rank",
    "output_schema_raw": "**output_schema**  \narticles: [List[Dict], list of article items, each containing 'title', 'author', 'popularity', 'view_count', 'like_count', 'collect_count', 'comment_count', 'interact_count', and 'link' fields]  \n\n**brief_explain**  \nThe tool returns a list of trending articles from Juejin in a custom text-based format with consistent XML-like tags. Each article contains structured metadata including title, author, popularity score, view count, like count, collect count, comment count, interaction count, and the article URL. The response is unstructured in transmission but semantically regular, so it can be fully parsed into a structured list of dictionaries with uniform fields.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "articles",
          "type": "List[Dict]",
          "description": "list of article items, each containing 'title', 'author', 'popularity', 'view_count', 'like_count', 'collect_count', 'comment_count', 'interact_count', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns a list of trending articles from Juejin in a custom text-based format with consistent XML-like tags. Each article contains structured metadata including title, author, popularity score, view count, like count, collect count, comment count, interaction count, and the article URL. The response is unstructured in transmission but semantically regular, so it can be fully parsed into a structured list of dictionaries with uniform fields."
    },
    "tool_schema": {
      "function": {
        "description": "获取掘金文章榜，包含前端开发、后端技术、人工智能、移动开发及技术架构等领域的高质量中文技术文章和教程",
        "name": "trends-hub-get-juejin-article-rank",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "category_id": {
              "anyOf": [
                {
                  "const": "6809637769959178254",
                  "description": "后端",
                  "type": "string"
                },
                {
                  "const": "6809637767543259144",
                  "description": "前端",
                  "type": "string"
                },
                {
                  "const": "6809635626879549454",
                  "description": "Android",
                  "type": "string"
                },
                {
                  "const": "6809635626661445640",
                  "description": "iOS",
                  "type": "string"
                },
                {
                  "const": "6809637773935378440",
                  "description": "人工智能",
                  "type": "string"
                },
                {
                  "const": "6809637771511070734",
                  "description": "开发工具",
                  "type": "string"
                },
                {
                  "const": "6809637776263217160",
                  "description": "代码人生",
                  "type": "string"
                },
                {
                  "const": "6809637772874219534",
                  "description": "阅读",
                  "type": "string"
                }
              ],
              "default": "6809637769959178254"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-theverge-news": {
    "tool_name": "trends-hub-get-theverge-news",
    "output_schema_raw": "**output_schema**  \narticles: [List[Dict], list of news articles, each with 'title', 'description', 'publish_time', and 'link' fields]  \n\n**brief_explain**  \nThe tool returns multiple news items from The Verge in a structured format where each article contains a title, description, publication timestamp, and URL. These are consistently present across all examples, so the response is best modeled as a list of dictionaries with these four fields.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "articles",
          "type": "List[Dict]",
          "description": "list of news articles, each with 'title', 'description', 'publish_time', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns multiple news items from The Verge in a structured format where each article contains a title, description, publication timestamp, and URL. These are consistently present across all examples, so the response is best modeled as a list of dictionaries with these four fields."
    },
    "tool_schema": {
      "function": {
        "description": "获取 The Verge 新闻，包含科技创新、数码产品评测、互联网趋势及科技公司动态的英文科技资讯",
        "name": "trends-hub-get-theverge-news",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-9to5mac-news": {
    "tool_name": "trends-hub-get-9to5mac-news",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取 9to5Mac 苹果相关新闻，包含苹果产品发布、iOS 更新、Mac 硬件、应用推荐及苹果公司动态的英文资讯",
        "name": "trends-hub-get-9to5mac-news",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mcp服务-query_weather": {
    "tool_name": "mcp服务-query_weather",
    "output_schema_raw": "**output_schema**  \nlocation: [str, full location string including city and country, e.g., \"New York, US\"]  \ntemperature_celsius: [float, current temperature in degrees Celsius]  \nhumidity: [int or float, relative humidity percentage]  \nwind_speed_m_s: [float, wind speed in meters per second]  \nweather_condition: [str, textual description of current weather, e.g., \"晴\" (clear)]  \ncity: [str, name of the city queried]  \ncountry: [str, ISO country code or full country name as shown in response]\n\n**brief_explain**  \nThe schema extracts all observable weather data from the tool's unstructured text response into discrete, machine-readable fields. Each meteorological attribute is separated into its own typed field, with geographic information split into city and country for better usability. Despite the original format using emojis and Chinese characters, the structured output captures the semantics losslessly and enables downstream computation (e.g., averaging temperatures).",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "str",
          "description": "full location string including city and country, e.g., \"New York, US\""
        },
        {
          "name": "temperature_celsius",
          "type": "float",
          "description": "current temperature in degrees Celsius"
        },
        {
          "name": "humidity",
          "type": "int or float",
          "description": "relative humidity percentage"
        },
        {
          "name": "wind_speed_m_s",
          "type": "float",
          "description": "wind speed in meters per second"
        },
        {
          "name": "weather_condition",
          "type": "str",
          "description": "textual description of current weather, e.g., \"晴\" (clear)"
        },
        {
          "name": "city",
          "type": "str",
          "description": "name of the city queried"
        },
        {
          "name": "country",
          "type": "str",
          "description": "ISO country code or full country name as shown in response"
        }
      ],
      "brief_explain": "The schema extracts all observable weather data from the tool's unstructured text response into discrete, machine-readable fields. Each meteorological attribute is separated into its own typed field, with geographic information split into city and country for better usability. Despite the original format using emojis and Chinese characters, the structured output captures the semantics losslessly and enables downstream computation (e.g., averaging temperatures)."
    },
    "tool_schema": {
      "function": {
        "description": "\n    输入指定城市的英文名称，返回今日天气查询结果。\n    :param city: 城市名称（需使用英文）\n    :return: 格式化后的天气信息\n    ",
        "name": "mcp服务-query_weather",
        "parameters": {
          "properties": {
            "city": {
              "title": "City",
              "type": "string"
            }
          },
          "required": [
            "city"
          ],
          "title": "query_weatherArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mapas-mentais-server-compara": {
    "tool_name": "mapas-mentais-server-compara",
    "output_schema_raw": "**output_schema**  \ncomparison_title: [str, title of the comparison between the two themes]  \nfocus_topics: [List[str], list of topics that the comparison focuses on, such as definitions, characteristics, advantages, etc.]  \ntheme1: [str, first theme being compared]  \ntheme2: [str, second theme being compared]  \ncomparison_points: [Dict, contains structured comparison data for each focus topic, with keys corresponding to the topics in focus_topics and values containing the comparative analysis for both themes]\n\n**brief_explain**  \nThe schema captures the core comparison between two themes, including the main title, the list of focused comparison topics, the names of the two themes, and a structured breakdown of how they compare across each topic. This ensures full information retention from the unstructured response while enabling programmatic access to each semantic component.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "comparison_title",
          "type": "str",
          "description": "title of the comparison between the two themes"
        },
        {
          "name": "focus_topics",
          "type": "List[str]",
          "description": "list of topics that the comparison focuses on, such as definitions, characteristics, advantages, etc."
        },
        {
          "name": "theme1",
          "type": "str",
          "description": "first theme being compared"
        },
        {
          "name": "theme2",
          "type": "str",
          "description": "second theme being compared"
        },
        {
          "name": "comparison_points",
          "type": "Dict",
          "description": "contains structured comparison data for each focus topic, with keys corresponding to the topics in focus_topics and values containing the comparative analysis for both themes"
        }
      ],
      "brief_explain": "The schema captures the core comparison between two themes, including the main title, the list of focused comparison topics, the names of the two themes, and a structured breakdown of how they compare across each topic. This ensures full information retention from the unstructured response while enabling programmatic access to each semantic component."
    },
    "tool_schema": {
      "function": {
        "description": "Gera um mapa mental comparando dois temas.",
        "name": "mapas-mentais-server-compara",
        "parameters": {
          "properties": {
            "tema1": {
              "title": "Tema1",
              "type": "string"
            },
            "tema2": {
              "title": "Tema2",
              "type": "string"
            }
          },
          "required": [
            "tema1",
            "tema2"
          ],
          "title": "comparaArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "ipma-weather-data-server-get_seismic_data": {
    "tool_name": "ipma-weather-data-server-get_seismic_data",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "Obter dados sísmicos recentes",
        "name": "ipma-weather-data-server-get_seismic_data",
        "parameters": {
          "properties": {
            "area": {
              "default": "all",
              "description": "Área: 'continent', 'azores', 'madeira', ou 'all'",
              "type": "string"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "flux-imagegen-server-generateImage": {
    "tool_name": "flux-imagegen-server-generateImage",
    "output_schema_raw": "**output_schema**  \nimage_data: [str, base64-encoded string of the generated image]  \nfile_path: [str, full path where the image was saved, including filename and extension]  \nfile_name: [str, name of the saved file without path, derived from prompt or user-specified]  \nformat: [str, image format used for saving (e.g., png, jpeg, jpg, webp)]  \nwidth: [int, width of the generated image in pixels]  \nheight: [int, height of the generated image in pixels]  \nmodel: [str, model name used for generation (e.g., \"flux\", \"turbo\")]  \nprompt: [str, original text description used to generate the image]  \nenhanced_prompt: [str, final prompt used after optional LLM-based enhancement]  \nseed: [int, random seed used for reproducible image generation]  \nenhance: [bool, whether prompt enhancement was applied before generation]  \nsafe: [bool, whether content filtering was enabled during generation]  \nprivate: [bool, whether the image was marked as private]  \nnologo: [bool, whether logo watermarking was disabled]  \n\nmetadata: [Dict, contains detailed generation parameters with keys: 'prompt', 'width', 'height', 'model', 'seed', 'enhance', 'private', 'nologo', 'safe']  \n\n**brief_explain**  \nThe output schema captures all structured information returned by the tool, including file details, image properties, generation settings, and embedded metadata. It separates atomic values for easy access while preserving the original metadata object for completeness.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "image_data",
          "type": "str",
          "description": "base64-encoded string of the generated image"
        },
        {
          "name": "file_path",
          "type": "str",
          "description": "full path where the image was saved, including filename and extension"
        },
        {
          "name": "file_name",
          "type": "str",
          "description": "name of the saved file without path, derived from prompt or user-specified"
        },
        {
          "name": "format",
          "type": "str",
          "description": "image format used for saving (e.g., png, jpeg, jpg, webp)"
        },
        {
          "name": "width",
          "type": "int",
          "description": "width of the generated image in pixels"
        },
        {
          "name": "height",
          "type": "int",
          "description": "height of the generated image in pixels"
        },
        {
          "name": "model",
          "type": "str",
          "description": "model name used for generation (e.g., \"flux\", \"turbo\")"
        },
        {
          "name": "prompt",
          "type": "str",
          "description": "original text description used to generate the image"
        },
        {
          "name": "enhanced_prompt",
          "type": "str",
          "description": "final prompt used after optional LLM-based enhancement"
        },
        {
          "name": "seed",
          "type": "int",
          "description": "random seed used for reproducible image generation"
        },
        {
          "name": "enhance",
          "type": "bool",
          "description": "whether prompt enhancement was applied before generation"
        },
        {
          "name": "safe",
          "type": "bool",
          "description": "whether content filtering was enabled during generation"
        },
        {
          "name": "private",
          "type": "bool",
          "description": "whether the image was marked as private"
        },
        {
          "name": "nologo",
          "type": "bool",
          "description": "whether logo watermarking was disabled"
        },
        {
          "name": "metadata",
          "type": "Dict",
          "description": "contains detailed generation parameters with keys: 'prompt', 'width', 'height', 'model', 'seed', 'enhance', 'private', 'nologo', 'safe'"
        }
      ],
      "brief_explain": "The output schema captures all structured information returned by the tool, including file details, image properties, generation settings, and embedded metadata. It separates atomic values for easy access while preserving the original metadata object for completeness."
    },
    "tool_schema": {
      "function": {
        "description": "Generate an image, return the base64-encoded data, and save to a file by default",
        "name": "flux-imagegen-server-generateImage",
        "parameters": {
          "properties": {
            "enhance": {
              "description": "Whether to enhance the prompt using an LLM before generating (default: true)",
              "type": "boolean"
            },
            "fileName": {
              "description": "Name of the file to save (without extension, default: generated from prompt)",
              "type": "string"
            },
            "format": {
              "description": "Image format to save as (png, jpeg, jpg, webp - default: png)",
              "type": "string"
            },
            "height": {
              "description": "Height of the generated image (default: 1024)",
              "type": "number"
            },
            "model": {
              "description": "Model name to use for generation (default: \"flux\"). Available options: \"flux, \"turbo\" (sdxl),",
              "type": "string"
            },
            "outputPath": {
              "description": "Directory path where to save the image (default: \"./mcpollinations-output\")",
              "type": "string"
            },
            "prompt": {
              "description": "The text description of the image to generate",
              "type": "string"
            },
            "safe": {
              "description": "Whether to apply content filtering (default: false)",
              "type": "boolean"
            },
            "seed": {
              "description": "Seed for reproducible results (default: random)",
              "type": "number"
            },
            "width": {
              "description": "Width of the generated image (default: 1024)",
              "type": "number"
            }
          },
          "required": [
            "prompt"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "united-states-weather-get_weather_alerts": {
    "tool_name": "united-states-weather-get_weather_alerts",
    "output_schema_raw": "**output_schema**  \nalerts: [List[Dict], list of active weather alerts, each containing 'event', 'severity', 'urgency', 'areas', 'effective', 'expires', 'description', and 'instructions' fields]  \nlocation: [str, the location identifier used in the query, either coordinates or state code]  \nalert_count: [int, number of active alerts returned for the location]\n\n**brief_explain**  \nThe tool returns a structured list of active weather alerts with detailed metadata per alert, along with the queried location and total alert count. Each alert includes event type, severity, urgency, affected areas, time range, description, and safety instructions.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "alerts",
          "type": "List[Dict]",
          "description": "list of active weather alerts, each containing 'event', 'severity', 'urgency', 'areas', 'effective', 'expires', 'description', and 'instructions' fields"
        },
        {
          "name": "location",
          "type": "str",
          "description": "the location identifier used in the query, either coordinates or state code"
        },
        {
          "name": "alert_count",
          "type": "int",
          "description": "number of active alerts returned for the location"
        }
      ],
      "brief_explain": "The tool returns a structured list of active weather alerts with detailed metadata per alert, along with the queried location and total alert count. Each alert includes event type, severity, urgency, affected areas, time range, description, and safety instructions."
    },
    "tool_schema": {
      "function": {
        "description": "Get active weather alerts, warnings, watches, and advisories for locations in the United States. Perfect for 'Are there any weather alerts in [US location]?' questions. Covers severe weather, winter storms, heat warnings, flood alerts, and more.",
        "name": "united-states-weather-get_weather_alerts",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "location": {
              "description": "US location as coordinates (lat,lng) in decimal degrees OR 2-letter state/territory code. Examples: '40.7128,-74.0060' for New York City, 'CA' for California, 'PR' for Puerto Rico. Valid state codes: AL, AK, AS, AR, AZ, CA, CO, CT, DE, DC, FL, GA, GU, HI, ID, IL, IN, IA, KS, KY, LA, ME, MD, MA, MI, MN, MS, MO, MT, NE, NV, NH, NJ, NM, NY, NC, ND, OH, OK, OR, PA, PR, RI, SC, SD, TN, TX, UT, VT, VI, VA, WA, WV, WI, WY, MP, PW, FM, MH.",
              "type": "string"
            },
            "severity": {
              "default": "all",
              "description": "Filter by alert severity: 'extreme' (life-threatening), 'severe' (significant threat), 'moderate' (possible threat), 'minor' (minimal threat), or 'all' (default - shows all active alerts).",
              "enum": [
                "all",
                "extreme",
                "severe",
                "moderate",
                "minor"
              ],
              "type": "string"
            }
          },
          "required": [
            "location"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mcp-server-get_definitions": {
    "tool_name": "mcp-server-get_definitions",
    "output_schema_raw": "**output_schema**  \ndefinition: [str, the definition of the requested word or phrase; may be a plain text explanation or an empty result indicator]  \nis_found: [bool, indicates whether a definition was successfully found for the requested word (True) or not (False)]\n\n**brief_explain**  \nThe tool returns either a textual definition or \"No definitions found.\" The schema captures both outcomes by separating the definition text and a boolean flag indicating its presence, ensuring lossless and structured representation of all possible responses.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "definition",
          "type": "str",
          "description": "the definition of the requested word or phrase; may be a plain text explanation or an empty result indicator"
        },
        {
          "name": "is_found",
          "type": "bool",
          "description": "indicates whether a definition was successfully found for the requested word (True) or not (False)"
        }
      ],
      "brief_explain": "The tool returns either a textual definition or \"No definitions found.\" The schema captures both outcomes by separating the definition text and a boolean flag indicating its presence, ensuring lossless and structured representation of all possible responses."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get definitions for a word.\n    ",
        "name": "mcp-server-get_definitions",
        "parameters": {
          "properties": {
            "word": {
              "title": "Word",
              "type": "string"
            }
          },
          "required": [
            "word"
          ],
          "title": "get_definitionsArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "books-server-search_word": {
    "tool_name": "books-server-search_word",
    "output_schema_raw": "**output_schema**  \nword: [str, the word or phrase that was searched for]  \ndefinitions: [List[Dict], list of definition entries, each containing 'part_of_speech' (str) and 'definition_text' (str) fields]  \n\n**brief_explain**  \nThe tool returns information about a searched word, including its part of speech and multiple definitions. Each definition is structured as a separate entry with its grammatical category and meaning text. The response is normalized into a structured format with the queried word and a list of definition objects.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "word",
          "type": "str",
          "description": "the word or phrase that was searched for"
        },
        {
          "name": "definitions",
          "type": "List[Dict]",
          "description": "list of definition entries, each containing 'part_of_speech' (str) and 'definition_text' (str) fields"
        }
      ],
      "brief_explain": "The tool returns information about a searched word, including its part of speech and multiple definitions. Each definition is structured as a separate entry with its grammatical category and meaning text. The response is normalized into a structured format with the queried word and a list of definition objects."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Search for a word and provide basic information.\n    \n    Args:\n        query: The word or phrase to search for\n    \n    Returns:\n        Search results or suggestions\n    ",
        "name": "books-server-search_word",
        "parameters": {
          "properties": {
            "query": {
              "title": "Query",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "title": "search_wordArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-get_daily_challenge": {
    "tool_name": "leetcode-get_daily_challenge",
    "output_schema_raw": "**output_schema**  \ndate: [str, the date of the daily challenge in YYYY-MM-DD format]  \nproblem_link: [str, relative URL path to the problem on LeetCode]  \nproblem_title: [str, title of the coding problem]  \nproblem_title_slug: [str, URL-friendly slug version of the problem title]  \nproblem_difficulty: [str, difficulty level of the problem (e.g., \"Easy\", \"Medium\", \"Hard\")]  \nproblem_description: [str, HTML-formatted description of the problem including examples and constraints]  \nproblem_constraints: [List[str], list of constraint strings extracted from the problem statement]  \nproblem_examples: [List[Dict], list of example cases, each with 'input', 'output', and 'explanation' fields]  \nproblem_topics: [List[str], list of topic tags associated with the problem (e.g., \"Array\", \"Math\")]  \nproblem_code_templates: [List[Dict], list of code templates for different programming languages, each with 'lang', 'langSlug', and 'code' fields]  \nproblem_stats_total_accepted: [str, total number of accepted submissions (formatted string)]  \nproblem_stats_total_submissions: [str, total number of submissions (formatted string)]  \nproblem_stats_acceptance_rate: [str, acceptance rate percentage as a string]  \nproblem_hints: [List[str], list of hints provided for solving the problem]  \nproblem_sample_test_case: [str, sample test case input provided for testing]  \nproblem_function_name: [str, name of the function to implement in the solution]  \nproblem_parameters: [List[Dict], list of function parameters, each with 'name' and 'type' fields]  \nproblem_return_type: [str, return type of the function]  \n\n**brief_explain**  \nThe schema captures all essential components of the LeetCode daily challenge: metadata (title, difficulty, date), problem content (description, examples, constraints), code scaffolding (templates per language), statistical data, solution hints, and function signature details. Each semantic unit is separated into its own field, with lists used for collections like examples and topics, and nested dicts for structured items like parameters and code templates. This ensures full information retention in a structured, accessible format.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "date",
          "type": "str",
          "description": "the date of the daily challenge in YYYY-MM-DD format"
        },
        {
          "name": "problem_link",
          "type": "str",
          "description": "relative URL path to the problem on LeetCode"
        },
        {
          "name": "problem_title",
          "type": "str",
          "description": "title of the coding problem"
        },
        {
          "name": "problem_title_slug",
          "type": "str",
          "description": "URL-friendly slug version of the problem title"
        },
        {
          "name": "problem_difficulty",
          "type": "str",
          "description": "difficulty level of the problem (e.g., \"Easy\", \"Medium\", \"Hard\")"
        },
        {
          "name": "problem_description",
          "type": "str",
          "description": "HTML-formatted description of the problem including examples and constraints"
        },
        {
          "name": "problem_constraints",
          "type": "List[str]",
          "description": "list of constraint strings extracted from the problem statement"
        },
        {
          "name": "problem_examples",
          "type": "List[Dict]",
          "description": "list of example cases, each with 'input', 'output', and 'explanation' fields"
        },
        {
          "name": "problem_topics",
          "type": "List[str]",
          "description": "list of topic tags associated with the problem (e.g., \"Array\", \"Math\")"
        },
        {
          "name": "problem_code_templates",
          "type": "List[Dict]",
          "description": "list of code templates for different programming languages, each with 'lang', 'langSlug', and 'code' fields"
        },
        {
          "name": "problem_stats_total_accepted",
          "type": "str",
          "description": "total number of accepted submissions (formatted string)"
        },
        {
          "name": "problem_stats_total_submissions",
          "type": "str",
          "description": "total number of submissions (formatted string)"
        },
        {
          "name": "problem_stats_acceptance_rate",
          "type": "str",
          "description": "acceptance rate percentage as a string"
        },
        {
          "name": "problem_hints",
          "type": "List[str]",
          "description": "list of hints provided for solving the problem"
        },
        {
          "name": "problem_sample_test_case",
          "type": "str",
          "description": "sample test case input provided for testing"
        },
        {
          "name": "problem_function_name",
          "type": "str",
          "description": "name of the function to implement in the solution"
        },
        {
          "name": "problem_parameters",
          "type": "List[Dict]",
          "description": "list of function parameters, each with 'name' and 'type' fields"
        },
        {
          "name": "problem_return_type",
          "type": "str",
          "description": "return type of the function"
        }
      ],
      "brief_explain": "The schema captures all essential components of the LeetCode daily challenge: metadata (title, difficulty, date), problem content (description, examples, constraints), code scaffolding (templates per language), statistical data, solution hints, and function signature details. Each semantic unit is separated into its own field, with lists used for collections like examples and topics, and nested dicts for structured items like parameters and code templates. This ensures full information retention in a structured, accessible format."
    },
    "tool_schema": {
      "function": {
        "description": "Retrieves today's LeetCode Daily Challenge problem with complete details, including problem description, constraints, and examples",
        "name": "leetcode-get_daily_challenge",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-infoq-news": {
    "tool_name": "trends-hub-get-infoq-news",
    "output_schema_raw": "**output_schema**  \nnews_list: [List[Dict], list of news articles, each containing 'title', 'description', 'category', 'author', 'publish_time', and 'link' fields]  \n\n**brief_explain**  \nThe tool returns a list of tech news articles from InfoQ, with each article containing structured metadata. The response varies slightly between regions (e.g., `cn` may lack `<description>` or `<category>` tags), but all critical information is captured in consistent XML-like elements. The schema uses a list of dictionaries to represent multiple articles, with each dictionary including all available semantic fields: title, description (including embedded image if present), category/tags, author, publish time, and URL link. This structure ensures full fidelity across both global and Chinese regional responses.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "news_list",
          "type": "List[Dict]",
          "description": "list of news articles, each containing 'title', 'description', 'category', 'author', 'publish_time', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns a list of tech news articles from InfoQ, with each article containing structured metadata. The response varies slightly between regions (e.g., `cn` may lack `<description>` or `<category>` tags), but all critical information is captured in consistent XML-like elements. The schema uses a list of dictionaries to represent multiple articles, with each dictionary including all available semantic fields: title, description (including embedded image if present), category/tags, author, publish time, and URL link. This structure ensures full fidelity across both global and Chinese regional responses."
    },
    "tool_schema": {
      "function": {
        "description": "获取 InfoQ 技术资讯，包含软件开发、架构设计、云计算、AI等企业级技术内容和前沿开发者动态",
        "name": "trends-hub-get-infoq-news",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "region": {
              "default": "cn",
              "enum": [
                "cn",
                "global"
              ],
              "type": "string"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mapas-mentais-server-inicial": {
    "tool_name": "mapas-mentais-server-inicial",
    "output_schema_raw": "**output_schema**  \ntopic: [str, the main theme or subject of the initial knowledge mind map]  \nfocus_areas: [List[Dict], list of focus areas with their respective tasks; each dict contains 'area' (e.g., 'Lembrar', 'Compreender', 'Aplicar') and 'tasks' (List[str] describing the specific actions or content types for that cognitive level)]\n\n**brief_explain**  \nThe tool generates foundational knowledge structures around a given theme, organized by cognitive levels (remember, understand, apply). The response is consistently structured around these three core areas, each containing specific instructional tasks. This schema captures both the central topic and the hierarchical breakdown of learning objectives and actions.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "topic",
          "type": "str",
          "description": "the main theme or subject of the initial knowledge mind map"
        },
        {
          "name": "focus_areas",
          "type": "List[Dict]",
          "description": "list of focus areas with their respective tasks; each dict contains 'area' (e.g., 'Lembrar', 'Compreender', 'Aplicar') and 'tasks' (List[str] describing the specific actions or content types for that cognitive level)"
        }
      ],
      "brief_explain": "The tool generates foundational knowledge structures around a given theme, organized by cognitive levels (remember, understand, apply). The response is consistently structured around these three core areas, each containing specific instructional tasks. This schema captures both the central topic and the hierarchical breakdown of learning objectives and actions."
    },
    "tool_schema": {
      "function": {
        "description": "Gera um mapa mental de conhecimentos iniciais sobre o tema.",
        "name": "mapas-mentais-server-inicial",
        "parameters": {
          "properties": {
            "tema": {
              "title": "Tema",
              "type": "string"
            }
          },
          "required": [
            "tema"
          ],
          "title": "inicialArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "ipma-weather-data-server-get_weather_stations": {
    "tool_name": "ipma-weather-data-server-get_weather_stations",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "Obter dados de observação das estações meteorológicas",
        "name": "ipma-weather-data-server-get_weather_stations",
        "parameters": {
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "united-states-weather-get_local_time": {
    "tool_name": "united-states-weather-get_local_time",
    "output_schema_raw": "**output_schema**  \nlocal_time: [str, current local date and time in the format \"M/D/YYYY, H:MM AM/PM\"]  \n\n**brief_explain**  \nThe tool returns a single piece of information—the current local time at the specified US location—as a human-readable string. All examples show the same format and no additional metadata, so a single string field suffices to capture the complete response.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "local_time",
          "type": "str",
          "description": "current local date and time in the format \"M/D/YYYY, H:MM AM/PM\""
        }
      ],
      "brief_explain": "The tool returns a single piece of information—the current local time at the specified US location—as a human-readable string. All examples show the same format and no additional metadata, so a single string field suffices to capture the complete response."
    },
    "tool_schema": {
      "function": {
        "description": "Get the current local time for a US location. Shows what time it is right now at the specified location.",
        "name": "united-states-weather-get_local_time",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "location": {
              "description": "US location as coordinates (lat,lng) in decimal degrees. Example: '40.7128,-74.0060' for New York City.",
              "type": "string"
            }
          },
          "required": [
            "location"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-zhihu-trending": {
    "tool_name": "trends-hub-get-zhihu-trending",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取知乎热榜，包含时事热点、社会话题、科技动态、娱乐八卦等多领域的热门问答和讨论的中文资讯",
        "name": "trends-hub-get-zhihu-trending",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "limit": {
              "default": 50,
              "type": "number"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "united-states-weather-find_weather_stations": {
    "tool_name": "united-states-weather-find_weather_stations",
    "output_schema_raw": "**output_schema**  \nstations: [List[Dict], list of weather stations near the specified location, each containing 'name', 'station_id', 'elevation_ft', 'distance_miles', 'latest_report_time_local', 'latest_report_age_minutes', and 'temperature_f' (if available)]  \nlocation: [str, the input geographic coordinates (latitude,longitude) in decimal degrees for which stations were found]  \ntotal_found: [int, total number of stations found matching the query near the location]  \n\n**brief_explain**  \nThe schema captures all weather stations returned by the tool with structured fields per station, including metadata like distance, elevation, and latest observation details. It preserves both the query context (location) and result summary (total_found), while representing individual station data in a consistent, accessible format.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "stations",
          "type": "List[Dict]",
          "description": "list of weather stations near the specified location, each containing 'name', 'station_id', 'elevation_ft', 'distance_miles', 'latest_report_time_local', 'latest_report_age_minutes', and 'temperature_f' (if available)"
        },
        {
          "name": "location",
          "type": "str",
          "description": "the input geographic coordinates (latitude,longitude) in decimal degrees for which stations were found"
        },
        {
          "name": "total_found",
          "type": "int",
          "description": "total number of stations found matching the query near the location"
        }
      ],
      "brief_explain": "The schema captures all weather stations returned by the tool with structured fields per station, including metadata like distance, elevation, and latest observation details. It preserves both the query context (location) and result summary (total_found), while representing individual station data in a consistent, accessible format."
    },
    "tool_schema": {
      "function": {
        "description": "Find weather observation stations near a location in the United States. Useful for getting station-specific data, finding data sources, or understanding which stations provide weather data for an area. Includes ASOS, AWOS, and other automated weather stations.",
        "name": "united-states-weather-find_weather_stations",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "limit": {
              "default": 10,
              "description": "Maximum number of stations to return (1-20, default 10). Stations are returned ordered by distance from the specified location.",
              "type": "number"
            },
            "location": {
              "description": "US location as coordinates (lat,lng) in decimal degrees. Example: '40.7128,-74.0060' for New York City. Must be within US boundaries including states, territories (PR, VI, AS, GU, MP), and coastal waters.",
              "type": "string"
            }
          },
          "required": [
            "location"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-nytimes-news": {
    "tool_name": "trends-hub-get-nytimes-news",
    "output_schema_raw": "**output_schema**  \narticles: [List[Dict], list of news articles, each containing 'title', 'description', 'category', 'author', 'publish_time', and 'link' fields]  \n\n**brief_explain**  \nThe tool returns multiple news articles in an unstructured format with consistent XML-like tags. Each article contains six key pieces of information: title, description, category (as a comma-separated string), author (may be multiple authors), publish time in RFC 2822 format, and link. These are extracted into a structured list of dictionaries to preserve all semantic content without loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "articles",
          "type": "List[Dict]",
          "description": "list of news articles, each containing 'title', 'description', 'category', 'author', 'publish_time', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns multiple news articles in an unstructured format with consistent XML-like tags. Each article contains six key pieces of information: title, description, category (as a comma-separated string), author (may be multiple authors), publish time in RFC 2822 format, and link. These are extracted into a structured list of dictionaries to preserve all semantic content without loss."
    },
    "tool_schema": {
      "function": {
        "description": "获取纽约时报新闻，包含国际政治、经济金融、社会文化、科学技术及艺术评论的高质量英文或中文国际新闻资讯",
        "name": "trends-hub-get-nytimes-news",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "region": {
              "anyOf": [
                {
                  "const": "cn",
                  "description": "中文",
                  "type": "string"
                },
                {
                  "const": "global",
                  "description": "全球",
                  "type": "string"
                }
              ],
              "default": "cn"
            },
            "section": {
              "default": "HomePage",
              "description": "分类，当 `region` 为 `cn` 时无效。可选值: Africa, Americas, ArtandDesign, Arts, AsiaPacific, Automobiles, Baseball, Books/Review, Business, Climate, CollegeBasketball, CollegeFootball, Dance, Dealbook, DiningandWine, Economy, Education, EnergyEnvironment, Europe, FashionandStyle, Golf, Health, Hockey, HomePage, Jobs, Lens, MediaandAdvertising, MiddleEast, MostEmailed, MostShared, MostViewed, Movies, Music, NYRegion, Obituaries, PersonalTech, Politics, ProBasketball, ProFootball, RealEstate, Science, SmallBusiness, Soccer, Space, Sports, SundayBookReview, Sunday-Review, Technology, Television, Tennis, Theater, TMagazine, Travel, Upshot, US, Weddings, Well, World, YourMoney",
              "type": "string"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-bilibili-rank": {
    "tool_name": "trends-hub-get-bilibili-rank",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取哔哩哔哩视频排行榜，包含全站、动画、音乐、游戏等多个分区的热门视频，反映当下年轻人的内容消费趋势",
        "name": "trends-hub-get-bilibili-rank",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "type": {
              "anyOf": [
                {
                  "const": 0,
                  "description": "全站",
                  "type": "number"
                },
                {
                  "const": 1,
                  "description": "动画",
                  "type": "number"
                },
                {
                  "const": 3,
                  "description": "音乐",
                  "type": "number"
                },
                {
                  "const": 4,
                  "description": "游戏",
                  "type": "number"
                },
                {
                  "const": 5,
                  "description": "娱乐",
                  "type": "number"
                },
                {
                  "const": 188,
                  "description": "科技",
                  "type": "number"
                },
                {
                  "const": 119,
                  "description": "鬼畜",
                  "type": "number"
                },
                {
                  "const": 129,
                  "description": "舞蹈",
                  "type": "number"
                },
                {
                  "const": 155,
                  "description": "时尚",
                  "type": "number"
                },
                {
                  "const": 160,
                  "description": "生活",
                  "type": "number"
                },
                {
                  "const": 168,
                  "description": "国创相关",
                  "type": "number"
                },
                {
                  "const": 181,
                  "description": "影视",
                  "type": "number"
                }
              ],
              "default": 0,
              "description": "排行榜分区"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-get_problem_solution": {
    "tool_name": "leetcode-get_problem_solution",
    "output_schema_raw": "**output_schema**  \ntopicId: [str, unique identifier of the solution topic]  \nsolution: [Dict, contains detailed information about the solution including title, content, tags, navigation links, and topic reference. Keys include 'title', 'slug', 'content', 'tags', 'topic', 'prev', and 'next']  \nsolution.title: [str, title of the solution article]  \nsolution.slug: [str, URL-friendly slug identifying the solution]  \nsolution.content: [str, full text content of the solution, including explanations, code snippets, and formatting in plain text with escaped characters like \\\\n and \\\\t]  \nsolution.tags: [List[Dict], list of tag objects associated with the solution, each containing a 'slug' field representing the category or technology, e.g., 'dynamic-programming', 'java']  \nsolution.tags[].slug: [str, category or technology tag for the solution]  \nsolution.topic: [Dict, reference object containing the 'id' of the current solution topic]  \nsolution.topic.id: [int, numeric ID of the current solution topic]  \nsolution.prev: [Dict or None, previous solution in navigation order; contains 'slug' and 'topicId' if exists, otherwise null]  \nsolution.prev.slug: [str, URL-friendly slug of the previous solution]  \nsolution.prev.topicId: [str, topic ID of the previous solution]  \nsolution.next: [Dict or None, next solution in navigation order; contains 'slug' and 'topicId' if exists, otherwise null]  \nsolution.next.slug: [str, URL-friendly slug of the next solution]  \nsolution.next.topicId: [str, topic ID of the next solution]\n\n**brief_explain**  \nThe output schema captures all metadata and content from a LeetCode community solution, structured into nested fields for clarity. It includes the solution’s title, content, tags, and bidirectional navigation links (prev/next), preserving full fidelity of the original response in a semantically organized format.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "topicId",
          "type": "str",
          "description": "unique identifier of the solution topic"
        },
        {
          "name": "solution",
          "type": "Dict",
          "description": "contains detailed information about the solution including title, content, tags, navigation links, and topic reference. Keys include 'title', 'slug', 'content', 'tags', 'topic', 'prev', and 'next'"
        },
        {
          "name": "solution.title",
          "type": "str",
          "description": "title of the solution article"
        },
        {
          "name": "solution.slug",
          "type": "str",
          "description": "URL-friendly slug identifying the solution"
        },
        {
          "name": "solution.content",
          "type": "str",
          "description": "full text content of the solution, including explanations, code snippets, and formatting in plain text with escaped characters like \\\\n and \\\\t"
        },
        {
          "name": "solution.tags",
          "type": "List[Dict]",
          "description": "list of tag objects associated with the solution, each containing a 'slug' field representing the category or technology, e.g., 'dynamic-programming', 'java'"
        },
        {
          "name": "solution.tags[].slug",
          "type": "str",
          "description": "category or technology tag for the solution"
        },
        {
          "name": "solution.topic",
          "type": "Dict",
          "description": "reference object containing the 'id' of the current solution topic"
        },
        {
          "name": "solution.topic.id",
          "type": "int",
          "description": "numeric ID of the current solution topic"
        },
        {
          "name": "solution.prev",
          "type": "Dict or None",
          "description": "previous solution in navigation order; contains 'slug' and 'topicId' if exists, otherwise null"
        },
        {
          "name": "solution.prev.slug",
          "type": "str",
          "description": "URL-friendly slug of the previous solution"
        },
        {
          "name": "solution.prev.topicId",
          "type": "str",
          "description": "topic ID of the previous solution"
        },
        {
          "name": "solution.next",
          "type": "Dict or None",
          "description": "next solution in navigation order; contains 'slug' and 'topicId' if exists, otherwise null"
        },
        {
          "name": "solution.next.slug",
          "type": "str",
          "description": "URL-friendly slug of the next solution"
        },
        {
          "name": "solution.next.topicId",
          "type": "str",
          "description": "topic ID of the next solution"
        }
      ],
      "brief_explain": "The output schema captures all metadata and content from a LeetCode community solution, structured into nested fields for clarity. It includes the solution’s title, content, tags, and bidirectional navigation links (prev/next), preserving full fidelity of the original response in a semantically organized format."
    },
    "tool_schema": {
      "function": {
        "description": "Retrieves the complete content and metadata of a specific solution, including the full article text, author information, and related navigation links",
        "name": "leetcode-get_problem_solution",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "topicId": {
              "description": "The unique topic ID of the solution to retrieve. This ID can be obtained from the 'topicId' field in the response of the 'list_problem_solutions' tool. Format is typically a string of numbers and letters that uniquely identifies the solution in LeetCode's database.",
              "type": "string"
            }
          },
          "required": [
            "topicId"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "airbnb-search-and-listing-details-server-airbnb_listing_details": {
    "tool_name": "airbnb-search-and-listing-details-server-airbnb_listing_details",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "Get detailed information about a specific Airbnb listing. Provide direct links to the user",
        "name": "airbnb-search-and-listing-details-server-airbnb_listing_details",
        "parameters": {
          "properties": {
            "adults": {
              "description": "Number of adults",
              "type": "number"
            },
            "checkin": {
              "description": "Check-in date (YYYY-MM-DD)",
              "type": "string"
            },
            "checkout": {
              "description": "Check-out date (YYYY-MM-DD)",
              "type": "string"
            },
            "children": {
              "description": "Number of children",
              "type": "number"
            },
            "id": {
              "description": "The Airbnb listing ID",
              "type": "string"
            },
            "ignoreRobotsText": {
              "description": "Ignore robots.txt rules for this request",
              "type": "boolean"
            },
            "infants": {
              "description": "Number of infants",
              "type": "number"
            },
            "pets": {
              "description": "Number of pets",
              "type": "number"
            }
          },
          "required": [
            "id"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-toutiao-trending": {
    "tool_name": "trends-hub-get-toutiao-trending",
    "output_schema_raw": "**output_schema**  \ntrending_list: [List[Dict], list of trending items, each with 'title', 'cover', 'popularity', and 'link' fields]  \n\n**brief_explain**  \nThe tool returns a list of trending news items from Toutiao, each containing a title, image cover URL, popularity score, and direct link. The response is unstructured text but consistently formatted with repeating XML-like tags; all entries are parsed into a structured list of dictionaries to capture every piece of information losslessly.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "trending_list",
          "type": "List[Dict]",
          "description": "list of trending items, each with 'title', 'cover', 'popularity', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns a list of trending news items from Toutiao, each containing a title, image cover URL, popularity score, and direct link. The response is unstructured text but consistently formatted with repeating XML-like tags; all entries are parsed into a structured list of dictionaries to capture every piece of information losslessly."
    },
    "tool_schema": {
      "function": {
        "description": "获取今日头条热榜，包含时政要闻、社会事件、国际新闻、科技发展及娱乐八卦等多领域的热门中文资讯",
        "name": "trends-hub-get-toutiao-trending",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mapas-mentais-server-revisa": {
    "tool_name": "mapas-mentais-server-revisa",
    "output_schema_raw": "**output_schema**  \nmain_topic: [str, main topic of the review mind map as provided in the theme]  \nfocus_instructions: [List[str], list of key structural instructions or focus points for constructing the mind map]  \nprimary_branches: [str, description indicating that subtopics are used as primary branches in the mind map]  \nsecondary_branches: [str, description indicating that details and examples are used as secondary branches in the mind map]\n\n**brief_explain**  \nThe tool generates a textual response outlining how to structure a mind map for reviewing a given topic. The output consistently includes the main topic, structural guidance, and hierarchical organization (primary and secondary branches). These elements are extracted into structured fields to preserve all semantic content in a clear, accessible format.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "main_topic",
          "type": "str",
          "description": "main topic of the review mind map as provided in the theme"
        },
        {
          "name": "focus_instructions",
          "type": "List[str]",
          "description": "list of key structural instructions or focus points for constructing the mind map"
        },
        {
          "name": "primary_branches",
          "type": "str",
          "description": "description indicating that subtopics are used as primary branches in the mind map"
        },
        {
          "name": "secondary_branches",
          "type": "str",
          "description": "description indicating that details and examples are used as secondary branches in the mind map"
        }
      ],
      "brief_explain": "The tool generates a textual response outlining how to structure a mind map for reviewing a given topic. The output consistently includes the main topic, structural guidance, and hierarchical organization (primary and secondary branches). These elements are extracted into structured fields to preserve all semantic content in a clear, accessible format."
    },
    "tool_schema": {
      "function": {
        "description": "Gera um mapa mental para revisão de conteúdo sobre um tema.",
        "name": "mapas-mentais-server-revisa",
        "parameters": {
          "properties": {
            "tema": {
              "title": "Tema",
              "type": "string"
            }
          },
          "required": [
            "tema"
          ],
          "title": "revisaArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-netease-news-trending": {
    "tool_name": "trends-hub-get-netease-news-trending",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取网易新闻热点榜，包含时政要闻、社会事件、财经资讯、科技动态及娱乐体育的全方位中文新闻资讯",
        "name": "trends-hub-get-netease-news-trending",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "okx-server-get_price": {
    "tool_name": "okx-server-get_price",
    "output_schema_raw": "**output_schema**  \ninstrument: [str, instrument ID (e.g. BTC-USDT)]  \nlastPrice: [str, latest traded price of the instrument]  \nbid: [str, current highest bid price in the order book]  \nask: [str, current lowest ask price in the order book]  \nhigh24h: [str, highest price in the last 24 hours]  \nlow24h: [str, lowest price in the last 24 hours]  \nvolume24h: [str, total trading volume in the last 24 hours]  \ntimestamp: [str, ISO 8601 timestamp of the data point, in UTC]\n\n**brief_explain**  \nThe tool returns structured price data for a given OKX trading pair, including latest trade, bid/ask spread, 24-hour high/low, volume, and timestamp. All fields are preserved as strings to maintain precision, consistent with financial API practices.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "instrument",
          "type": "str",
          "description": "instrument ID (e.g. BTC-USDT)"
        },
        {
          "name": "lastPrice",
          "type": "str",
          "description": "latest traded price of the instrument"
        },
        {
          "name": "bid",
          "type": "str",
          "description": "current highest bid price in the order book"
        },
        {
          "name": "ask",
          "type": "str",
          "description": "current lowest ask price in the order book"
        },
        {
          "name": "high24h",
          "type": "str",
          "description": "highest price in the last 24 hours"
        },
        {
          "name": "low24h",
          "type": "str",
          "description": "lowest price in the last 24 hours"
        },
        {
          "name": "volume24h",
          "type": "str",
          "description": "total trading volume in the last 24 hours"
        },
        {
          "name": "timestamp",
          "type": "str",
          "description": "ISO 8601 timestamp of the data point, in UTC"
        }
      ],
      "brief_explain": "The tool returns structured price data for a given OKX trading pair, including latest trade, bid/ask spread, 24-hour high/low, volume, and timestamp. All fields are preserved as strings to maintain precision, consistent with financial API practices."
    },
    "tool_schema": {
      "function": {
        "description": "Get latest price for an OKX instrument",
        "name": "okx-server-get_price",
        "parameters": {
          "properties": {
            "instrument": {
              "description": "Instrument ID (e.g. BTC-USDT)",
              "type": "string"
            }
          },
          "required": [
            "instrument"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "flux-imagegen-server-listImageModels": {
    "tool_name": "flux-imagegen-server-listImageModels",
    "output_schema_raw": "**output_schema**  \nmodels: [List[str], list of available image model names, such as 'flux', 'kontext', 'turbo']  \nerror: [str, error message if the request to list models failed, otherwise absent or null]\n\n**brief_explain**  \nThe tool returns either a list of available image model names or an error message on failure. The schema captures both success and error cases with separate fields to ensure lossless representation.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "models",
          "type": "List[str]",
          "description": "list of available image model names, such as 'flux', 'kontext', 'turbo'"
        },
        {
          "name": "error",
          "type": "str",
          "description": "error message if the request to list models failed, otherwise absent or null"
        }
      ],
      "brief_explain": "The tool returns either a list of available image model names or an error message on failure. The schema captures both success and error cases with separate fields to ensure lossless representation."
    },
    "tool_schema": {
      "function": {
        "description": "List available image models",
        "name": "flux-imagegen-server-listImageModels",
        "parameters": {
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-forecast-server-get_weather_by_city": {
    "tool_name": "weather-forecast-server-get_weather_by_city",
    "output_schema_raw": "**output_schema**  \nlocation: [Dict, contains 'latitude', 'longitude', 'city', 'country' fields]  \nweather: [Dict, contains 'main_condition', 'description', 'icon' fields]  \ntemperature: [Dict, contains 'current', 'feels_like', 'min', 'max', 'unit' fields]  \natmosphere: [Dict, contains 'pressure', 'humidity', 'visibility' fields]  \nwind: [Dict, contains 'speed', 'direction', 'unit' fields]  \ncloudiness: [Dict, contains 'percentage' field]  \nsun: [Dict, contains 'sunrise', 'sunset' fields (Unix timestamps)]  \ntime: [Dict, contains 'data_time', 'timezone_offset' fields (Unix timestamp and offset in seconds)]\n\n**brief_explain**  \nThe output schema captures all weather-related data returned by the tool in a structured, hierarchical format. Each major category (e.g., location, weather condition, temperature) is represented as a nested dictionary with atomic values, preserving full information from the API response without loss. Timestamps are in Unix format, and units are explicitly included where applicable.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "Dict",
          "description": "contains 'latitude', 'longitude', 'city', 'country' fields"
        },
        {
          "name": "weather",
          "type": "Dict",
          "description": "contains 'main_condition', 'description', 'icon' fields"
        },
        {
          "name": "temperature",
          "type": "Dict",
          "description": "contains 'current', 'feels_like', 'min', 'max', 'unit' fields"
        },
        {
          "name": "atmosphere",
          "type": "Dict",
          "description": "contains 'pressure', 'humidity', 'visibility' fields"
        },
        {
          "name": "wind",
          "type": "Dict",
          "description": "contains 'speed', 'direction', 'unit' fields"
        },
        {
          "name": "cloudiness",
          "type": "Dict",
          "description": "contains 'percentage' field"
        },
        {
          "name": "sun",
          "type": "Dict",
          "description": "contains 'sunrise', 'sunset' fields (Unix timestamps)"
        },
        {
          "name": "time",
          "type": "Dict",
          "description": "contains 'data_time', 'timezone_offset' fields (Unix timestamp and offset in seconds)"
        }
      ],
      "brief_explain": "The output schema captures all weather-related data returned by the tool in a structured, hierarchical format. Each major category (e.g., location, weather condition, temperature) is represented as a nested dictionary with atomic values, preserving full information from the API response without loss. Timestamps are in Unix format, and units are explicitly included where applicable."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Şehir adına göre hava durumu bilgilerini getirir.\n\n    Args:\n        city_name: Şehir adı\n        country_code: Ülke kodu (opsiyonel, örn: TR, US)\n        units: Ölçü birimi (metric, imperial, standard)\n\n    Returns:\n        JSON formatında hava durumu bilgileri\n    ",
        "name": "weather-forecast-server-get_weather_by_city",
        "parameters": {
          "properties": {
            "city_name": {
              "title": "City Name",
              "type": "string"
            },
            "country_code": {
              "default": "",
              "title": "Country Code",
              "type": "string"
            },
            "units": {
              "default": null,
              "title": "Units",
              "type": "string"
            }
          },
          "required": [
            "city_name"
          ],
          "title": "get_weather_by_cityArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-get_user_contest_ranking": {
    "tool_name": "leetcode-get_user_contest_ranking",
    "output_schema_raw": "**output_schema**  \nusername: [str, username of the LeetCode user]  \ncontestRanking: [Dict, contains user's overall contest ranking and history; includes 'userContestRanking' (detailed info on current ranking or null) and 'userContestRankingHistory' (list of past contest performances or null)]  \n\n**brief_explain**  \nThe tool returns a user's contest ranking data with their username and a nested contestRanking object, which may contain current ranking details and historical participation. When the user has not participated in contests, both fields inside contestRanking are null.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "username",
          "type": "str",
          "description": "username of the LeetCode user"
        },
        {
          "name": "contestRanking",
          "type": "Dict",
          "description": "contains user's overall contest ranking and history; includes 'userContestRanking' (detailed info on current ranking or null) and 'userContestRankingHistory' (list of past contest performances or null)"
        }
      ],
      "brief_explain": "The tool returns a user's contest ranking data with their username and a nested contestRanking object, which may contain current ranking details and historical participation. When the user has not participated in contests, both fields inside contestRanking are null."
    },
    "tool_schema": {
      "function": {
        "description": "Retrieves a user's contest ranking information on LeetCode, including overall ranking, participation history, and performance metrics across contests",
        "name": "leetcode-get_user_contest_ranking",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "attended": {
              "default": true,
              "description": "Whether to include only the contests the user has participated in (true) or all contests (false); defaults to true",
              "type": "boolean"
            },
            "username": {
              "description": "LeetCode username to retrieve contest ranking information for",
              "type": "string"
            }
          },
          "required": [
            "username"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "drawing-tool-for-ai-assistants-drawing_getCanvasPng": {
    "tool_name": "drawing-tool-for-ai-assistants-drawing_getCanvasPng",
    "output_schema_raw": "**output_schema**  \nimage_base64: [str, base64-encoded PNG image data of the current drawing canvas]\n\n**brief_explain**  \nThe tool returns a single piece of information: the canvas image as a base64-encoded PNG string. This schema captures that value in a structured, lossless way using a dedicated field.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "image_base64",
          "type": "str",
          "description": "base64-encoded PNG image data of the current drawing canvas"
        }
      ],
      "brief_explain": "The tool returns a single piece of information: the canvas image as a base64-encoded PNG string. This schema captures that value in a structured, lossless way using a dedicated field."
    },
    "tool_schema": {
      "function": {
        "description": "Get the current drawing canvas as a PNG image (base64 encoded).",
        "name": "drawing-tool-for-ai-assistants-drawing_getCanvasPng",
        "parameters": {
          "properties": {},
          "required": [],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "pokémcp-pokemon-query": {
    "tool_name": "pokémcp-pokemon-query",
    "output_schema_raw": "**output_schema**  \nsuggested_queries: [List[str], list of example Pokémon queries the tool can handle, such as looking up a Pokémon by number, getting a random Pokémon, or filtering by region/type]  \n\n**brief_explain**  \nThe tool does not return structured data for complex natural language queries and instead responds with a static list of suggested query examples when it cannot fulfill the request. All observed responses contain only these suggestion strings, so the output schema captures them as a list of actionable query templates.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "suggested_queries",
          "type": "List[str]",
          "description": "list of example Pokémon queries the tool can handle, such as looking up a Pokémon by number, getting a random Pokémon, or filtering by region/type"
        }
      ],
      "brief_explain": "The tool does not return structured data for complex natural language queries and instead responds with a static list of suggested query examples when it cannot fulfill the request. All observed responses contain only these suggestion strings, so the output schema captures them as a list of actionable query templates."
    },
    "tool_schema": {
      "function": {
        "description": "Answer natural language Pokémon queries",
        "name": "pokémcp-pokemon-query",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "query": {
              "description": "A natural language query about Pokémon",
              "type": "string"
            }
          },
          "required": [
            "query"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-thepaper-trending": {
    "tool_name": "trends-hub-get-thepaper-trending",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取澎湃新闻热榜，包含时政要闻、财经动态、社会事件、文化教育及深度报道的高质量中文新闻资讯",
        "name": "trends-hub-get-thepaper-trending",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "geeknews-server-get_weekly_news": {
    "tool_name": "geeknews-server-get_weekly_news",
    "output_schema_raw": "**output_schema**  \ntitle: [str, title of the weekly news edition]  \nnumber: [int, issue number of the weekly news]  \nid: [str, unique identifier for the weekly news edition]  \ncontent: [str, main content or summary text of the weekly news]  \nurl: [str, direct URL to view the full weekly news online]  \nitems: [List[Dict], list of featured news items in this edition, each with 'title', 'url', and 'rank' fields]\n\n**brief_explain**  \nThe tool returns structured information about a GeekNews weekly edition, including metadata (title, number, id, URL), a content summary, and a ranked list of featured items. Each item contains its title, link, and rank position. All fields are consistently present across responses.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "title",
          "type": "str",
          "description": "title of the weekly news edition"
        },
        {
          "name": "number",
          "type": "int",
          "description": "issue number of the weekly news"
        },
        {
          "name": "id",
          "type": "str",
          "description": "unique identifier for the weekly news edition"
        },
        {
          "name": "content",
          "type": "str",
          "description": "main content or summary text of the weekly news"
        },
        {
          "name": "url",
          "type": "str",
          "description": "direct URL to view the full weekly news online"
        },
        {
          "name": "items",
          "type": "List[Dict]",
          "description": "list of featured news items in this edition, each with 'title', 'url', and 'rank' fields"
        }
      ],
      "brief_explain": "The tool returns structured information about a GeekNews weekly edition, including metadata (title, number, id, URL), a content summary, and a ranked list of featured items. Each item contains its title, link, and rank position. All fields are consistently present across responses."
    },
    "tool_schema": {
      "function": {
        "description": "\n            GeekNews에서 주간 뉴스를 가져오는 도구\n            \n            Args:\n                weekly_id: 주간 뉴스 ID (빈 문자열인 경우 가장 최근 주간 뉴스를 가져옴)\n                \n            Returns:\n                Dict[str, Any]: 주간 뉴스 정보\n            ",
        "name": "geeknews-server-get_weekly_news",
        "parameters": {
          "properties": {
            "weekly_id": {
              "default": "",
              "title": "Weekly Id",
              "type": "string"
            }
          },
          "title": "get_weekly_newsArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "cooking-units-converter-convert_volume": {
    "tool_name": "cooking-units-converter-convert_volume",
    "output_schema_raw": "**output_schema**  \nvalue: [float, converted volume value rounded to three decimal places]  \nfrom_unit: [str, source volume unit (one of: ml, l, cup, tbsp, tsp)]  \nto_unit: [str, target volume unit (one of: ml, l, cup, tbsp, tsp)]  \n\n**brief_explain**  \nThe tool returns a structured response with the converted volume value and the corresponding source and target units, enabling clear interpretation of the conversion result.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "value",
          "type": "float",
          "description": "converted volume value rounded to three decimal places"
        },
        {
          "name": "from_unit",
          "type": "str",
          "description": "source volume unit (one of: ml, l, cup, tbsp, tsp)"
        },
        {
          "name": "to_unit",
          "type": "str",
          "description": "target volume unit (one of: ml, l, cup, tbsp, tsp)"
        }
      ],
      "brief_explain": "The tool returns a structured response with the converted volume value and the corresponding source and target units, enabling clear interpretation of the conversion result."
    },
    "tool_schema": {
      "function": {
        "description": "Convert between volume units (ml, l, cup, tbsp, tsp)",
        "name": "cooking-units-converter-convert_volume",
        "parameters": {
          "properties": {
            "from_unit": {
              "description": "Source volume unit (ml, l, cup, tbsp, tsp)",
              "enum": [
                "ml",
                "l",
                "cup",
                "tbsp",
                "tsp"
              ],
              "type": "string"
            },
            "to_unit": {
              "description": "Target volume unit (ml, l, cup, tbsp, tsp)",
              "enum": [
                "ml",
                "l",
                "cup",
                "tbsp",
                "tsp"
              ],
              "type": "string"
            },
            "value": {
              "description": "Volume value to convert",
              "type": "number"
            }
          },
          "required": [
            "value",
            "from_unit",
            "to_unit"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "unhcr-population-data-server-get_rsd_applications": {
    "tool_name": "unhcr-population-data-server-get_rsd_applications",
    "output_schema_raw": "**output_schema**  \npage: [int, current page number of the response]  \nmaxPages: [int, total number of pages available for the query]  \nshort-url: [str, short identifier for the query result]  \ntotal: [Dict, contains aggregate data with key 'applied' indicating total number of applications across all items]  \nitems: [List[Dict], list of individual application records, each containing detailed attributes such as year, country codes (numeric and ISO), country names, procedure type, application type, decision level, applicant category, and number of applications ('applied')]  \n\nEach item in `items` has the following structure:  \n- year: [int, the year of the application data]  \n- coo_id: [int, numeric ID of the country of origin]  \n- coa_id: [int, numeric ID of the country of asylum]  \n- coo_name: [str, full name of the country of origin]  \n- coa_name: [str, full name of the country of asylum]  \n- coo: [str, legacy code for country of origin]  \n- coa: [str, legacy code for country of asylum]  \n- coo_iso: [str, ISO3 code of the country of origin]  \n- coa_iso: [str, ISO3 code of the country of asylum]  \n- procedure_type: [str, type of asylum procedure (e.g., \"G\" for general)]  \n- app_type: [str, application type (e.g., \"N\" for new, \"A\" for appeal, \"R\" for renewal)]  \n- dec_level: [str, decision level (e.g., \"FI\" for first instance, \"JR\" for judicial review)]  \n- app_pc: [str, applicant population category (e.g., \"P\" for persons)]  \n- applied: [int, number of applications or individuals in this category]\n\n**brief_explain**  \nThe schema captures paginated UNHCR RSD application data with metadata (pagination, totals) and a list of granular records detailing asylum flows by origin and destination countries, including classification codes and application counts.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "page",
          "type": "int",
          "description": "current page number of the response"
        },
        {
          "name": "maxPages",
          "type": "int",
          "description": "total number of pages available for the query"
        },
        {
          "name": "short-url",
          "type": "str",
          "description": "short identifier for the query result"
        },
        {
          "name": "total",
          "type": "Dict",
          "description": "contains aggregate data with key 'applied' indicating total number of applications across all items"
        },
        {
          "name": "items",
          "type": "List[Dict]",
          "description": "list of individual application records, each containing detailed attributes such as year, country codes (numeric and ISO), country names, procedure type, application type, decision level, applicant category, and number of applications ('applied')"
        },
        {
          "name": "Each item in `items` has the following structure",
          "type": "",
          "description": ""
        },
        {
          "name": "- year",
          "type": "int",
          "description": "the year of the application data"
        },
        {
          "name": "- coo_id",
          "type": "int",
          "description": "numeric ID of the country of origin"
        },
        {
          "name": "- coa_id",
          "type": "int",
          "description": "numeric ID of the country of asylum"
        },
        {
          "name": "- coo_name",
          "type": "str",
          "description": "full name of the country of origin"
        },
        {
          "name": "- coa_name",
          "type": "str",
          "description": "full name of the country of asylum"
        },
        {
          "name": "- coo",
          "type": "str",
          "description": "legacy code for country of origin"
        },
        {
          "name": "- coa",
          "type": "str",
          "description": "legacy code for country of asylum"
        },
        {
          "name": "- coo_iso",
          "type": "str",
          "description": "ISO3 code of the country of origin"
        },
        {
          "name": "- coa_iso",
          "type": "str",
          "description": "ISO3 code of the country of asylum"
        },
        {
          "name": "- procedure_type",
          "type": "str",
          "description": "type of asylum procedure (e.g., \"G\" for general)"
        },
        {
          "name": "- app_type",
          "type": "str",
          "description": "application type (e.g., \"N\" for new, \"A\" for appeal, \"R\" for renewal)"
        },
        {
          "name": "- dec_level",
          "type": "str",
          "description": "decision level (e.g., \"FI\" for first instance, \"JR\" for judicial review)"
        },
        {
          "name": "- app_pc",
          "type": "str",
          "description": "applicant population category (e.g., \"P\" for persons)"
        },
        {
          "name": "- applied",
          "type": "int",
          "description": "number of applications or individuals in this category"
        }
      ],
      "brief_explain": "The schema captures paginated UNHCR RSD application data with metadata (pagination, totals) and a list of granular records detailing asylum flows by origin and destination countries, including classification codes and application counts."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get RSD application data from UNHCR.\n    \n    Args:\n        coo: Country of origin filter (ISO3 code, comma-separated for multiple) - Use for questions about asylum seekers FROM a specific country\n        coa: Country of asylum filter (ISO3 code, comma-separated for multiple) - Use for questions about asylum applications IN a specific country\n        year: Year filter (comma-separated for multiple years) - defaults to 2024 if not provided\n        coo_all:  Set to True when analyzing the ORIGIN COUNTRIES of asylum seekers\n            - Use when answering: \"Which nationalities applied for asylum in Germany?\"\n        coa_all: Set to True when analyzing the ASYLUM COUNTRIES where applications were filed\n            - Use when answering: \"Where did Syrians apply for asylum?\" (breakdown by country)\n            - Do NOT use when answering: \"How many asylum applications were filed in Germany?\"\n        \n        Important query patterns:\n        - \"How many [nationality] people applied for asylum in [country]?\"\n            → Use coo=\"[nationality code]\" and coa=\"[country code]\"\n        \n        - \"Where did [nationality] people apply for asylum?\"\n            → Use coo=\"[nationality code]\" and coa_all=True\n        \n        - \"Who applied for asylum in [country]?\"\n            → Use coa=\"[country code]\" and coo_all=True\n        \n        - \"How many asylum applications were there in [year]?\"\n            → Use year=\"[year]\" with appropriate coo/coa filters if needed\n        \n    Returns:\n        UNHCR RSD Applications data in a country of asylum\n    ",
        "name": "unhcr-population-data-server-get_rsd_applications",
        "parameters": {
          "properties": {
            "coa": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Coa"
            },
            "coa_all": {
              "default": false,
              "title": "Coa All",
              "type": "boolean"
            },
            "coo": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Coo"
            },
            "coo_all": {
              "default": false,
              "title": "Coo All",
              "type": "boolean"
            },
            "year": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Year"
            }
          },
          "title": "get_rsd_applicationsArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-forecast-server-weather_greeting": {
    "tool_name": "weather-forecast-server-weather_greeting",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "\n    Hava durumu asistanının karşılama mesajı.\n\n    Returns:\n        Dostane karşılama mesajı\n    ",
        "name": "weather-forecast-server-weather_greeting",
        "parameters": {
          "properties": {},
          "title": "weather_greetingArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-36kr-trending": {
    "tool_name": "trends-hub-get-36kr-trending",
    "output_schema_raw": "**output_schema**  \ntrending_list: [List[Dict], list of trending articles, each containing 'title', 'cover', 'author', 'publish_time', 'read_count', 'collect_count', 'comment_count', 'praise_count', and 'link' fields]  \n\n**brief_explain**  \nThe tool returns a list of trending articles from 36氪, with each article represented as a structured dictionary containing key metadata such as title, image URL, author, publication timestamp, engagement metrics (reads, collects, comments, likes), and the article link. The response is uniformly structured across all types (hot, video, comment, collect), so a single list of dictionaries captures all possible outputs without information loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "trending_list",
          "type": "List[Dict]",
          "description": "list of trending articles, each containing 'title', 'cover', 'author', 'publish_time', 'read_count', 'collect_count', 'comment_count', 'praise_count', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns a list of trending articles from 36氪, with each article represented as a structured dictionary containing key metadata such as title, image URL, author, publication timestamp, engagement metrics (reads, collects, comments, likes), and the article link. The response is uniformly structured across all types (hot, video, comment, collect), so a single list of dictionaries captures all possible outputs without information loss."
    },
    "tool_schema": {
      "function": {
        "description": "获取 36 氪热榜，提供创业、商业、科技领域的热门资讯，包含投融资动态、新兴产业分析和商业模式创新信息",
        "name": "trends-hub-get-36kr-trending",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "type": {
              "anyOf": [
                {
                  "const": "hot",
                  "description": "人气榜",
                  "type": "string"
                },
                {
                  "const": "video",
                  "description": "视频榜",
                  "type": "string"
                },
                {
                  "const": "comment",
                  "description": "热议榜",
                  "type": "string"
                },
                {
                  "const": "collect",
                  "description": "收藏榜",
                  "type": "string"
                }
              ],
              "default": "hot",
              "description": "分类"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-ifanr-news": {
    "tool_name": "trends-hub-get-ifanr-news",
    "output_schema_raw": "**output_schema**  \nnews_list: [List[Dict], list of news items, each containing 'title', 'description', and 'link' fields]  \n\n**brief_explain**  \nThe tool returns a series of news entries in an unstructured text format using `<title>`, `<description>`, and `<link>` tags. Each entry represents a distinct tech news item. The response is consistently structured across all examples, with multiple items forming a list. Therefore, the output schema captures this pattern as a list of dictionaries, where each dictionary has three fields: `title` (str), `description` (str), and `link` (str), corresponding to the semantic components of each news item. This design ensures full information preservation and structural clarity.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "news_list",
          "type": "List[Dict]",
          "description": "list of news items, each containing 'title', 'description', and 'link' fields"
        }
      ],
      "brief_explain": "The tool returns a series of news entries in an unstructured text format using `<title>`, `<description>`, and `<link>` tags. Each entry represents a distinct tech news item. The response is consistently structured across all examples, with multiple items forming a list. Therefore, the output schema captures this pattern as a list of dictionaries, where each dictionary has three fields: `title` (str), `description` (str), and `link` (str), corresponding to the semantic components of each news item. This design ensures full information preservation and structural clarity."
    },
    "tool_schema": {
      "function": {
        "description": "获取爱范儿科技快讯，包含最新的科技产品、数码设备、互联网动态等前沿科技资讯",
        "name": "trends-hub-get-ifanr-news",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "limit": {
              "default": 20,
              "type": "integer"
            },
            "offset": {
              "default": 0,
              "type": "integer"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "leetcode-get_recent_submissions": {
    "tool_name": "leetcode-get_recent_submissions",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "Retrieves a user's recent submissions on LeetCode Global, including both accepted and failed submissions with detailed metadata",
        "name": "leetcode-get_recent_submissions",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "limit": {
              "default": 10,
              "description": "Maximum number of submissions to return (optional, defaults to server-defined limit)",
              "type": "number"
            },
            "username": {
              "description": "LeetCode username to retrieve recent submissions for",
              "type": "string"
            }
          },
          "required": [
            "username"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "ipma-weather-data-server-get_locations": {
    "tool_name": "ipma-weather-data-server-get_locations",
    "output_schema_raw": "**output_schema**  \nlocations: [List[Dict], list of locations, each with 'name', 'region_id', 'latitude', 'longitude' fields]  \nregions: [List[Dict], list of regions, each with 'region_id', 'name', and 'locations' (list of location dicts with 'name', 'latitude', 'longitude') fields]\n\n**brief_explain**  \nThe tool returns a list of available weather forecast locations in Portugal, grouped by region. Each location includes its name, geographic coordinates, and associated region. The response is structured hierarchically by region and can be represented as a list of locations or grouped under regions. Both representations are included to support flat and hierarchical use cases.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "locations",
          "type": "List[Dict]",
          "description": "list of locations, each with 'name', 'region_id', 'latitude', 'longitude' fields"
        },
        {
          "name": "regions",
          "type": "List[Dict]",
          "description": "list of regions, each with 'region_id', 'name', and 'locations' (list of location dicts with 'name', 'latitude', 'longitude') fields"
        }
      ],
      "brief_explain": "The tool returns a list of available weather forecast locations in Portugal, grouped by region. Each location includes its name, geographic coordinates, and associated region. The response is structured hierarchically by region and can be represented as a list of locations or grouped under regions. Both representations are included to support flat and hierarchical use cases."
    },
    "tool_schema": {
      "function": {
        "description": "Listar todas as cidades/locais disponíveis para previsão",
        "name": "ipma-weather-data-server-get_locations",
        "parameters": {
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "dictionary-mcp-server-get_definitions": {
    "tool_name": "dictionary-mcp-server-get_definitions",
    "output_schema_raw": "**output_schema**  \ndefinitions: [List[str], list of definition strings for the requested word, each string representing a distinct meaning or usage context]\n\n**brief_explain**  \nThe tool returns multiple definitions for a given word, each capturing a different sense or contextual usage. These are best represented as a list of strings to preserve all distinct meanings without loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "definitions",
          "type": "List[str]",
          "description": "list of definition strings for the requested word, each string representing a distinct meaning or usage context"
        }
      ],
      "brief_explain": "The tool returns multiple definitions for a given word, each capturing a different sense or contextual usage. These are best represented as a list of strings to preserve all distinct meanings without loss."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get definitions for a word.\n    ",
        "name": "dictionary-mcp-server-get_definitions",
        "parameters": {
          "properties": {
            "word": {
              "title": "Word",
              "type": "string"
            }
          },
          "required": [
            "word"
          ],
          "title": "get_definitionsArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-service-get_live_temp": {
    "tool_name": "weather-service-get_live_temp",
    "output_schema_raw": "**output_schema**  \ntemperature: [float, current live temperature in degrees Celsius (or Fahrenheit, if specified by system defaults)]\n\n**brief_explain**  \nThe tool returns a single structured field containing the live temperature at the specified coordinates. All examples show a consistent JSON response with only the \"temperature\" key, indicating a simple scalar value response representing the current ambient temperature. No additional metadata (like units, timestamp, or location) is included in the response, so the schema captures only the numeric temperature value.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "temperature",
          "type": "float",
          "description": "current live temperature in degrees Celsius (or Fahrenheit, if specified by system defaults)"
        }
      ],
      "brief_explain": "The tool returns a single structured field containing the live temperature at the specified coordinates. All examples show a consistent JSON response with only the \"temperature\" key, indicating a simple scalar value response representing the current ambient temperature. No additional metadata (like units, timestamp, or location) is included in the response, so the schema captures only the numeric temperature value."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get live temperature for a given latitude and longitude.\n    ",
        "name": "weather-service-get_live_temp",
        "parameters": {
          "properties": {
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "title": "get_live_tempArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "ipma-weather-data-server-get_weather_warnings": {
    "tool_name": "ipma-weather-data-server-get_weather_warnings",
    "output_schema_raw": "**output_schema**  \nwarnings: [List[Dict], list of weather warning objects, each containing 'event', 'area', 'level', 'start_time', 'end_time', and optionally 'details' fields]  \n\n**brief_explain**  \nThe tool returns a list of active weather warnings, each with structured attributes including the type of event, geographic area code, alert level, time range, and an optional details note. All information is captured in a structured list of dictionaries to preserve completeness and enable easy parsing.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "warnings",
          "type": "List[Dict]",
          "description": "list of weather warning objects, each containing 'event', 'area', 'level', 'start_time', 'end_time', and optionally 'details' fields"
        }
      ],
      "brief_explain": "The tool returns a list of active weather warnings, each with structured attributes including the type of event, geographic area code, alert level, time range, and an optional details note. All information is captured in a structured list of dictionaries to preserve completeness and enable easy parsing."
    },
    "tool_schema": {
      "function": {
        "description": "Obter avisos meteorológicos ativos em Portugal",
        "name": "ipma-weather-data-server-get_weather_warnings",
        "parameters": {
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "cooking-units-converter-convert_temperature": {
    "tool_name": "cooking-units-converter-convert_temperature",
    "output_schema_raw": "**output_schema**  \nvalue: [float, converted temperature value]  \nfrom_unit: [str, source temperature unit, either \"C\" or \"F\"]  \nto_unit: [str, target temperature unit, either \"C\" or \"F\"]\n\n**brief_explain**  \nThe tool returns a structured response with the converted temperature value and the corresponding source and target units. All examples show consistent JSON output with these three fields, making them sufficient to capture the full response without information loss.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "value",
          "type": "float",
          "description": "converted temperature value"
        },
        {
          "name": "from_unit",
          "type": "str",
          "description": "source temperature unit, either \"C\" or \"F\""
        },
        {
          "name": "to_unit",
          "type": "str",
          "description": "target temperature unit, either \"C\" or \"F\""
        }
      ],
      "brief_explain": "The tool returns a structured response with the converted temperature value and the corresponding source and target units. All examples show consistent JSON output with these three fields, making them sufficient to capture the full response without information loss."
    },
    "tool_schema": {
      "function": {
        "description": "Convert between Celsius (C) and Fahrenheit (F) temperatures",
        "name": "cooking-units-converter-convert_temperature",
        "parameters": {
          "properties": {
            "from_unit": {
              "description": "Source temperature unit (C or F)",
              "enum": [
                "C",
                "F"
              ],
              "type": "string"
            },
            "to_unit": {
              "description": "Target temperature unit (C or F)",
              "enum": [
                "C",
                "F"
              ],
              "type": "string"
            },
            "value": {
              "description": "Temperature value to convert",
              "type": "number"
            }
          },
          "required": [
            "value",
            "from_unit",
            "to_unit"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "ipma-weather-data-server-get_weather_forecast": {
    "tool_name": "ipma-weather-data-server-get_weather_forecast",
    "output_schema_raw": "**output_schema**  \ncity: [str, name of the city for which weather forecast is provided]  \ncoordinates: [Dict, contains 'latitude' and 'longitude' as float values representing the city's geographic coordinates]  \nlast_updated: [str, timestamp of the last update in ISO 8601 format (e.g., '2025-08-10T21:31:02')]  \nforecast: [List[Dict], list of daily forecast entries, each containing 'date', 'min_temperature', 'max_temperature', 'conditions', 'precipitation_probability', and 'wind_direction']  \n\n**brief_explain**  \nThe schema captures all information from the unstructured tool responses in a structured, lossless way: city name, geographic coordinates, update timestamp, and a list of daily forecasts with temperature ranges, weather conditions, precipitation chance, and wind direction. Each forecast day is a separate object to support variable numbers of days (up to 10).",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "city",
          "type": "str",
          "description": "name of the city for which weather forecast is provided"
        },
        {
          "name": "coordinates",
          "type": "Dict",
          "description": "contains 'latitude' and 'longitude' as float values representing the city's geographic coordinates"
        },
        {
          "name": "last_updated",
          "type": "str",
          "description": "timestamp of the last update in ISO 8601 format (e.g., '2025-08-10T21:31:02')"
        },
        {
          "name": "forecast",
          "type": "List[Dict]",
          "description": "list of daily forecast entries, each containing 'date', 'min_temperature', 'max_temperature', 'conditions', 'precipitation_probability', and 'wind_direction'"
        }
      ],
      "brief_explain": "The schema captures all information from the unstructured tool responses in a structured, lossless way: city name, geographic coordinates, update timestamp, and a list of daily forecasts with temperature ranges, weather conditions, precipitation chance, and wind direction. Each forecast day is a separate object to support variable numbers of days (up to 10)."
    },
    "tool_schema": {
      "function": {
        "description": "Obter previsão meteorológica para uma cidade específica em Portugal",
        "name": "ipma-weather-data-server-get_weather_forecast",
        "parameters": {
          "properties": {
            "city": {
              "description": "Nome da cidade (ex: Lisboa, Porto, Coimbra, Faro, etc.)",
              "type": "string"
            },
            "days": {
              "default": 5,
              "description": "Número de dias de previsão (máximo 10)",
              "type": "number"
            }
          },
          "required": [
            "city"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-smzdm-rank": {
    "tool_name": "trends-hub-get-smzdm-rank",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取什么值得买热门，包含商品推荐、优惠信息、购物攻略、产品评测及消费经验分享的实用中文消费类资讯",
        "name": "trends-hub-get-smzdm-rank",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "unit": {
              "anyOf": [
                {
                  "const": 1,
                  "description": "今日热门",
                  "type": "number"
                },
                {
                  "const": 7,
                  "description": "周热门",
                  "type": "number"
                },
                {
                  "const": 30,
                  "description": "月热门",
                  "type": "number"
                }
              ],
              "default": 1
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "drawing-tool-for-ai-assistants-drawing_getCanvasData": {
    "tool_name": "drawing-tool-for-ai-assistants-drawing_getCanvasData",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "Get the current pixel data of the drawing canvas as JSON.",
        "name": "drawing-tool-for-ai-assistants-drawing_getCanvasData",
        "parameters": {
          "properties": {},
          "required": [],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mapas-mentais-server-apresenta": {
    "tool_name": "mapas-mentais-server-apresenta",
    "output_schema_raw": "**output_schema**  \ntitle: [str, title of the presentation based on the given theme]  \nfocus_topics: [List[str], list of main topics to be covered in the presentation, including: \"O que é\", \"Diferenças entre o [tema] e um conceito similar\", \"Exemplos de ferramentas\", \"Vantagens e desafios\", \"Casos de uso\"]\n\n**brief_explain**  \nThe tool generates a structured mental map for presentations, always returning a presentation title derived from the input theme and a fixed set of focus topics. These topics follow a consistent pattern across all responses, covering definition, differentiation, tools, pros/cons, and real-world applications. The output is semantically uniform and can be fully captured in two fields: a title string and a list of standardized topic strings.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "title",
          "type": "str",
          "description": "title of the presentation based on the given theme"
        },
        {
          "name": "focus_topics",
          "type": "List[str]",
          "description": "list of main topics to be covered in the presentation, including: \"O que é\", \"Diferenças entre o [tema] e um conceito similar\", \"Exemplos de ferramentas\", \"Vantagens e desafios\", \"Casos de uso\""
        }
      ],
      "brief_explain": "The tool generates a structured mental map for presentations, always returning a presentation title derived from the input theme and a fixed set of focus topics. These topics follow a consistent pattern across all responses, covering definition, differentiation, tools, pros/cons, and real-world applications. The output is semantically uniform and can be fully captured in two fields: a title string and a list of standardized topic strings."
    },
    "tool_schema": {
      "function": {
        "description": "Gera um mapa mental para apresentações sobre um tema.",
        "name": "mapas-mentais-server-apresenta",
        "parameters": {
          "properties": {
            "tema": {
              "title": "Tema",
              "type": "string"
            }
          },
          "required": [
            "tema"
          ],
          "title": "apresentaArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-gcores-new": {
    "tool_name": "trends-hub-get-gcores-new",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取机核网游戏相关资讯，包含电子游戏评测、玩家文化、游戏开发和游戏周边产品的深度内容",
        "name": "trends-hub-get-gcores-new",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "pokémcp-random-pokemon": {
    "tool_name": "pokémcp-random-pokemon",
    "output_schema_raw": "**output_schema**  \nname: [str, name of the Pokémon, including form if applicable (e.g., \"Wishiwashi-solo\")]  \nnational_dex_number: [int, the National Pokédex number (e.g., 740 for Crabominable)]  \ntypes: [List[str], list of the Pokémon's types (e.g., [\"Fighting\", \"Ice\"])]  \nheight_m: [float, height of the Pokémon in meters]  \nweight_kg: [float, weight of the Pokémon in kilograms]  \nabilities: [List[str], list of ability names (e.g., [\"Hyper-cutter\", \"Iron-fist\", \"Anger-point\"])]  \ndescription: [str, flavor text describing the Pokémon's background or behavior]\n\n**brief_explain**  \nThe output schema captures all semantic fields from the unstructured tool responses, extracting structured data such as name, ID, types, physical stats, abilities, and descriptive lore. Each concept is separated into atomic yet meaningful fields, with lists used for multi-value attributes like types and abilities, ensuring full information retention in a clean, queryable format.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "name",
          "type": "str",
          "description": "name of the Pokémon, including form if applicable (e.g., \"Wishiwashi-solo\")"
        },
        {
          "name": "national_dex_number",
          "type": "int",
          "description": "the National Pokédex number (e.g., 740 for Crabominable)"
        },
        {
          "name": "types",
          "type": "List[str]",
          "description": "list of the Pokémon's types (e.g., [\"Fighting\", \"Ice\"])"
        },
        {
          "name": "height_m",
          "type": "float",
          "description": "height of the Pokémon in meters"
        },
        {
          "name": "weight_kg",
          "type": "float",
          "description": "weight of the Pokémon in kilograms"
        },
        {
          "name": "abilities",
          "type": "List[str]",
          "description": "list of ability names (e.g., [\"Hyper-cutter\", \"Iron-fist\", \"Anger-point\"])"
        },
        {
          "name": "description",
          "type": "str",
          "description": "flavor text describing the Pokémon's background or behavior"
        }
      ],
      "brief_explain": "The output schema captures all semantic fields from the unstructured tool responses, extracting structured data such as name, ID, types, physical stats, abilities, and descriptive lore. Each concept is separated into atomic yet meaningful fields, with lists used for multi-value attributes like types and abilities, ensuring full information retention in a clean, queryable format."
    },
    "tool_schema": {
      "function": {
        "description": "Get a random Pokémon",
        "name": "pokémcp-random-pokemon",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {},
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-server-health_check": {
    "tool_name": "weather-server-health_check",
    "output_schema_raw": "**output_schema**  \nstatus: [str, status of the server (e.g., \"healthy\")]  \ntimestamp: [str, ISO 8601 timestamp indicating when the health check was performed]  \nserver: [str, name or identifier of the weather server (e.g., \"weather-mcp\")]  \nversion: [str, version string of the server software (e.g., \"1.0.0\")]  \ntools_available: [List[str], list of tool names available on the server]\n\n**brief_explain**  \nThe health check returns structured metadata about the server's operational status, including its availability, identity, version, and the set of tools it supports. Each piece of information is separated into distinct fields for clarity and programmatic access.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "status",
          "type": "str",
          "description": "status of the server (e.g., \"healthy\")"
        },
        {
          "name": "timestamp",
          "type": "str",
          "description": "ISO 8601 timestamp indicating when the health check was performed"
        },
        {
          "name": "server",
          "type": "str",
          "description": "name or identifier of the weather server (e.g., \"weather-mcp\")"
        },
        {
          "name": "version",
          "type": "str",
          "description": "version string of the server software (e.g., \"1.0.0\")"
        },
        {
          "name": "tools_available",
          "type": "List[str]",
          "description": "list of tool names available on the server"
        }
      ],
      "brief_explain": "The health check returns structured metadata about the server's operational status, including its availability, identity, version, and the set of tools it supports. Each piece of information is separated into distinct fields for clarity and programmatic access."
    },
    "tool_schema": {
      "function": {
        "description": "Health check to verify server connectivity and status.",
        "name": "weather-server-health_check",
        "parameters": {
          "properties": {},
          "title": "health_checkArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "unhcr-population-data-server-get_rsd_decisions": {
    "tool_name": "unhcr-population-data-server-get_rsd_decisions",
    "output_schema_raw": "**output_schema**  \npage: [int, current page number in paginated response]  \nmaxPages: [int, total number of pages available in the response]  \ntotal: [Dict, aggregate totals across all items, with keys 'dec_recognized', 'dec_other', 'dec_rejected', 'dec_closed', 'dec_total' representing decision outcomes]  \nitems: [List[Dict], list of individual decision records, each containing detailed attributes such as year, country codes (ISO and internal), procedure type, decision level, decision category, and counts for recognized, other, rejected, closed, and total decisions. Includes country of origin and asylum names and identifiers.]  \n\n**brief_explain**  \nThe output schema captures paginated RSD decision data from UNHCR, including summary totals and detailed per-record breakdowns by year, country of origin, country of asylum, and decision characteristics. The `items` list contains granular records with standardized fields for analysis, while `total` provides aggregated statistics. All key decision metrics are preserved in a structured, queryable format.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "page",
          "type": "int",
          "description": "current page number in paginated response"
        },
        {
          "name": "maxPages",
          "type": "int",
          "description": "total number of pages available in the response"
        },
        {
          "name": "total",
          "type": "Dict",
          "description": "aggregate totals across all items, with keys 'dec_recognized', 'dec_other', 'dec_rejected', 'dec_closed', 'dec_total' representing decision outcomes"
        },
        {
          "name": "items",
          "type": "List[Dict]",
          "description": "list of individual decision records, each containing detailed attributes such as year, country codes (ISO and internal), procedure type, decision level, decision category, and counts for recognized, other, rejected, closed, and total decisions. Includes country of origin and asylum names and identifiers."
        }
      ],
      "brief_explain": "The output schema captures paginated RSD decision data from UNHCR, including summary totals and detailed per-record breakdowns by year, country of origin, country of asylum, and decision characteristics. The `items` list contains granular records with standardized fields for analysis, while `total` provides aggregated statistics. All key decision metrics are preserved in a structured, queryable format."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get Refugee Status Determination (RSD) decision data from UNHCR.\n    \n    Args:\n        coo: Country of origin filter (ISO3 code, comma-separated for multiple) - Use for questions about asylum decisions FOR people FROM a specific country\n             Example: \"SYR\" for Syria, \"AFG,IRQ\" for Afghanistan and Iraq\n        \n        coa: Country of asylum filter (ISO3 code, comma-separated for multiple) - Use for questions about asylum decisions MADE IN a specific country\n             Example: \"DEU\" for Germany, \"FRA,ITA\" for France and Italy\n        \n        year: Year filter (comma-separated for multiple years) - defaults to 2024 if not provided\n             Example: \"2023\" or \"2022,2023,2024\" for multiple years\n        \n        coo_all: Set to True when analyzing decisions breakdown BY NATIONALITY of asylum seekers\n            - Use when answering: \"Which nationalities received asylum decisions in Germany?\"\n            - Use when answering: \"What was the approval rate for different nationalities in France?\"\n        \n        coa_all: Set to True when analyzing decisions breakdown BY COUNTRY where decisions were made\n            - Use when answering: \"Where did Syrians receive asylum decisions?\" (breakdown by country)\n            - Use when answering: \"Which countries approved/rejected the most Eritrean asylum claims?\"\n        \n    Important query patterns:\n        - \"How many [nationality] people were granted/rejected asylum in [country]?\"\n            → Use coo=\"[nationality code]\" and coa=\"[country code]\"\n        \n        - \"Where did [nationality] people receive positive/negative asylum decisions?\"\n            → Use coo=\"[nationality code]\" and coa_all=True\n        \n        - \"What was the asylum approval rate for different nationalities in [country]?\"\n            → Use coa=\"[country code]\" and coo_all=True\n        \n        - \"How many asylum decisions were made in [year]?\"\n            → Use year=\"[year]\" with appropriate coo/coa filters if needed\n        \n        - \"What was the recognition rate for [nationality] refugees in [country]?\"\n            → Use coo=\"[nationality code]\" and coa=\"[country code]\"\n        \n    Returns:\n        UNHCR RSD Decision data including counts of recognized, rejected, and otherwise closed cases\n        with statistics on recognition rates and processing efficiency\n    ",
        "name": "unhcr-population-data-server-get_rsd_decisions",
        "parameters": {
          "properties": {
            "coa": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Coa"
            },
            "coa_all": {
              "default": false,
              "title": "Coa All",
              "type": "boolean"
            },
            "coo": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Coo"
            },
            "coo_all": {
              "default": false,
              "title": "Coo All",
              "type": "boolean"
            },
            "year": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "default": null,
              "title": "Year"
            }
          },
          "title": "get_rsd_decisionsArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mcp服务-add": {
    "tool_name": "mcp服务-add",
    "output_schema_raw": "**output_schema**  \nresult: [int, the sum of the two input numbers 'a' and 'b']\n\n**brief_explain**  \nThe tool consistently returns a single integer representing the sum of the two provided integers. All examples show an unstructured plain integer response, so the output schema captures this result in one structured field.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "result",
          "type": "int",
          "description": "the sum of the two input numbers 'a' and 'b'"
        }
      ],
      "brief_explain": "The tool consistently returns a single integer representing the sum of the two provided integers. All examples show an unstructured plain integer response, so the output schema captures this result in one structured field."
    },
    "tool_schema": {
      "function": {
        "description": "Add two numbers",
        "name": "mcp服务-add",
        "parameters": {
          "properties": {
            "a": {
              "title": "A",
              "type": "integer"
            },
            "b": {
              "title": "B",
              "type": "integer"
            }
          },
          "required": [
            "a",
            "b"
          ],
          "title": "addArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "time-server-readableTime": {
    "tool_name": "time-server-readableTime",
    "output_schema_raw": "**output_schema**  \nreadable_time: [str, full human-readable date and time string in the format \"Weekday, Day Month Year Hour:Minute:Second\", e.g., \"Wednesday, 19 June 2025 15:30:45\"]  \nweekday: [str, name of the weekday, e.g., \"Tuesday\", \"Wednesday\"]  \nday: [int, day of the month as a number, e.g., 20, 31]  \nmonth: [str, full name of the month, e.g., \"June\", \"December\"]  \nyear: [int, four-digit year, e.g., 2023, 2025]  \nhour: [int, hour in 24-hour format (0–23), e.g., 15, 23]  \nminute: [int, minute (0–59), e.g., 30, 53]  \nsecond: [int, second (0–59), e.g., 45, 07]  \ntimestamp_input: [float, the Unix timestamp provided as input to the function]\n\n**brief_explain**  \nThe schema captures both the original input timestamp and fully decomposes the human-readable time string into structured fields for granular access, ensuring no information loss while enabling programmatic use of individual time components.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "readable_time",
          "type": "str",
          "description": "full human-readable date and time string in the format \"Weekday, Day Month Year Hour:Minute:Second\", e.g., \"Wednesday, 19 June 2025 15:30:45\""
        },
        {
          "name": "weekday",
          "type": "str",
          "description": "name of the weekday, e.g., \"Tuesday\", \"Wednesday\""
        },
        {
          "name": "day",
          "type": "int",
          "description": "day of the month as a number, e.g., 20, 31"
        },
        {
          "name": "month",
          "type": "str",
          "description": "full name of the month, e.g., \"June\", \"December\""
        },
        {
          "name": "year",
          "type": "int",
          "description": "four-digit year, e.g., 2023, 2025"
        },
        {
          "name": "hour",
          "type": "int",
          "description": "hour in 24-hour format (0–23), e.g., 15, 23"
        },
        {
          "name": "minute",
          "type": "int",
          "description": "minute (0–59), e.g., 30, 53"
        },
        {
          "name": "second",
          "type": "int",
          "description": "second (0–59), e.g., 45, 07"
        },
        {
          "name": "timestamp_input",
          "type": "float",
          "description": "the Unix timestamp provided as input to the function"
        }
      ],
      "brief_explain": "The schema captures both the original input timestamp and fully decomposes the human-readable time string into structured fields for granular access, ensuring no information loss while enabling programmatic use of individual time components."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Convert a Unix timestamp to a human-readable date and time string.\n    \n    Args:\n        timestamp (float): A Unix timestamp (seconds since epoch) to convert.\n            Can be obtained from the getTime() function.\n            \n    Returns:\n        str: A formatted date and time string in the format:\n            \"Weekday, Day Month Year Hour:Minute:Second\"\n            Example: \"Wednesday, 19 June 2025 15:30:45\"\n    ",
        "name": "time-server-readableTime",
        "parameters": {
          "properties": {
            "timestamp": {
              "title": "Timestamp",
              "type": "number"
            }
          },
          "required": [
            "timestamp"
          ],
          "title": "readableTimeArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "drawing-tool-for-ai-assistants-drawing_fillRectangle": {
    "tool_name": "drawing-tool-for-ai-assistants-drawing_fillRectangle",
    "output_schema_raw": "**output_schema**  \nstatus: [str, status of the operation (\"success\" or \"error\")]  \nmessage: [str, human-readable description of the result or error]  \nrectangle: [Dict, contains details about the rectangle that was filled, with 'x', 'y', 'width', 'height' fields]  \ncolor: [Dict, contains the color used for filling, with 'r', 'g', 'b', 'a' fields (a is optional)]  \noperation: [str, name of the operation performed, e.g. \"fillRectangle\"]\n\n**brief_explain**  \nThe schema captures both success and error responses in a structured way, extracting all semantic information from textual tool responses. It includes operation status, descriptive message, rectangle geometry, fill color, and operation type, ensuring no loss of information while maintaining clear separation of concerns.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "status",
          "type": "str",
          "description": "status of the operation (\"success\" or \"error\")"
        },
        {
          "name": "message",
          "type": "str",
          "description": "human-readable description of the result or error"
        },
        {
          "name": "rectangle",
          "type": "Dict",
          "description": "contains details about the rectangle that was filled, with 'x', 'y', 'width', 'height' fields"
        },
        {
          "name": "color",
          "type": "Dict",
          "description": "contains the color used for filling, with 'r', 'g', 'b', 'a' fields (a is optional)"
        },
        {
          "name": "operation",
          "type": "str",
          "description": "name of the operation performed, e.g. \"fillRectangle\""
        }
      ],
      "brief_explain": "The schema captures both success and error responses in a structured way, extracting all semantic information from textual tool responses. It includes operation status, descriptive message, rectangle geometry, fill color, and operation type, ensuring no loss of information while maintaining clear separation of concerns."
    },
    "tool_schema": {
      "function": {
        "description": "Fill a rectangle on the drawing canvas with a specified color and coordinates.",
        "name": "drawing-tool-for-ai-assistants-drawing_fillRectangle",
        "parameters": {
          "properties": {
            "color": {
              "description": "Color to fill the rectangle with (RGB)",
              "properties": {
                "a": {
                  "description": "Alpha component (0-255, optional, default 255)",
                  "type": "number"
                },
                "b": {
                  "description": "Blue component (0-255)",
                  "type": "number"
                },
                "g": {
                  "description": "Green component (0-255)",
                  "type": "number"
                },
                "r": {
                  "description": "Red component (0-255)",
                  "type": "number"
                }
              },
              "required": [
                "r",
                "g",
                "b"
              ],
              "type": "object"
            },
            "height": {
              "description": "Height of the rectangle",
              "type": "number"
            },
            "width": {
              "description": "Width of the rectangle",
              "type": "number"
            },
            "x": {
              "description": "X coordinate of the top-left corner of the rectangle",
              "type": "number"
            },
            "y": {
              "description": "Y coordinate of the top-left corner of the rectangle",
              "type": "number"
            }
          },
          "required": [
            "x",
            "y",
            "width",
            "height",
            "color"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "trends-hub-get-tencent-news-trending": {
    "tool_name": "trends-hub-get-tencent-news-trending",
    "error": "no_examples",
    "tool_schema": {
      "function": {
        "description": "获取腾讯新闻热点榜，包含国内外时事、社会热点、财经资讯、娱乐动态及体育赛事的综合性中文新闻资讯",
        "name": "trends-hub-get-tencent-news-trending",
        "parameters": {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "additionalProperties": false,
          "properties": {
            "page_size": {
              "default": 20,
              "type": "integer"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "time-server-getTime": {
    "tool_name": "time-server-getTime",
    "output_schema_raw": "**output_schema**  \ntimestamp: [float, the current time as seconds since January 1, 1970 (Unix epoch), with microsecond precision]\n\n**brief_explain**  \nThe tool returns a single numeric value representing the current Unix timestamp. This value is always a floating-point number indicating seconds since the Unix epoch, including fractional seconds for sub-second precision.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "timestamp",
          "type": "float",
          "description": "the current time as seconds since January 1, 1970 (Unix epoch), with microsecond precision"
        }
      ],
      "brief_explain": "The tool returns a single numeric value representing the current Unix timestamp. This value is always a floating-point number indicating seconds since the Unix epoch, including fractional seconds for sub-second precision."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get the current Unix timestamp.\n    \n    Returns:\n        float: The current time as seconds since January 1, 1970 (Unix epoch).\n        This is a standardized way to represent time as a single number.\n        Example: 1687302487.654321\n    ",
        "name": "time-server-getTime",
        "parameters": {
          "properties": {},
          "title": "getTimeArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-server-compare_weather": {
    "tool_name": "weather-server-compare_weather",
    "output_schema_raw": "**output_schema**  \nmetric: [str, the weather metric used for comparison (e.g., \"temperature\")]  \ncities: [List[Dict], list of city weather data, each containing 'city' (str), 'temperature' (str), 'humidity' (str), and 'wind' (str) fields]\n\n**brief_explain**  \nThe response includes a metric indicating the type of weather being compared (defaulting to temperature) and a list of cities with their respective weather conditions including temperature, humidity, and wind speed.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "metric",
          "type": "str",
          "description": "the weather metric used for comparison (e.g., \"temperature\")"
        },
        {
          "name": "cities",
          "type": "List[Dict]",
          "description": "list of city weather data, each containing 'city' (str), 'temperature' (str), 'humidity' (str), and 'wind' (str) fields"
        }
      ],
      "brief_explain": "The response includes a metric indicating the type of weather being compared (defaulting to temperature) and a list of cities with their respective weather conditions including temperature, humidity, and wind speed."
    },
    "tool_schema": {
      "function": {
        "description": "Compare weather between multiple cities.",
        "name": "weather-server-compare_weather",
        "parameters": {
          "properties": {
            "cities": {
              "items": {
                "type": "string"
              },
              "title": "Cities",
              "type": "array"
            },
            "metric": {
              "default": "temperature",
              "title": "Metric",
              "type": "string"
            }
          },
          "required": [
            "cities"
          ],
          "title": "compare_weatherArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mcp-server-test-get_forecast": {
    "tool_name": "mcp-server-test-get_forecast",
    "output_schema_raw": "**output_schema**  \nforecast_periods: [List[Dict], list of forecast periods, each containing 'period', 'temperature', 'wind', 'forecast_text', and optionally 'chance_of_precipitation' fields]  \n\n- period: [str, the time period for the forecast (e.g., \"This Afternoon\", \"Tonight\", \"Thursday\")]  \n- temperature: [str, the temperature value for the period (e.g., \"85°F\", \"63°F\")]  \n- wind: [str, description of wind conditions (e.g., \"5 to 10 mph SW\", \"0 to 5 mph SSW\")]  \n- forecast_text: [str, detailed weather description for the period (e.g., \"Sunny, with a high near 85. Southwest wind 5 to 10 mph.\")]  \n- chance_of_precipitation: [Optional[str], chance of rain or precipitation as a percentage string if mentioned (e.g., \"20%\"), otherwise absent]  \n\n**brief_explain**  \nThe tool returns a textual weather forecast divided into time periods. Each period includes temperature, wind, forecast details, and occasionally a precipitation chance. The schema structures this unstructured text into a clean list of typed dictionaries, capturing all semantic information losslessly.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "forecast_periods",
          "type": "List[Dict]",
          "description": "list of forecast periods, each containing 'period', 'temperature', 'wind', 'forecast_text', and optionally 'chance_of_precipitation' fields"
        },
        {
          "name": "- period",
          "type": "str",
          "description": "the time period for the forecast (e.g., \"This Afternoon\", \"Tonight\", \"Thursday\")"
        },
        {
          "name": "- temperature",
          "type": "str",
          "description": "the temperature value for the period (e.g., \"85°F\", \"63°F\")"
        },
        {
          "name": "- wind",
          "type": "str",
          "description": "description of wind conditions (e.g., \"5 to 10 mph SW\", \"0 to 5 mph SSW\")"
        },
        {
          "name": "- forecast_text",
          "type": "str",
          "description": "detailed weather description for the period (e.g., \"Sunny, with a high near 85. Southwest wind 5 to 10 mph.\")"
        },
        {
          "name": "- chance_of_precipitation",
          "type": "Optional[str]",
          "description": "chance of rain or precipitation as a percentage string if mentioned (e.g., \"20%\"), otherwise absent"
        }
      ],
      "brief_explain": "The tool returns a textual weather forecast divided into time periods. Each period includes temperature, wind, forecast details, and occasionally a precipitation chance. The schema structures this unstructured text into a clean list of typed dictionaries, capturing all semantic information losslessly."
    },
    "tool_schema": {
      "function": {
        "description": "Get weather forecast for a location.\n\n    Args:\n        latitude: Latitude of the location\n        longitude: Longitude of the location\n    ",
        "name": "mcp-server-test-get_forecast",
        "parameters": {
          "properties": {
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-server-ping": {
    "tool_name": "weather-server-ping",
    "output_schema_raw": "**output_schema**  \nresponse: [str, the server's response to the ping request, indicating its operational status]\n\n**brief_explain**  \nThe tool returns a simple unstructured \"pong\" response to confirm server responsiveness, which is captured as a string in the `response` field. This reflects the minimal, atomic nature of the ping operation with no additional metadata or structured content returned.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "response",
          "type": "str",
          "description": "the server's response to the ping request, indicating its operational status"
        }
      ],
      "brief_explain": "The tool returns a simple unstructured \"pong\" response to confirm server responsiveness, which is captured as a string in the `response` field. This reflects the minimal, atomic nature of the ping operation with no additional metadata or structured content returned."
    },
    "tool_schema": {
      "function": {
        "description": "Simple ping tool to test server responsiveness and prevent timeouts.",
        "name": "weather-server-ping",
        "parameters": {
          "properties": {},
          "title": "pingArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-forecast-service-get_live_temp": {
    "tool_name": "weather-forecast-service-get_live_temp",
    "output_schema_raw": "**output_schema**  \ntemperature: [float, current live temperature in degrees Celsius (or Fahrenheit, depending on service default) at the specified latitude and longitude]\n\n**brief_explain**  \nThe tool returns a single structured field containing the current temperature reading for the given geographic coordinates. All observed responses are JSON objects with a \"temperature\" key and a numeric value, indicating the core purpose is to provide real-time temperature data without additional metadata or status indicators.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "temperature",
          "type": "float",
          "description": "current live temperature in degrees Celsius (or Fahrenheit, depending on service default) at the specified latitude and longitude"
        }
      ],
      "brief_explain": "The tool returns a single structured field containing the current temperature reading for the given geographic coordinates. All observed responses are JSON objects with a \"temperature\" key and a numeric value, indicating the core purpose is to provide real-time temperature data without additional metadata or status indicators."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get live temperature for a given latitude and longitude.\n    ",
        "name": "weather-forecast-service-get_live_temp",
        "parameters": {
          "properties": {
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "title": "get_live_tempArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "drawing-tool-for-ai-assistants-drawing_generateCanvas": {
    "tool_name": "drawing-tool-for-ai-assistants-drawing_generateCanvas",
    "output_schema_raw": "**output_schema**  \nwidth: [int, width of the generated canvas in pixels]  \nheight: [int, height of the generated canvas in pixels]  \nstatus: [str, status message indicating success, e.g., \"Canvas generated\"]  \n\n**brief_explain**  \nThe tool generates a canvas with specified dimensions and returns a plain text confirmation. The response consistently includes the width and height values and implies success through fixed messaging. The schema captures these three semantic elements as structured fields to represent all information losslessly.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "width",
          "type": "int",
          "description": "width of the generated canvas in pixels"
        },
        {
          "name": "height",
          "type": "int",
          "description": "height of the generated canvas in pixels"
        },
        {
          "name": "status",
          "type": "str",
          "description": "status message indicating success, e.g., \"Canvas generated\""
        }
      ],
      "brief_explain": "The tool generates a canvas with specified dimensions and returns a plain text confirmation. The response consistently includes the width and height values and implies success through fixed messaging. The schema captures these three semantic elements as structured fields to represent all information losslessly."
    },
    "tool_schema": {
      "function": {
        "description": "Generate a new drawing canvas with specified width and height.",
        "name": "drawing-tool-for-ai-assistants-drawing_generateCanvas",
        "parameters": {
          "properties": {
            "height": {
              "description": "Height of the canvas in pixels",
              "type": "number"
            },
            "width": {
              "description": "Width of the canvas in pixels",
              "type": "number"
            }
          },
          "required": [
            "width",
            "height"
          ],
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-calculator-get_exchange_rates": {
    "tool_name": "weather-calculator-get_exchange_rates",
    "output_schema_raw": "**output_schema**  \nbase_currency: [str, base currency code for the exchange rates]  \nrates: [Dict, mapping of target currency codes (e.g., 'EUR', 'JPY') to their exchange rate values relative to the base currency]  \nlast_updated: [str, date of the last update in YYYY-MM-DD format]\n\n**brief_explain**  \nThe tool returns exchange rates from a base currency (typically USD) to multiple foreign currencies. The response includes the base currency, a dictionary of currency code to rate mappings, and the last updated date. All information is consistently structured across calls, enabling full extraction into a structured schema.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "base_currency",
          "type": "str",
          "description": "base currency code for the exchange rates"
        },
        {
          "name": "rates",
          "type": "Dict",
          "description": "mapping of target currency codes (e.g., 'EUR', 'JPY') to their exchange rate values relative to the base currency"
        },
        {
          "name": "last_updated",
          "type": "str",
          "description": "date of the last update in YYYY-MM-DD format"
        }
      ],
      "brief_explain": "The tool returns exchange rates from a base currency (typically USD) to multiple foreign currencies. The response includes the base currency, a dictionary of currency code to rate mappings, and the last updated date. All information is consistently structured across calls, enabling full extraction into a structured schema."
    },
    "tool_schema": {
      "function": {
        "description": "Get current USD exchange rates",
        "name": "weather-calculator-get_exchange_rates",
        "parameters": {
          "properties": {
            "base": {
              "default": "USD",
              "description": "Base currency (default: USD)",
              "type": "string"
            }
          },
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "books-server-get_definitions": {
    "tool_name": "books-server-get_definitions",
    "output_schema_raw": "**output_schema**  \nword: [str, the word for which definitions are retrieved]  \ndefinitions: [List[Dict], list of definition entries, each with 'part_of_speech' and 'meaning' fields]\n\n**brief_explain**  \nThe output schema captures the queried word and a structured list of its definitions, where each definition includes the part of speech (e.g., noun, adjective) and the corresponding meaning. This structure ensures lossless representation of all information present in the tool's response, supporting multiple senses across different grammatical categories.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "word",
          "type": "str",
          "description": "the word for which definitions are retrieved"
        },
        {
          "name": "definitions",
          "type": "List[Dict]",
          "description": "list of definition entries, each with 'part_of_speech' and 'meaning' fields"
        }
      ],
      "brief_explain": "The output schema captures the queried word and a structured list of its definitions, where each definition includes the part of speech (e.g., noun, adjective) and the corresponding meaning. This structure ensures lossless representation of all information present in the tool's response, supporting multiple senses across different grammatical categories."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get definitions for a word using Dictionary API.\n    \n    Args:\n        word: The word to get definitions for\n    \n    Returns:\n        Definitions of the word or error message\n    ",
        "name": "books-server-get_definitions",
        "parameters": {
          "properties": {
            "word": {
              "title": "Word",
              "type": "string"
            }
          },
          "required": [
            "word"
          ],
          "title": "get_definitionsArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "mcp-word-server-get_live_temp": {
    "tool_name": "mcp-word-server-get_live_temp",
    "output_schema_raw": "**output_schema**  \ntemperature: [float, current temperature in degrees Celsius at the specified coordinates]\n\n**brief_explain**  \nThe tool returns a single structured field containing the live temperature as a floating-point number, representing the current air temperature in Celsius at the given latitude and longitude. All observed responses are consistent with this simple structure.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "temperature",
          "type": "float",
          "description": "current temperature in degrees Celsius at the specified coordinates"
        }
      ],
      "brief_explain": "The tool returns a single structured field containing the live temperature as a floating-point number, representing the current air temperature in Celsius at the given latitude and longitude. All observed responses are consistent with this simple structure."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Get live temperature for a given latitude and longitude.\n    ",
        "name": "mcp-word-server-get_live_temp",
        "parameters": {
          "properties": {
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "title": "get_live_tempArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  },
  "weather-forecast-server-get_weather": {
    "tool_name": "weather-forecast-server-get_weather",
    "output_schema_raw": "**output_schema**  \nlocation: [str, name and country of the location in format \"City, Country\"]  \ncondition: [str, general weather condition (e.g., Açık, Kapalı, Parçalı Az Bulutlu)]  \ntemperature_current: [float, current temperature in °C]  \ntemperature_feels_like: [float, perceived temperature in °C]  \ntemperature_min: [float, minimum temperature of the day in °C]  \ntemperature_max: [float, maximum temperature of the day in °C]  \nhumidity: [int, relative humidity as a percentage]  \npressure: [int, atmospheric pressure in hPa]  \nwind_speed: [float, wind speed in m/s]  \nadvice_summary: [str, user-friendly summary or recommendations based on weather (e.g., clothing, hydration, staying in shade)]  \nadvice_tags: [List[str], list of short recommendation labels (e.g., 'Güzel hava!', 'Bol su için', 'Gölgede kalın')]  \n\n**brief_explain**  \nThe output schema captures all key weather data and user advice from the tool’s unstructured responses, extracting atomic fields for precise access while preserving both technical values and localized user guidance.",
    "output_schema_parsed": {
      "fields": [
        {
          "name": "location",
          "type": "str",
          "description": "name and country of the location in format \"City, Country\""
        },
        {
          "name": "condition",
          "type": "str",
          "description": "general weather condition (e.g., Açık, Kapalı, Parçalı Az Bulutlu)"
        },
        {
          "name": "temperature_current",
          "type": "float",
          "description": "current temperature in °C"
        },
        {
          "name": "temperature_feels_like",
          "type": "float",
          "description": "perceived temperature in °C"
        },
        {
          "name": "temperature_min",
          "type": "float",
          "description": "minimum temperature of the day in °C"
        },
        {
          "name": "temperature_max",
          "type": "float",
          "description": "maximum temperature of the day in °C"
        },
        {
          "name": "humidity",
          "type": "int",
          "description": "relative humidity as a percentage"
        },
        {
          "name": "pressure",
          "type": "int",
          "description": "atmospheric pressure in hPa"
        },
        {
          "name": "wind_speed",
          "type": "float",
          "description": "wind speed in m/s"
        },
        {
          "name": "advice_summary",
          "type": "str",
          "description": "user-friendly summary or recommendations based on weather (e.g., clothing, hydration, staying in shade)"
        },
        {
          "name": "advice_tags",
          "type": "List[str]",
          "description": "list of short recommendation labels (e.g., 'Güzel hava!', 'Bol su için', 'Gölgede kalın')"
        }
      ],
      "brief_explain": "The output schema captures all key weather data and user advice from the tool’s unstructured responses, extracting atomic fields for precise access while preserving both technical values and localized user guidance."
    },
    "tool_schema": {
      "function": {
        "description": "\n    Kullanıcı dostu hava durumu asistanı - koordinatlara göre hava durumu getirir.\n\n    Bu araç, kullanıcıyla dostane iletişim kurar ve hava durumu bilgilerini\n    anlaşılır şekilde sunar.\n\n    Args:\n        latitude: Enlem (-90 ile 90 arasında)\n        longitude: Boylam (-180 ile 180 arasında)\n\n    Returns:\n        Kullanıcı dostu formatta hava durumu bilgileri\n    ",
        "name": "weather-forecast-server-get_weather",
        "parameters": {
          "properties": {
            "latitude": {
              "title": "Latitude",
              "type": "number"
            },
            "longitude": {
              "title": "Longitude",
              "type": "number"
            }
          },
          "required": [
            "latitude",
            "longitude"
          ],
          "title": "get_weatherArguments",
          "type": "object"
        }
      },
      "type": "function"
    }
  }
}