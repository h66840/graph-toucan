from typing import Dict, List, Any, Optional
import random
import string
from datetime import datetime, timedelta


def call_external_api(tool_name: str) -> Dict[str, Any]:
    """
    Simulates fetching data from external API for getting posts by author ID.

    Returns:
        Dict with simple fields only (str, int, float, bool):
        - post_0_id (str): ID of the first post
        - post_0_content (str): Content of the first post
        - post_0_timestamp (str): ISO format timestamp of the first post
        - post_0_metadata_title (str): Title metadata of the first post
        - post_0_metadata_tags_0 (str): First tag of the first post
        - post_0_metadata_tags_1 (str): Second tag of the first post
        - post_1_id (str): ID of the second post
        - post_1_content (str): Content of the second post
        - post_1_timestamp (str): ISO format timestamp of the second post
        - post_1_metadata_title (str): Title metadata of the second post
        - post_1_metadata_tags_0 (str): First tag of the second post
        - post_1_metadata_tags_1 (str): Second tag of the second post
        - total_count (int): Total number of posts found for the author
        - author_id (str): The ID of the author whose posts were retrieved
        - limit (int): Maximum number of posts returned in this response
        - has_more (bool): Whether more posts are available beyond the current limit
        - metadata_query_time_ms (int): Query execution time in milliseconds
        - metadata_server_id (str): Server identifier that processed the request
        - metadata_filter_used (bool): Whether any filtering was applied
    """
    # Generate random data for simulation
    def random_string(length: int) -> str:
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))

    def random_timestamp() -> str:
        days_back = random.randint(0, 365)
        random_time = datetime.now() - timedelta(days=days_back)
        return random_time.isoformat()

    return {
        "post_0_id": f"post_{random_string(16)}",
        "post_0_content": f"This is a sample post content generated by author {random_string(8)}.",
        "post_0_timestamp": random_timestamp(),
        "post_0_metadata_title": f"Sample Post Title {random.randint(1, 100)}",
        "post_0_metadata_tags_0": f"tag{random.randint(1, 20)}",
        "post_0_metadata_tags_1": f"tag{random.randint(1, 20)}",
        "post_1_id": f"post_{random_string(16)}",
        "post_1_content": f"Another sample post with random content and ideas from {random_string(10)}.",
        "post_1_timestamp": random_timestamp(),
        "post_1_metadata_title": f"Another Post Title {random.randint(1, 100)}",
        "post_1_metadata_tags_0": f"topic{random.randint(1, 15)}",
        "post_1_metadata_tags_1": f"topic{random.randint(1, 15)}",
        "total_count": random.randint(5, 50),
        "author_id": f"user_{random_string(12)}",
        "limit": 2,
        "has_more": random.choice([True, False]),
        "metadata_query_time_ms": random.randint(10, 200),
        "metadata_server_id": f"server-{random.randint(1, 10)}",
        "metadata_filter_used": True
    }


def q_anon_posts_drops_server_get_posts_by_author_id(author_id: str, limit: Optional[int] = 10) -> Dict[str, Any]:
    """
    Get posts/drops by a specific author ID.

    Args:
        author_id (str): The author ID to search for
        limit (int, optional): Maximum number of results to return (default: 10)

    Returns:
        Dict containing:
        - posts (List[Dict]): List of post/drop objects returned by the author, each containing
          details such as id, content, timestamp, and metadata
        - total_count (int): Total number of posts found for the author, regardless of limit applied
        - author_id (str): The ID of the author whose posts were retrieved
        - limit (int): Maximum number of posts returned in this response
        - has_more (bool): Indicates whether more posts are available beyond the current limit
        - metadata (Dict): Additional contextual information such as query execution time,
          server info, or filtering details

    Raises:
        ValueError: If author_id is empty or None
        TypeError: If limit is not a positive integer
    """
    # Input validation
    if not author_id or not isinstance(author_id, str):
        raise ValueError("author_id must be a non-empty string")
    
    if limit is None:
        limit = 10
    elif not isinstance(limit, int) or limit <= 0:
        raise TypeError("limit must be a positive integer")

    # Call external API (simulated)
    api_data = call_external_api("q-anon-posts/drops-server-get_posts_by_author_id")

    # Construct posts list from flattened API data
    posts = []
    for i in range(2):  # We have data for 2 posts from the API
        post_key = f"post_{i}"
        metadata_key = f"{post_key}_metadata"
        
        # Only include posts up to the specified limit
        if i >= limit:
            break
            
        post = {
            "id": api_data.get(f"{post_key}_id", f"post_default_{i}"),
            "content": api_data.get(f"{post_key}_content", f"Default content for post {i}"),
            "timestamp": api_data.get(f"{post_key}_timestamp", datetime.now().isoformat()),
            "metadata": {
                "title": api_data.get(f"{metadata_key}_title", f"Default Title {i}"),
                "tags": [
                    api_data.get(f"{metadata_key}_tags_0", "general"),
                    api_data.get(f"{metadata_key}_tags_1", "sample")
                ]
            }
        }
        posts.append(post)

    # Construct metadata
    metadata = {
        "query_time_ms": api_data.get("metadata_query_time_ms", 50),
        "server_id": api_data.get("metadata_server_id", "server-1"),
        "filter_used": api_data.get("metadata_filter_used", False)
    }

    # Construct final result
    result = {
        "posts": posts,
        "total_count": api_data.get("total_count", len(posts)),
        "author_id": api_data.get("author_id", author_id),  # Use API author_id if available, otherwise input
        "limit": limit,
        "has_more": api_data.get("has_more", False),
        "metadata": metadata
    }

    return result